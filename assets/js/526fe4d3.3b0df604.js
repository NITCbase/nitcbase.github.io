"use strict";(self.webpackChunknitcbase_beta=self.webpackChunknitcbase_beta||[]).push([[2751],{3905:function(e,n,t){t.d(n,{Zo:function(){return c},kt:function(){return u}});var r=t(7294);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function a(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function f(e,n){if(null==e)return{};var t,r,i=function(e,n){if(null==e)return{};var t,r,i={},o=Object.keys(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var l=r.createContext({}),d=function(e){var n=r.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):a(a({},n),e)),t},c=function(e){var n=d(e.components);return r.createElement(l.Provider,{value:n},e.children)},T={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},s=r.forwardRef((function(e,n){var t=e.components,i=e.mdxType,o=e.originalType,l=e.parentName,c=f(e,["components","mdxType","originalType","parentName"]),s=d(t),u=i,_=s["".concat(l,".").concat(u)]||s[u]||T[u]||o;return t?r.createElement(_,a(a({ref:n},c),{},{components:t})):r.createElement(_,a({ref:n},c))}));function u(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var o=t.length,a=new Array(o);a[0]=s;var f={};for(var l in n)hasOwnProperty.call(n,l)&&(f[l]=n[l]);f.originalType=e,f.mdxType="string"==typeof e?e:i,a[1]=f;for(var d=2;d<o;d++)a[d]=t[d];return r.createElement.apply(null,a)}return r.createElement.apply(null,t)}s.displayName="MDXCreateElement"},9237:function(e,n,t){t.r(n),t.d(n,{frontMatter:function(){return f},contentTitle:function(){return l},metadata:function(){return d},toc:function(){return c},default:function(){return s}});var r=t(7462),i=t(3366),o=(t(7294),t(3905)),a=["components"],f={},l="Global Constants",d={type:"mdx",permalink:"/constants",source:"@site/src/pages/constants.md"},c=[{value:"constants.h",id:"constantsh",children:[],level:2}],T={toc:c};function s(e){var n=e.components,t=(0,i.Z)(e,a);return(0,o.kt)("wrapper",(0,r.Z)({},T,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"global-constants"},"Global Constants"),(0,o.kt)("p",null,"The constants used by various algorithms in NITCbase documentation are listed in the files errors.h(error values returned by the algorithms described in the project documentation) and constants.h(other global constants)"),(0,o.kt)("h2",{id:"constantsh"},"constants.h"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},'#ifndef NITCBASE_CONSTANTS_H\n#define NITCBASE_CONSTANTS_H\n#include <iostream>\n\n// Path to disk\n#define DISK_PATH "../Disk/disk"\n// Path to run copy of the disk\n#define DISK_RUN_COPY_PATH "../Disk/disk_run_copy"\n// Path to Files directory\n#define Files_Path "../Files/"\n// Path to Input_Files directory inside the Files directory\n#define INPUT_FILES_PATH "../Files/Input_Files/"\n// Path to Output_Files directory inside the Files directory\n#define OUTPUT_FILES_PATH "../Files/Output_Files/"\n// Path to Batch_Execution_Files directory inside the Files directory\n#define BATCH_FILES_PATH "../Files/Batch_Execution_Files/"\n\n// Size of Block in bytes\n#define BLOCK_SIZE 2048\n// Size of an attribute in bytes\n#define ATTR_SIZE 16\n// Size of Disk in bytes\n#define DISK_SIZE 16 * 1024 * 1024\n// Size of Header of a block in bytes (not including slotmap)\n#define HEADER_SIZE 32\n// Size of field Lchild in bytes\n#define LCHILD_SIZE 4\n// Size of field Rchild in bytes\n#define RCHILD_SIZE 4\n// Size of field Pblock in bytes\n#define PBLOCK_SIZE 4\n// Size of field BlockNum in bytes\n#define BLOCKNUM_SIZE 4\n// Size of field SlotNum in bytes\n#define SLOTNUM_SIZE 4\n// Size of unused field in index block (in bytes)\n#define INDEX_BLOCK_UNUSED_BYTES 8\n// Size of an Internal Index Entry in the Internal Index Block (in bytes)\n#define INTERNAL_ENTRY_SIZE 24\n// Size of an Leaf Index Entry in the Leaf Index Block (in bytes)\n#define LEAF_ENTRY_SIZE 32\n\n// Number of block in disk\n#define DISK_BLOCKS 8192\n// Total number of blocks available in the Buffer (Capacity of the Buffer in blocks)\n#define BUFFER_CAPACITY 32\n// Maximum number of relations allowed to be open and cached in Cache Layer.\n#define MAX_OPEN 12\n// Number of blocks given for Block Allocation Map in the disk\n#define BLOCK_ALLOCATION_MAP_SIZE 4\n\n// Number of attributes present in one entry / record of the Relation Catalog\n#define RELCAT_NO_ATTRS 6\n// Number of attributes present in one entry / record of the Attribute Catalog\n#define ATTRCAT_NO_ATTRS 6\n\n// Disk block number for the block of Relation Catalog\n#define RELCAT_BLOCK 4\n// Disk block number for the first block of Attribute Catalog\n#define ATTRCAT_BLOCK 5\n\n// Common variable to indicate the number of attributes present in one entry of Relation Catalog / Attribute Catalog\n#define NO_OF_ATTRS_RELCAT_ATTRCAT 6\n// Size of slotmap in both Relation Catalog and Attribute Catalog\n#define SLOTMAP_SIZE_RELCAT_ATTRCAT 20\n\n// Return variable to indicate Success\n#define SUCCESS 0\n// Return variable to indicate Failure\n#define FAILURE -1\n// Return variable to indicate Exit\n#define EXIT -2\n\n// Value to mark a slot in Slotmap as Occupied\n#define SLOT_OCCUPIED \'1\'\n// Value to mark a slot in Slotmap as Unoccupied\n#define SLOT_UNOCCUPIED \'0\'\n\n// Value to mark an entry in Open relation table of Cache as Occupied\n#define OCCUPIED 1\n// Value to mark an entry in Open relation table of Cache as Free\n#define FREE 0\n\n// Block Types\n// Block type for Record Block\n#define REC 0\n// Block type for Internal Index Block\n#define IND_INTERNAL 1\n// Block type for Leaf Index Block\n#define IND_LEAF 2\n// Block type for an Unused (Free) Block\n#define UNUSED_BLK 3\n\n// Operators\n// Equal to\n#define EQ 101\n// Less than or equal to\n#define LE 102\n// Less than\n#define LT 103\n// Greater than or equal to\n#define GE 104\n// Greater than\n#define GT 105\n// Not equal to\n#define NE 106 //if considered\n// Reset Operator (used to reset the previous hit\'s search index)\n#define RST 100 //reset op.\n// Project Operator (used for project operation)\n#define PRJCT 107\n\n// Data types\n// For an Integer or a Floating point number\n#define NUMBER 0\n// For a string of characters\n#define STRING 1\n\n// Relid for Relation catalog\n#define RELCAT_RELID 0\n// Relid for Attribute catalog\n#define ATTRCAT_RELID 1\n\n// Slot number for relation catalog in relation catalog\n#define RELCAT_SLOTNUM_FOR_RELCAT 0\n// Slot number for attribute catalog in relation catalog\n#define RELCAT_SLOTNUM_FOR_ATTRCAT 1\n\n// Indicates the Block number as Invalid.\n#define INVALID_BLOCKNUM -1\n\n// Used for internal purposes\n#define TEMP "temp"\n\n// Indexes for Relation Catalog Attributes\n// Index for the Relation Name attribute of a relation catalog entry\n#define RELCAT_REL_NAME_INDEX 0\n// Index for the #Attributes attribute of a relation catalog entry\n#define RELCAT_NO_ATTRIBUTES_INDEX 1\n// Index for the #Records attribute of a relation catalog entry\n#define RELCAT_NO_RECORDS_INDEX 2\n// Index for the First Block attribute of a relation catalog entry\n#define RELCAT_FIRST_BLOCK_INDEX 3\n// Index for the Last Block attribute of a relation catalog entry\n#define RELCAT_LAST_BLOCK_INDEX 4\n// Index for the Number of slots per block attribute of a relation catalog entry\n#define RELCAT_NO_SLOTS_PER_BLOCK_INDEX 5\n\n// Indexes for Attribute Catalog Attributes\n// Index for Relation Name attribute of an attribute catalog entry\n#define ATTRCAT_REL_NAME_INDEX 0\n// Index for Attribute Name attribute of an attribute catalog entry\n#define ATTRCAT_ATTR_NAME_INDEX 1\n// Index for Attribute Type attribute of an attribute catalog entry\n#define ATTRCAT_ATTR_TYPE_INDEX 2\n// Index for Primary Flag attribute of an attribute catalog entry\n#define ATTRCAT_PRIMARY_FLAG_INDEX 3\n// Index for Root Block attribute of an attribute catalog entry\n#define ATTRCAT_ROOT_BLOCK_INDEX 4\n// Index for Offset attribute of an attribute catalog entry\n#define ATTRCAT_OFFSET_INDEX 5\n\n// Global variables for B+ Tree Layer\n// Maximum number of keys allowed in an Internal Node of a B+ tree\n#define MAX_KEYS_INTERNAL 100\n// Index of the middle element in an Internal Node of a B+ tree\n#define MIDDLE_INDEX_INTERNAL 50\n// Maximum number of keys allowed in a Leaf Node of a B+ tree\n#define MAX_KEYS_LEAF 63\n// Index of the middle element in a Leaf Node of a B+ tree\n#define MIDDLE_INDEX_LEAF 31\n\n// Relation Catalog attribute name strings\n#define RELCAT_ATTR_RELNAME "RelName"\n#define RELCAT_ATTR_NO_ATTRIBUTES "#Attributes"\n#define RELCAT_ATTR_NO_RECORDS "#Records"\n#define RELCAT_ATTR_FIRST_BLOCK "FirstBlock"\n#define RELCAT_ATTR_LAST_BLOCK "LastBlock"\n#define RELCAT_ATTR_NO_SLOTS "#Slots"\n\n// Attribte Catalog attribute name strings\n#define ATTRCAT_ATTR_RELNAME "RelName"\n#define ATTRCAT_ATTR_ATTRIBUTE_NAME "AttributeName"\n#define ATTRCAT_ATTR_ATTRIBUTE_TYPE "AttributeType"\n#define ATTRCAT_ATTR_PRIMARY_FLAG "PrimaryFlag"\n#define ATTRCAT_ATTR_ROOT_BLOCK "RootBlock"\n#define ATTRCAT_ATTR_OFFSET "Offset"\n\n#define SET 1\n#define UNSET 0\n\n#endif //NITCBASE_CONSTANTS_H\n')))}s.isMDXComponent=!0}}]);