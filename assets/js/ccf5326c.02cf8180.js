"use strict";(self.webpackChunknitcbase=self.webpackChunknitcbase||[]).push([[2329],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>u});var a=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,r=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),h=p(n),u=o,m=h["".concat(s,".").concat(u)]||h[u]||d[u]||r;return n?a.createElement(m,i(i({ref:t},c),{},{components:n})):a.createElement(m,i({ref:t},c))}));function u(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=n.length,i=new Array(r);i[0]=h;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:o,i[1]=l;for(var p=2;p<r;p++)i[p]=n[p];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},9618:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>d,frontMatter:()=>r,metadata:()=>l,toc:()=>p});var a=n(7462),o=(n(7294),n(3905));const r={title:"Stage 3 : The Frontend Interface"},i="The Frontend Interface (6 hours)",l={unversionedId:"Roadmap/Stage03",id:"Roadmap/Stage03",title:"Stage 3 : The Frontend Interface",description:"- Learn about the operations in NITCbase and the XFS interface",source:"@site/docs/Roadmap/Stage03.md",sourceDirName:"Roadmap",slug:"/Roadmap/Stage03",permalink:"/docs/Roadmap/Stage03",draft:!1,tags:[],version:"current",frontMatter:{title:"Stage 3 : The Frontend Interface"},sidebar:"Roadmap",previous:{title:"Stage 2: Record Blocks and Catalogs",permalink:"/docs/Roadmap/Stage02"}},s={},p=[{value:"Schema Operations",id:"schema-operations",level:3},{value:"Algebra Operations",id:"algebra-operations",level:3},{value:"Architecture",id:"architecture",level:2},{value:"The XFS Interface",id:"the-xfs-interface",level:2}],c={toc:p};function d(e){let{components:t,...n}=e;return(0,o.kt)("wrapper",(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"the-frontend-interface-6-hours"},"The Frontend Interface (6 hours)"),(0,o.kt)("admonition",{title:"Learning Objectives",type:"note"},(0,o.kt)("ul",{parentName:"admonition"},(0,o.kt)("li",{parentName:"ul"},"Learn about the operations in NITCbase and the XFS interface"),(0,o.kt)("li",{parentName:"ul"},"Learn about the NITCbase architecture"))),(0,o.kt)("p",null,"We've now got a bottom-up view of how NITCbase stores and uses the data. Let's take a top-down look at all the operations our database will support and how we'll implement them."),(0,o.kt)("h1",{id:"the-commands"},"The Commands"),(0,o.kt)("h3",{id:"schema-operations"},"Schema Operations"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"Table Creation and Deletion"),(0,o.kt)("br",null),"\nCreating a table is a fundamental operation in a database. In NITCbase, table creation entails the following steps;"),(0,o.kt)("ol",{parentName:"li"},(0,o.kt)("li",{parentName:"ol"},"Ensure that a relation with the same name does not already exist by iterating through the relation catalog"),(0,o.kt)("li",{parentName:"ol"},"Insert a new entry into the relation catalog. We will have to do this operation on the relation catalog disk block directly since we do not have a relation cache entry(Why?)"),(0,o.kt)("li",{parentName:"ol"},"Insert entries for all the new attributes into the appropriate attribute catalog disk block. This too will have to be done to the disk block directly.")),(0,o.kt)("p",{parentName:"li"},"Deleting a table involves removing all the entries created during the table creation and freeing all the record blocks used by the relation.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"Table Opening and Closing"),(0,o.kt)("br",null),"\nAs we mentioned earlier, a table needs to be open for any operation to be done on it. Opening a relation involves loading the relation and attribute catalog entries for the relation into the relation and attribute cache respectively. ",(0,o.kt)("br",null),"\nClosing a relation involves writing back any changes that occured to the cache to the disk block and freeing the memory allocated during opening. ",(0,o.kt)("br",null),"\nThe relation catalog and attribute catalog will always be open and cannot be closed.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"Index Creation and Deletion"),(0,o.kt)("br",null),"\nA high-end database might automatically create and dispose of indexes as required by the program without user intervention. In NITCbase, the user is expected to decide when the index is to be created and dropped. Creating an index on an attribute involves iterating through all the records of the relation and inserting the attribute value as well as a pointer to the record into a B+ tree.",(0,o.kt)("br",null),"\nIndex deletion involves recursively deleting all the nodes of the B+ tree.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"Table and Column Rename"),(0,o.kt)("br",null),"\nNITCbase allows us to rename existing relations and their attributes. This is done by updating the relation/attribute cache."))),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Read through the documentation for ",(0,o.kt)("a",{parentName:"strong",href:"/docs/User%20Interface%20Commands/ddl"},"DDL Commands")," before proceeding further.")," We'll look into detail about the implementation of these features as we develop the ",(0,o.kt)("a",{parentName:"p",href:"/docs/Design/Schema%20Layer"},"Schema Layer"),"."),(0,o.kt)("h3",{id:"algebra-operations"},"Algebra Operations"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"Insertion"),(0,o.kt)("br",null),"\nAny database will have to support the basic operation of inserting records. Inserting records into a relation in NITCbase involves the following steps."),(0,o.kt)("ol",{parentName:"li"},(0,o.kt)("li",{parentName:"ol"},"ensuring that the relation is open and not the relation/attribute catalog"),(0,o.kt)("li",{parentName:"ol"},"fetch the relation catalog entry from the relation cache"),(0,o.kt)("li",{parentName:"ol"},"get the first record block for the relation from the relation catalog entry"),(0,o.kt)("li",{parentName:"ol"},"iterate through all the slots of the block and every subsequent record block until a free slot is found (using the slot map)"),(0,o.kt)("li",{parentName:"ol"},"if a free slot is not found, allocate a new record block for the relation and update the relation cache and the block headers to add it to the linked list."),(0,o.kt)("li",{parentName:"ol"},"set the record values in the free slot found and update the ",(0,o.kt)("inlineCode",{parentName:"li"},"numEntries")," in the relation cache and other fields in the header of the block."),(0,o.kt)("li",{parentName:"ol"},"do a b+ tree insertion if any index exists for this relation"))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"Selection"),(0,o.kt)("br",null),"\nA selection operation on a relation is used to select a subset of the records satisfying a certain condition. NITCbase supports selection with the following operators: ",(0,o.kt)("inlineCode",{parentName:"p"},"="),", ",(0,o.kt)("inlineCode",{parentName:"p"},"!="),", ",(0,o.kt)("inlineCode",{parentName:"p"},">"),", ",(0,o.kt)("inlineCode",{parentName:"p"},">="),", ",(0,o.kt)("inlineCode",{parentName:"p"},"<")," ",(0,o.kt)("inlineCode",{parentName:"p"},">="),". We will be able to select the records that fit the condition into a new relation.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"Projection"),(0,o.kt)("br",null),"\nA projection operation is used to pick a subset of attributes from a relation. The specified attributes from all the records of the relation will be projected. NITCbase supports projection into a new relation.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"Joins"),(0,o.kt)("br",null),"\nThe join operation is used to combine two relations with respect to a condition on two columns from the respective relations. NITCbase allows us to combine two relations into a new relation with the ",(0,o.kt)("inlineCode",{parentName:"p"},"=")," condition. This is called an ",(0,o.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Relational_algebra#%CE%B8-join_and_equijoin"},"equijoin"),"."))),(0,o.kt)("p",null,"NITCbase also allows you to do any combination of selection, projection and join together in a single command to create a new target relation with the specified properties."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Read through the documentation for ",(0,o.kt)("a",{parentName:"strong",href:"/docs/User%20Interface%20Commands/dml"},"DML Commands")," before proceeding further.")," We'll look into detail about the implementation of these features as we develop the ",(0,o.kt)("a",{parentName:"p",href:"/docs/Design/Algebra%20Layer"},"Algebra Layer"),"."),(0,o.kt)("details",null,(0,o.kt)("summary",null,(0,o.kt)("p",null,"Q. Consider we have a relation ",(0,o.kt)("inlineCode",{parentName:"p"},"Events")," with the attributes (",(0,o.kt)("inlineCode",{parentName:"p"},"id"),": NUM, ",(0,o.kt)("inlineCode",{parentName:"p"},"title"),": STR, ",(0,o.kt)("inlineCode",{parentName:"p"},"location"),": STR) and a relation ",(0,o.kt)("inlineCode",{parentName:"p"},"Locations")," with the attributes name(",(0,o.kt)("inlineCode",{parentName:"p"},"name"),": STR, ",(0,o.kt)("inlineCode",{parentName:"p"},"capacity"),": NUM). There are no index blocks on the disk. We run the following commands on our frontend interface."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"OPEN TABLE Events;\nSELECT * FROM Events INTO Lectures WHERE location=ELHC;\nOPEN TABLE Locations;\nOPEN TABLE Lectures;\nSELECT title, location, capacity FROM Lectures JOIN INTO LectureCapacities Locations WHERE Lectures.location = Locations.name;\nDROP TABLE Lectures;\nALTER TABLE RENAME LectureCapacities TO Lectures;\n")),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"What are the entries in the relation cache and attribute cache for the new relation?"),(0,o.kt)("li",{parentName:"ol"},"What commands could we have run to speed up these operations?"),(0,o.kt)("li",{parentName:"ol"},"Suppose we add a relation ",(0,o.kt)("inlineCode",{parentName:"li"},"Participants")," with attributes (",(0,o.kt)("inlineCode",{parentName:"li"},"regNo"),": NUM, ",(0,o.kt)("inlineCode",{parentName:"li"},"event"),": STR). Write commands to filter only the students who are attending the event happening in the location ",(0,o.kt)("em",{parentName:"li"},"Auditorium"),".")),(0,o.kt)("p",null,"(click to view answer)")),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Answer"),"(Pending)"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"relation lectures with combined attrs"),(0,o.kt)("li",{parentName:"ol"},"create indexes on join attrs (mention that we'll auto create indexes)"),(0,o.kt)("li",{parentName:"ol"},"join + select + project operations"))),(0,o.kt)("h2",{id:"architecture"},"Architecture"),(0,o.kt)("p",null,"You must now have an understanding of the functionalities provided to you by NITCbase and how they are represented in a lower level. We can now get into the finer details of our architecture. NITCbase has a 7-layer object-oriented architecture with each layer specialising in some operation. ",(0,o.kt)("strong",{parentName:"p"},"Take a look at the ",(0,o.kt)("a",{parentName:"strong",href:"/docs/Design/Architecture"},"architecture")," page before proceeding further"),". You don't need to understand everything mentioned there at this point. You could also take a look at the ",(0,o.kt)("a",{parentName:"p",href:"/docs/Design/DesignDiagram"},"system design")," to get a detailed idea about the flow of information between layers."),(0,o.kt)("h2",{id:"the-xfs-interface"},"The XFS Interface"),(0,o.kt)("p",null,"The XFS interface also supports all these commands. pending."))}d.isMDXComponent=!0}}]);