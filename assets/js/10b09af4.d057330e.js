"use strict";(self.webpackChunknitcbase=self.webpackChunknitcbase||[]).push([[7747],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>u});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var c=r.createContext({}),h=function(e){var t=r.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},d=function(e){var t=h(e.components);return r.createElement(c.Provider,{value:t},e.children)},s={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},f=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,c=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),f=h(n),u=a,b=f["".concat(c,".").concat(u)]||f[u]||s[u]||o;return n?r.createElement(b,i(i({ref:t},d),{},{components:n})):r.createElement(b,i({ref:t},d))}));function u(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,i=new Array(o);i[0]=f;var l={};for(var c in t)hasOwnProperty.call(t,c)&&(l[c]=t[c]);l.originalType=e,l.mdxType="string"==typeof e?e:a,i[1]=l;for(var h=2;h<o;h++)i[h]=n[h];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}f.displayName="MDXCreateElement"},8034:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>s,frontMatter:()=>o,metadata:()=>l,toc:()=>h});var r=n(7462),a=(n(7294),n(3905));const o={sidebar_position:6,title:"Cache Layer"},i="Cache Layer Stub Code",l={unversionedId:"Misc/stub/cache",id:"Misc/stub/cache",title:"Cache Layer",description:"RelCacheTable.cpp",source:"@site/docs/Misc/stub/cache.md",sourceDirName:"Misc/stub",slug:"/Misc/stub/cache",permalink:"/docs/Misc/stub/cache",draft:!1,tags:[],version:"current",sidebarPosition:6,frontMatter:{sidebar_position:6,title:"Cache Layer"},sidebar:"stubSidebar",previous:{title:"B+ Tree Layer",permalink:"/docs/Misc/stub/bplus"},next:{title:"Buffer Layer",permalink:"/docs/Misc/stub/buffer"}},c={},h=[{value:"RelCacheTable.cpp",id:"relcachetablecpp",level:2},{value:"AttrCacheTable.cpp",id:"attrcachetablecpp",level:2},{value:"OpenRelTable.cpp",id:"openreltablecpp",level:2}],d={toc:h};function s(e){let{components:t,...n}=e;return(0,a.kt)("wrapper",(0,r.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"cache-layer-stub-code"},"Cache Layer Stub Code"),(0,a.kt)("h2",{id:"relcachetablecpp"},"RelCacheTable.cpp"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"int RelCacheTable::getRelCatEntry(int relId, RelCatEntry *relCatBuf) {\n\n  if(/*relId is outside the range [0, MAX_OPEN-1]*/) {\n    return E_OUTOFBOUND;\n  }\n\n  if(/*entry corresponding to the relId in the Relation Cache Table is free*/) {\n    return E_RELNOTOPEN;\n  }\n\n  // copy the corresponding Relation Catalog entry in the Relation Cache Table\n  // to relCatBuf.\n\n  return SUCCESS;\n\n}\n\n\nint RelCacheTable::setRelCatEntry(int relId, RelCatEntry *relCatBuf) {\n\n  if(/*relId is outside the range [0, MAX_OPEN-1]*/) {\n    return E_OUTOFBOUND;\n  }\n\n  if(/*entry corresponding to the relId in the Relation Cache Table is free*/) {\n    return E_RELNOTOPEN;\n  }\n\n  // copy the relCatBuf to the corresponding Relation Catalog entry in\n  // the Relation Cache Table.\n\n  // set the dirty flag of the corresponding Relation Cache entry in\n  // the Relation Cache Table.\n\n  return SUCCESS;\n}\n\n\nint relCacheTable::getSearchIndex(int relid, recId *recidbuff_ptr) {\n\n  if(/*relId is outside the range [0, MAX_OPEN-1]*/) {\n    return E_OUTOFBOUND;\n  }\n\n  if(/*entry corresponding to the relId in the Relation Cache Table is free*/) {\n    return E_RELNOTOPEN;\n  }\n\n  // copy the searchIndex field of the Relation Cache entry corresponding to\n  // input relId to searchIndex variable.\n\n  return SUCCESS;\n}\n\n\nint RelCacheTable::setSearchIndex(int relId, recId *searchIndex) {\n\n  if(/*relId is outside the range [0, MAX_OPEN-1]*/) {\n    return E_OUTOFBOUND;\n  }\n\n  if(/*entry corresponding to the relId in the Relation Cache Table is free*/) {\n    return E_RELNOTOPEN;\n  }\n\n  // copy the searchIndex variable to the searchIndex field of the Relation\n  // Cache entry corresponding to input relId.\n\n  return SUCCESS;\n}\n\n\nint RelCacheTable::resetSearchIndex(int relId) {\n\n  // declare a RecId having value {-1, -1}\n  // set the search index to {-1, -1} using RelCacheTable::setSearchIndex\n  // return the value returned by setSearchIndex\n}\n\nvoid RelCacheTable::recordToRelCatEntry(union Attribute record[RELCAT_NO_ATTRS], RelCatEntry *relCatEntry){\n    // left to you\n}\n\n\nvoid relCatEntryToRecord(RelCatEntry *relCatEntry, union Attribute record[RELCAT_NO_ATTRS]){\n    // left to you\n}\n")),(0,a.kt)("h2",{id:"attrcachetablecpp"},"AttrCacheTable.cpp"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"int AttrCacheTable::getAttrCatEntry(int relId, char attrName[ATTR_SIZE]/int attrOffset, AttrCatEntry *attrCatBuf) {\n\n  if(/*relId is outside the range [0, MAX_OPEN-1]*/) {\n    return E_OUTOFBOUND;\n  }\n\n  if(/*entry corresponding to the relId in the Attribute Cache Table is free*/) {\n    return E_RELNOTOPEN;\n  }\n\n  for(/* each attribute corresponding to relation with relId */)\n  {\n    if (/* attrName/offset field of the AttrCatEntry\n        is equal to the input attrName/attrOffset */)\n    {\n      // copy that Attribute Catalog entry in the Attribute Cache Table to\n      // attrCatBuf.\n\n      return SUCCESS;\n    }\n  }\n\n  return E_ATTRNOTEXIST;\n}\n\n\nint AttrCacheTable::setAttrCatEntry(int relId, char attrName[ATTR_SIZE]/int attrOffset, AttrCatEntry *attrCatBuf) {\n\n  if(/*relId is outside the range [0, MAX_OPEN-1]*/) {\n    return E_OUTOFBOUND;\n  }\n\n  if(/*entry corresponding to the relId in the Attribute Cache Table is free*/) {\n    return E_RELNOTOPEN;\n  }\n\n  for(/* each attribute corresponding to relation with relId */)\n  {\n    if(/* the attrName/offset field of the AttrCatEntry\n       is equal to the input attrName/attrOffset */)\n    {\n      // copy the attrCatBuf to the corresponding Attribute Catalog entry in\n      // the Attribute Cache Table.\n\n      // set the dirty flag of the corresponding Attribute Cache entry in the\n      // Attribute Cache Table.\n\n      return SUCCESS;\n    }\n  }\n\n  return E_ATTRNOTEXIST;\n}\n\n\nint AttrCacheTable::getSearchIndex(int relId, char attrName[ATTR_SIZE], IndexId *searchIndex) {\n\n  if(/*relId is outside the range [0, MAX_OPEN-1]*/) {\n    return E_OUTOFBOUND;\n  }\n\n  if(/*entry corresponding to the relId in the Attribute Cache Table is free*/) {\n    return E_RELNOTOPEN;\n  }\n\n  for(/* each attribute corresponding to relation with relId */)\n  {\n    if (/* attrName/offset field of the AttrCatEntry\n        is equal to the input attrName/attrOffset */)\n    {\n      //copy the searchIndex field of the corresponding Attribute Cache entry\n      //in the Attribute Cache Table to input searchIndex variable.\n\n      return SUCCESS;\n    }\n  }\n\n  return E_ATTRNOTEXIST;\n\n}\n\n\nint AttrCacheTable::setSearchIndex(int relId, char attrName[ATTR_SIZE]/int attrOffset, IndexId *searchIndex) {\n\n  if(/*relId is outside the range [0, MAX_OPEN-1]*/) {\n    return E_OUTOFBOUND;\n  }\n\n  if(/*entry corresponding to the relId in the Attribute Cache Table is free*/) {\n    return E_RELNOTOPEN;\n  }\n\n  for(/* each attribute corresponding to relation with relId */)\n  {\n    if (/* attrName/offset field of the AttrCatEntry\n        is equal to the input attrName/attrOffset */)\n    {\n      // copy the input searchIndex variable to the searchIndex field of the\n      //corresponding Attribute Cache entry in the Attribute Cache Table.\n\n      return SUCCESS;\n    }\n  }\n\n  return E_ATTRNOTEXIST;\n}\n\n\nint AttrCacheTable::resetSearchIndex(int relId, char attrName[ATTR_SIZE]/int attrOffset) {\n\n  // declare an IndexId having value {-1, -1}\n  // set the search index to {-1, -1} using AttrCacheTable::setSearchIndex\n  // return the value returned by setSearchIndex\n}\n\n\nvoid recordToAttrCatEntry(union Attribute record[ATTRCAT_NO_ATTRS], AttrCatEntry *attrCatEntry){\n    // left to you\n}\n\n\nvoid attrCatEntryToRecord(AttrCatEntry *attrCatEntry, union Attribute record[ATTRCAT_NO_ATTRS]){\n    // left to you\n}\n")),(0,a.kt)("h2",{id:"openreltablecpp"},"OpenRelTable.cpp"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"OpenRelTable::OpenRelTable() {\n\n    /* initialize tableMetaInfo of all the entries of the Open Relation Table with\n    free as true and relName as an empty string. also set all entries in\n    AttrCacheTable::attrCache to nullptr */\n\n    /************ Setting up the Relation Cache ************/\n\n    /**** setting up Relation Catalog relation in the Relation Cache ****/\n\n    /* read the record entry at index 0 from block 4, the block corresponding to\n     Relation Catalog in the disk, and create a Relation Cache entry on it\n     using RecBuffer::getRecord() and RelCacheTable::recordToRelCatEntry().\n     update the recId field of this Relation Cache entry to {4,0}.\n     use it to set the 0th index entry of the RelCacheTable. */\n    // NOTE: use malloc to create the RelCacheEntry\n\n    /**** setting up Attribute Catalog relation in the Relation Cache ****/\n\n    /* read the record entry at index 1 from block 4, the block corresponding to\n     Relation Catalog in the disk, and create a Relation Cache entry on it\n     using RecBuffer::getRecord() and RelCacheTable::recordToRelCatEntry().\n     update the recId field of this Relation Cache entry to {4,1}.\n     use it to set the 1st index entry of the RelCacheTable.*/\n\n\n    /************ Setting up the Attribute cache ************/\n\n    /**** setting up Relation Catalog relation in the Attribute Cache ****/\n\n    // listHead will hold the head of the linked list of Attribute Cache entries.\n    AttrCacheEntry* listHead;\n\n    for i from 0 to 5:\n    {\n      /* read the ith record entry from block 5, the block corresponding to\n      Attribute Catalog in the disk, and create an Attribute Cache entry on it\n      using RecBuffer::getRecord() and AttrCacheTable::recordToAttrCatEntry().\n      update the recId field of this Attribute Cache entry to {5,i}.\n      add the Attribute Cache entry to the linked list of listHead .*/\n      // NOTE: use malloc to create the AttrCacheTable entries\n    }\n\n    // set the 0th entry of the AttrCacheTable to listHead.\n\n\n    /**** setting up Attribute Catalog relation in the Attribute Cache ****/\n\n    for i from 6 to 11:\n    {\n      /* read the ith record entry from block 5, the block corresponding to\n      Attribute Catalog in the disk, and create an Attribute Cache entry on it\n      using RecBuffer::getRecord() and AttrCacheTable::recordToAttrCatEntry().\n      update the recId field of this Attribute Cache entry to {5,i}.\n      add the Attribute Cache entry to the linked list of listHead .*/\n    }\n\n    // set the 1st entry of the AttrCacheTable to listHead.\n\n\n    /************ Setting up the Open Relation table ************/\n\n    /**** setting up Relation Catalog relation in the Open Relation Table ****/\n\n    //update the 0th entry of the tableMetaInfo with free as false and relName\n    // as 'RELATIONCAT'.\n\n    /**** setting up Attribute Catalog relation in the Open Relation Table ****/\n\n    //update the 1st entry of the tableMetaInfo with free as false and relName\n    // as 'ATTRIBUTECAT'.\n\n}\n\n\nOpenRelTable::~OpenRelTable() {\n\n    for i from 2 to MAX_OPEN-1:\n    {\n        if ith relation is still open:\n        {\n            // close the relation using openRelTable::closeRel().\n        }\n    }\n\n    /**** Closing the catalog relations in the relation cache ****/\n\n    //releasing the relation cache entry of the attribute catalog\n\n    if (/* RelCatEntry of the ATTRCAT_RELID-th RelCacheEntry has been modified */) {\n\n        /* Get the Relation Catalog entry from RelCacheTable::relCache\n        Then convert it to a record using RelCacheTable::relCatEntryToRecord(). */\n\n        // declaring an object of RecBuffer class to write back to the buffer\n        RecBuffer relCatBlock(recId.block);\n\n        // Write back to the buffer using relCatBlock.setRecord() with recId.slot\n    }\n    // free the memory dynamically allocated to this RelCacheEntry\n\n\n    //releasing the relation cache entry of the relation catalog\n\n    if(/* RelCatEntry of the RELCAT_RELID-th RelCacheEntry has been modified */) {\n\n        /* Get the Relation Catalog entry from RelCacheTable::relCache\n        Then convert it to a record using RelCacheTable::relCatEntryToRecord(). */\n\n        // declaring an object of RecBuffer class to write back to the buffer\n        RecBuffer relCatBlock(recId.block);\n\n        // Write back to the buffer using relCatBlock.setRecord() with recId.slot\n    }\n    // free the memory dynamically allocated for this RelCacheEntry\n\n\n    // free the memory allocated for the attribute cache entries of the\n    // relation catalog and the attribute catalog\n}\n\n\nint OpenRelTable::getRelId(unsigned char relName[ATTR_SIZE]) {\n\n  /* traverse through the tableMetaInfo array,\n    find the entry in the Open Relation Table corresponding to relName.*/\n\n  // if found return the relation id, else indicate that the relation do not\n  // have an entry in the Open Relation Table.\n}\n\n\nint OpenRelTable::openRel(unsigned char relName[ATTR_SIZE]) {\n\n  if(/* the relation `relName` already has an entry in the Open Relation Table */){\n    // (checked using OpenRelTable::getRelId())\n\n    // return that relation id;\n  }\n\n  /* find a free slot in the Open Relation Table\n     using OpenRelTable::getFreeOpenRelTableEntry(). */\n\n  if (/* free slot not available */){\n    return E_CACHEFULL;\n  }\n\n  // let relId be used to store the free slot.\n  int relId;\n\n  /****** Setting up Relation Cache entry for the relation ******/\n\n  /* search for the entry with relation name, relName, in the Relation Catalog using\n      BlockAccess::linearSearch().\n      Care should be taken to reset the searchIndex of the relation RELCAT_RELID\n      before calling linearSearch().*/\n\n  // relcatRecId stores the rec-id of the relation `relName` in the Relation Catalog.\n  RecId relcatRecId;\n\n  if (/* relcatRecId == {-1, -1} */) {\n    // (the relation is not found in the Relation Catalog.)\n    return E_RELNOTEXIST;\n  }\n\n  /* read the record entry corresponding to relcatRecId and create a relCacheEntry\n      on it using RecBuffer::getRecord() and RelCacheTable::recordToRelCatEntry().\n      update the recId field of this Relation Cache entry to relcatRecId.\n      use the Relation Cache entry to set the relId-th entry of the RelCacheTable.\n    NOTE: make sure to allocate memory for the RelCacheEntry using malloc()\n  */\n\n  /****** Setting up Attribute Cache entry for the relation ******/\n\n  // let listHead be used to hold the head of the linked list of attrCache entries.\n  AttrCacheEntry* listHead;\n\n  /*iterate over all the entries in the Attribute Catalog corresponding to each\n  attribute of the relation relName by multiple calls of BlockAccess::linearSearch()\n  care should be taken to reset the searchIndex of the relation, ATTRCAT_RELID,\n  corresponding to Attribute Catalog before the first call to linearSearch().*/\n  {\n      /* let attrcatRecId store a valid record id an entry of the relation, relName,\n      in the Attribute Catalog.*/\n      RecId attrcatRecId;\n\n      /* read the record entry corresponding to attrcatRecId and create an\n      Attribute Cache entry on it using RecBuffer::getRecord() and\n      AttrCacheTable::recordToAttrCatEntry().\n      update the recId field of this Attribute Cache entry to attrcatRecId.\n      add the Attribute Cache entry to the linked list of listHead .*/\n      // NOTE: make sure to allocate memory for the AttrCacheEntry using malloc()\n  }\n\n  // set the relIdth entry of the AttrCacheTable to listHead.\n\n  /****** Setting up metadata in the Open Relation Table for the relation******/\n\n  // update the relIdth entry of the tableMetaInfo with free as false and\n  // relName as the input.\n\n  return relId;\n}\n\n\nint OpenRelTable::closeRel(int relId) {\n\n    if relId is either RELCAT_RELID or ATTRCAT_RELID:\n    {\n        return E_NOTPERMITTED;\n    }\n\n    if relId is outside the range [0, MAX_OPEN-1]:\n    {\n        return E_OUTOFBOUND;\n    }\n\n    if entry corresponding to the relId in the Open Relation Table is free:\n    {\n        return E_RELNOTOPEN;\n    }\n\n    /****** Releasing the Relation Cache entry of the relation ******/\n\n    if (/* RelCatEntry of the relIdth Relation Cache entry has been modified */)\n    {\n        /* Get the Relation Catalog entry from RelCacheTable::relCache\n        Then convert it to a record using RelCacheTable::relCatEntryToRecord(). */\n\n        // declaring an object of RecBuffer class to write back to the buffer\n        RecBuffer relCatBlock(recId.block);\n\n        // Write back to the buffer using relCatBlock.setRecord() with recId.slot\n    }\n\n    // free the memory dynamically alloted to this Relation Cache entry\n    // and assign nullptr to that entry\n\n    /****** Releasing the Attribute Cache entry of the relation ******/\n\n    // for all the entries in the linked list of the relIdth Attribute Cache entry.\n    {\n        if the entry has been modified:\n        {\n            /* Get the Attribute Catalog entry from attrCache\n             Then convert it to a record using AttrCacheTable::attrCatEntryToRecord().\n             Write back that entry by instantiating RecBuffer class. Use recId\n             member field and recBuffer.setRecord() */\n        }\n\n        // free the memory dynamically alloted to this entry in Attribute\n        // Cache linked list and assign nullptr to that entry\n    }\n\n    /****** Updating metadata in the Open Relation Table of the relation  ******/\n\n    //free the relIdth entry of the tableMetaInfo.\n\n    return SUCCESS;\n}\n\n\nint OpenRelTable::getFreeOpenRelTableEntry() {\n\n  /* traverse through the tableMetaInfo array,\n    find a free entry in the Open Relation Table.*/\n\n  // if found return the relation id, else return E_CACHEFULL.\n}\n")))}s.isMDXComponent=!0}}]);