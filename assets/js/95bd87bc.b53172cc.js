"use strict";(self.webpackChunknitcbase_beta=self.webpackChunknitcbase_beta||[]).push([[8594],{3905:function(e,t,n){n.d(t,{Zo:function(){return u},kt:function(){return m}});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},l=Object.keys(e);for(r=0;r<l.length;r++)n=l[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(r=0;r<l.length;r++)n=l[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var c=r.createContext({}),s=function(e){var t=r.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},u=function(e){var t=s(e.components);return r.createElement(c.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},h=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,l=e.originalType,c=e.parentName,u=i(e,["components","mdxType","originalType","parentName"]),h=s(n),m=a,f=h["".concat(c,".").concat(m)]||h[m]||p[m]||l;return n?r.createElement(f,o(o({ref:t},u),{},{components:n})):r.createElement(f,o({ref:t},u))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var l=n.length,o=new Array(l);o[0]=h;var i={};for(var c in t)hasOwnProperty.call(t,c)&&(i[c]=t[c]);i.originalType=e,i.mdxType="string"==typeof e?e:a,o[1]=i;for(var s=2;s<l;s++)o[s]=n[s];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}h.displayName="MDXCreateElement"},208:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return i},contentTitle:function(){return c},metadata:function(){return s},toc:function(){return u},default:function(){return h}});var r=n(7462),a=n(3366),l=(n(7294),n(3905)),o=["components"],i={},c="Schema Layer Stub Code",s={type:"mdx",permalink:"/schema_stub",source:"@site/src/pages/schema_stub.md"},u=[{value:"Schema.cpp",id:"schemacpp",children:[],level:2},{value:"Schema.h",id:"schemah",children:[],level:2}],p={toc:u};function h(e){var t=e.components,n=(0,a.Z)(e,o);return(0,l.kt)("wrapper",(0,r.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,l.kt)("h1",{id:"schema-layer-stub-code"},"Schema Layer Stub Code"),(0,l.kt)("h2",{id:"schemacpp"},"Schema.cpp"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},'#include "Schema.h"\n#include "../Cache/OpenRelTable.h"\n#include "../BlockAccess/BlockAccess.h"\n\nint Schema::deleteRel(char *relName) {\n    // if the relation to delete is either Relation Catalog or Attribute Catalog, return E_NOTPERMITTED\n        // compare the input relName with "RELATIONCAT" and "ATTRIBUTECAT"\n        // OR use the following constants: RELCAT_NAME and ATTRCAT_NAME\n\n\n    // get the open relation id using appropriate method of OpenRelTable class by passing relation name as argument\n\n    // if relation is opened in open relation table, return E_RELOPEN\n\n    // Call ba_deleteRelation method of the Block Access Layer by passing appropriate argument.\n\n    // return the value returned by the above ba_deleteRelation() call\n    // Errors from ba_deleteRelation -> E_RELNOTEXIST\n        // TODO: AS OF NOW, It can return E_OUT_OF_BOUND from loadBlockAndGetBufferPtr call,\n        //  but if done properly we will not reach this point\n        //  this comes up only when BlockBuffer(or RecBuffer) was initialized with an Invalid Block Number\n}\n\nint Schema::dropIndex(char *relName, char *attr) {\n    // get the open relation id using appropriate method of OpenRelTable class by passing relation name as argument\n\n    // if relation is opened in open relation table, return E_RELOPEN\n\n    // ret = bplus_destroy(relid,attr);\n    // return ret\n}\n\nint Schema::renameAttr(char *relName, char *oldAttrName, char *newAttrName) {\n    // get the open relation id using appropriate method of OpenRelTable class by passing relation name as argument\n\n    // if relation is opened in open relation table, return E_RELOPEN\n\n    // Call ba_renameAttribute method of Block Access Layer by passing appropriate arguments.\n\n    // return the value returned by the above ba_renameAttribute() call\n}\n\nint Schema::openRel(char *relName) {\n    // Call openRelation method of OpenRelTable by passing appropriate arguments\n\n    // return the value returned by the above openRelation() call\n}\n\nint Schema::createRel(char relName[], int numOfAttributes, char attrNames[][ATTR_SIZE], int attrTypes[]) {\n    // let Attribute relNameAsAttribute\n    // copy the relName into relNameAsAttribute.sVal\n\n    // let recId targetrelid\n    RecId targetRelId{};\n\n    /*\n        Search the relation RELCAT(relId RELCAT_RELID,which is equal to 0) for attribute value attribute "RelName" = relName_val\n        using ba_search() of Block Access Layer with OP = EQ\n        Let the return value of ba_search be retVal\n    */\n    Attribute relCatSearchResultRecord[6];\n    int retVal = BlockAccess::ba_search(RELCAT_RELID, relCatSearchResultRecord, "RelName", relNameAsAttribute, EQ);\n\n    // if retVal == SUCCESS (i.e relation with relation name as relName already exists), return E_RELEXIST;\n\n    // compare every pair of attributes of attrNames[] array\n    // if any attribute names have same string value, return E_DUPLICATEATTR (i.e 2 attributes have same value)\n\n    // let Attribute relCatRecord[6] be the new record to be inserted into relation catalog corresponding to new relation)\n    // fill relCatRecord fields as given below:\n    // offset RELCAT_REL_NAME_INDEX: relName\n    // offset RELCAT_NO_ATTRIBUTES_INDEX: numOfAttributes\n    // offset RELCAT_NO_RECORDS_INDEX: 0\n    // offset RELCAT_FIRST_BLOCK_INDEX: -1\n    // offset RELCAT_LAST_BLOCK_INDEX: -1\n    // offset RELCAT_NO_SLOTS_PER_BLOCK_INDEX: floor((2016 / (16 * nAttrs + 1)))\n\n    // retVal = ba_insert(RELCAT_RELID(=0), relCatRecord);\n    // if ba_insert fails return retVal\n\n\n    // iterate through 0 to numOfAttributes - 1 :\n    for (int i = 0; i < numOfAttributes; ++i)\n    {\n        // let Attribute attrCatRecord[6] be the record in attribute catalog corresponding to i\'th Attribute)\n        // (where i is the iterator of the loop)\n        // fill attrCatRecord fields(corresponding to i\'th attribute of the relation) as given below\n        // offset ATTRCAT_REL_NAME_INDEX: relName\n        // offset ATTRCAT_ATTR_NAME_INDEX: attrNames[i]\n        // offset ATTRCAT_ATTR_TYPE_INDEX: attrTypes[i]\n        // offset ATTRCAT_PRIMARY_FLAG_INDEX: -1\n        // offset ATTRCAT_ROOT_BLOCK_INDEX: -1\n        // offset ATTRCAT_OFFSET_INDEX: i\n\n        // retval = ba_insert(ATTRCAT_RELID(=1), attrCatRecord);\n        /* if ba_insert fails:\n            delete the relation by calling deleteRel(targetrel) of schema layer\n            return E_DISKFULL\n        */\n\n    }\n\n    // return SUCCESS\n}\n\nint Schema::createIndex(char relName[ATTR_SIZE],char attr[ATTR_SIZE]) {\n    // get the relation\'s open relation id using OpenRelTable::getRelationId() method\n\n    // if relation is not open in open relation table, return E_RELNOTOPEN\n    // (check if the value returned from getRelationId function call = E_RELNOTOPEN)\n\n    // retVal = bplus_create(relId, attr);\n    // return retVal\n}\n\nint Schema::renameRel(char oldRelName[ATTR_SIZE],char newRelName[ATTR_SIZE]) {\n    // get the relation\'s open relation id using OpenRelTable::getRelationId() method\n\n    // if relation is open in open relation table, return E_RELOPEN\n    // (check if the value returned from getRelationId function call != E_RELNOTOPEN)\n\n    // retVal = BlockAccess::ba_renameRelation(oldRelName, newRelName);\n    // return retVal\n}\n\nint Schema::closeRel(char *relName) {\n    // get the relation\'s open relation id using OpenRelTable::getRelationId() method\n\n    // if relation is not open in open relation table, return E_RELNOTOPEN\n    // (check if the value returned from getRelationId function call = E_RELNOTOPEN)\n\n    // close the relId\'th relation using OpenRelTable::closeRelation(relId) of Cache Layer\n    // let the return value be retVal\n    // return retVal;\n}\n\n')),(0,l.kt)("h2",{id:"schemah"},"Schema.h"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},'#ifndef NITCBASE_SCHEMA_H\n#define NITCBASE_SCHEMA_H\n\n#include "../define/constants.h"\n#include "../define/errors.h"\n\nclass Schema {\npublic:\n\n    static int createRel(char relName[], int numOfAttributes, char attrs[][ATTR_SIZE], int attrType[]);\n    static int deleteRel(char relName[ATTR_SIZE]);\n    static int createIndex(char relName[ATTR_SIZE], char attr[ATTR_SIZE]);\n    static int dropIndex(char relName[ATTR_SIZE], char attr[ATTR_SIZE]);\n    static int renameRel(char oldRelName[ATTR_SIZE], char newRelName[ATTR_SIZE]);\n    static int renameAttr(char relName[ATTR_SIZE], char oldAttrName[ATTR_SIZE], char newAttrName[ATTR_SIZE]);\n    static int openRel(char relName[ATTR_SIZE]);\n    static int closeRel(char relName[ATTR_SIZE]);\n};\n\n#endif //NITCBASE_SCHEMA_H\n')))}h.isMDXComponent=!0}}]);