"use strict";(self.webpackChunknitcbase_beta=self.webpackChunknitcbase_beta||[]).push([[6914],{3905:function(e,t,n){n.d(t,{Zo:function(){return p},kt:function(){return h}});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},l=Object.keys(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=a.createContext({}),d=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},p=function(e){var t=d(e.components);return a.createElement(s.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,l=e.originalType,s=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),c=d(n),h=i,k=c["".concat(s,".").concat(h)]||c[h]||m[h]||l;return n?a.createElement(k,r(r({ref:t},p),{},{components:n})):a.createElement(k,r({ref:t},p))}));function h(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var l=n.length,r=new Array(l);r[0]=c;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o.mdxType="string"==typeof e?e:i,r[1]=o;for(var d=2;d<l;d++)r[d]=n[d];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},9880:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return o},contentTitle:function(){return s},metadata:function(){return d},toc:function(){return p},default:function(){return c}});var a=n(7462),i=n(3366),l=(n(7294),n(3905)),r=["components"],o={sidebar_position:3,title:"External File System Commands",tags:["External","Commands","File","System","fdisk","run","import","export","dump","exit","ls","XFS"]},s=void 0,d={unversionedId:"User Interface Commands/efs",id:"User Interface Commands/efs",isDocsHomePage:!1,title:"External File System Commands",description:"The External File System commands are used to format the disk, dump disk data structures like Block Allocation Map, Relation Catalog and Attribute Catalog, load / remove relations, list relations and copy the records of a relation on the NITCbase disk to a UNIX file. These commands are only available for the XFS Interface. The following are the External File System commands supported by NITCBase.",source:"@site/docs/User Interface Commands/efs.md",sourceDirName:"User Interface Commands",slug:"/User Interface Commands/efs",permalink:"/docs/User Interface Commands/efs",tags:[{label:"External",permalink:"/docs/tags/external"},{label:"Commands",permalink:"/docs/tags/commands"},{label:"File",permalink:"/docs/tags/file"},{label:"System",permalink:"/docs/tags/system"},{label:"fdisk",permalink:"/docs/tags/fdisk"},{label:"run",permalink:"/docs/tags/run"},{label:"import",permalink:"/docs/tags/import"},{label:"export",permalink:"/docs/tags/export"},{label:"dump",permalink:"/docs/tags/dump"},{label:"exit",permalink:"/docs/tags/exit"},{label:"ls",permalink:"/docs/tags/ls"},{label:"XFS",permalink:"/docs/tags/xfs"}],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3,title:"External File System Commands",tags:["External","Commands","File","System","fdisk","run","import","export","dump","exit","ls","XFS"]}},p=[{value:"Format Disk",id:"format-disk",children:[{value:"Description",id:"description",children:[],level:4},{value:"Syntax",id:"syntax",children:[],level:4}],level:3},{value:"Import Relation",id:"import-relation",children:[{value:"Description",id:"description-1",children:[],level:4},{value:"File Fromat",id:"file-fromat",children:[],level:4},{value:"Syntax",id:"syntax-1",children:[],level:4}],level:3},{value:"Export Relation",id:"export-relation",children:[{value:"Description",id:"description-2",children:[],level:4},{value:"Syntax",id:"syntax-2",children:[],level:4}],level:3},{value:"List Relation Names",id:"list-relation-names",children:[{value:"Description",id:"description-3",children:[],level:4},{value:"Syntax",id:"syntax-3",children:[],level:4}],level:3},{value:"Dump Block Allocation Map",id:"dump-block-allocation-map",children:[{value:"Description",id:"description-4",children:[],level:4},{value:"Syntax",id:"syntax-4",children:[],level:4}],level:3},{value:"Dump Relation Catalog",id:"dump-relation-catalog",children:[{value:"Description",id:"description-5",children:[],level:4},{value:"Syntax",id:"syntax-5",children:[],level:4}],level:3},{value:"Dump Attribute Catalog",id:"dump-attribute-catalog",children:[{value:"Description",id:"description-6",children:[],level:4},{value:"Syntax",id:"syntax-6",children:[],level:4}],level:3},{value:"Exit",id:"exit",children:[{value:"Description",id:"description-7",children:[],level:4},{value:"Syntax",id:"syntax-7",children:[],level:4}],level:3},{value:"Print B+ Tree",id:"print-b-tree",children:[{value:"Description",id:"description-8",children:[],level:4},{value:"Syntax",id:"syntax-8",children:[],level:4}],level:3},{value:"Print B+ Blocks",id:"print-b-blocks",children:[{value:"Description",id:"description-9",children:[],level:4},{value:"Syntax",id:"syntax-9",children:[],level:4}],level:3}],m={toc:p};function c(e){var t=e.components,n=(0,i.Z)(e,r);return(0,l.kt)("wrapper",(0,a.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,l.kt)("p",null,"The External File System commands are used to format the disk, dump disk data structures like Block Allocation Map, Relation Catalog and Attribute Catalog, load / remove relations, list relations and copy the records of a relation on the NITCbase disk to a UNIX file. These commands are only available for the XFS Interface. The following are the External File System commands supported by NITCBase."),(0,l.kt)("h3",{id:"format-disk"},"Format Disk"),(0,l.kt)("h4",{id:"description"},"Description"),(0,l.kt)("p",null,"This command is used to create a simulated disk or to format the disk if already it already exists. On the newly created/formatted disk, initialization of ",(0,l.kt)("em",{parentName:"p"},"disk data structures"),", namely - ",(0,l.kt)("inlineCode",{parentName:"p"},"Block allocation map"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"Relation catalog")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"Attribute catalog")," are done according to the specification for disk model given in the ",(0,l.kt)("a",{parentName:"p",href:"https://nitcbase.github.io/storage-model.html"},"Physical layer")," of NITCBase. The disk is simulated on a binary file called ",(0,l.kt)("inlineCode",{parentName:"p"},"disk")," which is located at ",(0,l.kt)("inlineCode",{parentName:"p"},"$HOME/NITCBase/Disk/")," once it is created."),(0,l.kt)("h4",{id:"syntax"},"Syntax"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"fdisk\n")),(0,l.kt)("h3",{id:"import-relation"},"Import Relation"),(0,l.kt)("h4",{id:"description-1"},"Description"),(0,l.kt)("p",null,"This command is used to load relations from the UNIX filesystem to the NITCbase disk. The argument ",(0,l.kt)("inlineCode",{parentName:"p"},"filename")," specifies the name of the ",(0,l.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Comma-separated_values"},"CSV")," (Comma Separated Values) file which contains the contents of the relation to be uploaded. The file names should ",(0,l.kt)("strong",{parentName:"p"},"not")," contain ",(0,l.kt)("inlineCode",{parentName:"p"},"whitespaces")," or any special characters except ",(0,l.kt)("inlineCode",{parentName:"p"},"-")," or ",(0,l.kt)("inlineCode",{parentName:"p"},"_"),". The command checks the size of the relation in the ",(0,l.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Comma-separated_values"},"CSV")," file, allocates the required number of blocks for the relation, updates the ",(0,l.kt)("inlineCode",{parentName:"p"},"Block allocation map"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"Relation catalog")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"Attribute catalog"),"."),(0,l.kt)("h4",{id:"file-fromat"},"File Fromat"),(0,l.kt)("p",null,"The records to be added in the relation must be in a ",(0,l.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Comma-separated_values"},"CSV")," file.\nThe CSV file ",(0,l.kt)("strong",{parentName:"p"},"must follow")," the following format:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"The first line must contain the names of the attributes of the relation separated by commas."),(0,l.kt)("li",{parentName:"ul"},"Second line onwards records are specified as ",(0,l.kt)("em",{parentName:"li"},"comma-seperated attribute values"),", in the ",(0,l.kt)("strong",{parentName:"li"},"same order")," as the attrbiutes listed in the first line."),(0,l.kt)("li",{parentName:"ul"},"Only ",(0,l.kt)("strong",{parentName:"li"},"one record is allowed per line."))),(0,l.kt)("h4",{id:"syntax-1"},"Syntax"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"import filename\n")),(0,l.kt)("div",{className:"admonition admonition-info alert alert--info"},(0,l.kt)("div",{parentName:"div",className:"admonition-heading"},(0,l.kt)("h5",{parentName:"div"},(0,l.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,l.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,l.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"}))),"info")),(0,l.kt)("div",{parentName:"div",className:"admonition-content"},(0,l.kt)("ul",{parentName:"div"},(0,l.kt)("li",{parentName:"ul"},"The data types of the attributes in the first line are inferred from the values of the corresponding attributes on the second line of the CSV file."),(0,l.kt)("li",{parentName:"ul"},"The name of the CSV file must be the same as the relation to be imported to the disk. i.e. the CSV file name should be in the format ",(0,l.kt)("inlineCode",{parentName:"li"},"relname.csv"),", where relname is taken as name of the new relation."),(0,l.kt)("li",{parentName:"ul"},"First ",(0,l.kt)("strong",{parentName:"li"},"15 characters of name of file is taken as the relation name"),". Similarly, only the first 15 characters of attributes listed in first line of the CSV file is taken as the name for each attribute."),(0,l.kt)("li",{parentName:"ul"},"The CSV file ",(0,l.kt)("strong",{parentName:"li"},"should not contain any null values.")),(0,l.kt)("li",{parentName:"ul"},"If a relation with the same name as that of the CSV file already exists, then the import will ",(0,l.kt)("em",{parentName:"li"},"fail, without any changes to disk.")),(0,l.kt)("li",{parentName:"ul"},"All files to be imported should be stored in the path ",(0,l.kt)("inlineCode",{parentName:"li"},"$HOME/NITCBase/Files/"),"."),(0,l.kt)("li",{parentName:"ul"},"The ",(0,l.kt)("em",{parentName:"li"},"order of attribute values in each line of the CSV file must be same as that of the attributes of the relation.")),(0,l.kt)("li",{parentName:"ul"},"The number of attribute values in each row should match the number of attributes specified in the first line of the file."),(0,l.kt)("li",{parentName:"ul"},"The types of attribute values in each row should match the attribute types inferred from the second line of the file."),(0,l.kt)("li",{parentName:"ul"},"All attribute names of the relation must be unique.\n:::")))),(0,l.kt)("p",null,"Consider the sample ",(0,l.kt)("inlineCode",{parentName:"p"},"Students.csv")," file:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-c",metastring:'title="/Files/Students.csv"',title:'"/Files/Students.csv"'},"No,Name,Cgpa\n3,Sunny,8.2\n5,Sania,6.0\n7,Ralph,7.5\n")),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"import sample.csv")," command will import relation ",(0,l.kt)("inlineCode",{parentName:"p"},"Students")," into the disk"),(0,l.kt)("p",null,"The first line in the CSV file represents the list of attributes in the relation which in this case are No, Name, Cgpa.\nThe datatypes of the attributes are determined from the values of the attributes in the second line.\nAn attribute can be an a number or a string. In this example the datatypes will be number, string and number respectively."),(0,l.kt)("p",null,":::"),(0,l.kt)("h3",{id:"export-relation"},"Export Relation"),(0,l.kt)("h4",{id:"description-2"},"Description"),(0,l.kt)("p",null,"This command is used to export a relation from XFS / NITCbase disk to UNIX file system. All the records corresponding to the relation ",(0,l.kt)("inlineCode",{parentName:"p"},"tablename")," are written to a CSV file named ",(0,l.kt)("inlineCode",{parentName:"p"},"filename.csv"),", located at the following path: ",(0,l.kt)("inlineCode",{parentName:"p"},"$HOME/NITCBase/Files/")),(0,l.kt)("h4",{id:"syntax-2"},"Syntax"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"export tablename filename\n")),(0,l.kt)("div",{className:"admonition admonition-info alert alert--info"},(0,l.kt)("div",{parentName:"div",className:"admonition-heading"},(0,l.kt)("h5",{parentName:"div"},(0,l.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,l.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,l.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"}))),"info")),(0,l.kt)("div",{parentName:"div",className:"admonition-content"},(0,l.kt)("ul",{parentName:"div"},(0,l.kt)("li",{parentName:"ul"},"The file to which output is to be written must be a CSV file."),(0,l.kt)("li",{parentName:"ul"},"The file names should not contain ",(0,l.kt)("inlineCode",{parentName:"li"},"whitespaces")," or any special characters except ",(0,l.kt)("inlineCode",{parentName:"li"},"-")," or ",(0,l.kt)("inlineCode",{parentName:"li"},"_"),".\n:::")))),(0,l.kt)("p",null,"To export a relation ",(0,l.kt)("inlineCode",{parentName:"p"},"Students")," present in the NITCbase disk to a CSV file (named ",(0,l.kt)("inlineCode",{parentName:"p"},"Marks.csv")," located at ",(0,l.kt)("inlineCode",{parentName:"p"},"$HOME/NITCBase/Files/")," directory),\nexecute the following command:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"export Students Marks.csv\n")),(0,l.kt)("p",null,":::"),(0,l.kt)("h3",{id:"list-relation-names"},"List Relation Names"),(0,l.kt)("h4",{id:"description-3"},"Description"),(0,l.kt)("p",null,"This command is used to list the names of all relations in present in NITCbase / XFS Disk to the command line."),(0,l.kt)("h4",{id:"syntax-3"},"Syntax"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"ls\n")),(0,l.kt)("h3",{id:"dump-block-allocation-map"},"Dump Block Allocation Map"),(0,l.kt)("h4",{id:"description-4"},"Description"),(0,l.kt)("p",null,"This command is used to dump the contents of the ",(0,l.kt)("inlineCode",{parentName:"p"},"Block allocation map")," into an external file named ",(0,l.kt)("inlineCode",{parentName:"p"},"block_allocation_map.txt")," located at the following path: ",(0,l.kt)("inlineCode",{parentName:"p"},"$HOME/NITCBase/Files/"),"."),(0,l.kt)("h4",{id:"syntax-4"},"Syntax"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"dump bmap\n")),(0,l.kt)("h3",{id:"dump-relation-catalog"},"Dump Relation Catalog"),(0,l.kt)("h4",{id:"description-5"},"Description"),(0,l.kt)("p",null,"This command is used to copy the contents of ",(0,l.kt)("inlineCode",{parentName:"p"},"Relation catalog")," to an external file named ",(0,l.kt)("inlineCode",{parentName:"p"},"relation_catalog.txt")," located at the following path: ",(0,l.kt)("inlineCode",{parentName:"p"},"$HOME/NITCBase/Files/"),"."),(0,l.kt)("h4",{id:"syntax-5"},"Syntax"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"dump relcat\n")),(0,l.kt)("h3",{id:"dump-attribute-catalog"},"Dump Attribute Catalog"),(0,l.kt)("h4",{id:"description-6"},"Description"),(0,l.kt)("p",null,"This command is used to copy the contents of ",(0,l.kt)("inlineCode",{parentName:"p"},"Attribute catalog")," to an external file named ",(0,l.kt)("inlineCode",{parentName:"p"},"attribute_catalog.txt")," located at the following path: ",(0,l.kt)("inlineCode",{parentName:"p"},"$HOME/NITCBase/Files/"),"."),(0,l.kt)("h4",{id:"syntax-6"},"Syntax"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"dump attrcat\n")),(0,l.kt)("h3",{id:"exit"},"Exit"),(0,l.kt)("h4",{id:"description-7"},"Description"),(0,l.kt)("p",null,"This command is used to exit the XFS Interface."),(0,l.kt)("h4",{id:"syntax-7"},"Syntax"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"exit\n")),(0,l.kt)("h3",{id:"print-b-tree"},"Print B+ Tree"),(0,l.kt)("h4",{id:"description-8"},"Description"),(0,l.kt)("p",null,"This command is used to print the ",(0,l.kt)("inlineCode",{parentName:"p"},"B+ tree"),"(in a level order manner) corresponding to the index created on an attribute of a relation. If index does not exist then an error message of ",(0,l.kt)("inlineCode",{parentName:"p"},"Index does not exist")," is returned."),(0,l.kt)("h4",{id:"syntax-8"},"Syntax"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"print b+ tree relation_name.attribute_name\n")),(0,l.kt)("div",{className:"admonition admonition-note alert alert--secondary"},(0,l.kt)("div",{parentName:"div",className:"admonition-heading"},(0,l.kt)("h5",{parentName:"div"},(0,l.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,l.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,l.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"}))),"Example")),(0,l.kt)("div",{parentName:"div",className:"admonition-content"},(0,l.kt)("p",{parentName:"div"},"Consider the sample ",(0,l.kt)("inlineCode",{parentName:"p"},"numbers.csv")," file:"),(0,l.kt)("pre",{parentName:"div"},(0,l.kt)("code",{parentName:"pre",className:"language-c",metastring:'title="/Files/numbers.csv"',title:'"/Files/numbers.csv"'},"key\n10\n5\n75\n20\n.\n.\n.\n")),(0,l.kt)("p",{parentName:"div"},"Assume an index is created on the attribute ",(0,l.kt)("inlineCode",{parentName:"p"},"key"),". Now to print the B+ tree corresponding to that index the following command can be used:\n",(0,l.kt)("inlineCode",{parentName:"p"},"print b+ tree numbers.key"),". This will give the following output:"),(0,l.kt)("pre",{parentName:"div"},(0,l.kt)("code",{parentName:"pre"},"LEVEL 0\n40\nLEVEL 1\n10,20   55,65\nLEVEL 2\n5,10   15,20   25,40,40   45,55   60,65   70,75\n")),(0,l.kt)("blockquote",{parentName:"div"},(0,l.kt)("p",{parentName:"blockquote"},"The tree is printed in a level-order manner.\nIn the above B+ tree, ",(0,l.kt)("inlineCode",{parentName:"p"},"40")," is the root node and it's left and right child nodes are ",(0,l.kt)("inlineCode",{parentName:"p"},"10,20")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"55,65")," respectively\n:::")))),(0,l.kt)("p",null,"In the above example, output shown is for a B+ tree which allows that maximum ",(0,l.kt)("inlineCode",{parentName:"p"},"4")," keys in the internal node and maximum ",(0,l.kt)("inlineCode",{parentName:"p"},"3")," keys in the leaf nodes. In NITCbase B+ tree design, maximum ",(0,l.kt)("inlineCode",{parentName:"p"},"100")," keys are allowed in the internal node and maximum ",(0,l.kt)("inlineCode",{parentName:"p"},"63")," keys are allowed in the leaf node.\n:::"),(0,l.kt)("h3",{id:"print-b-blocks"},"Print B+ Blocks"),(0,l.kt)("h4",{id:"description-9"},"Description"),(0,l.kt)("p",null,"This command is used to print the data stored in ",(0,l.kt)("inlineCode",{parentName:"p"},"index blocks"),"(",(0,l.kt)("inlineCode",{parentName:"p"},"internal index blocks")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"leaf index blocks"),") of the ",(0,l.kt)("inlineCode",{parentName:"p"},"B+ tree")," corresponding to an attribute of a relation. If index does not exist then an error message of ",(0,l.kt)("inlineCode",{parentName:"p"},"Index does not exist")," is returned."),(0,l.kt)("h4",{id:"syntax-9"},"Syntax"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"print b+ blocks relation_name.attribute_name\n")),(0,l.kt)("div",{className:"admonition admonition-note alert alert--secondary"},(0,l.kt)("div",{parentName:"div",className:"admonition-heading"},(0,l.kt)("h5",{parentName:"div"},(0,l.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,l.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,l.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"}))),"Example")),(0,l.kt)("div",{parentName:"div",className:"admonition-content"},(0,l.kt)("p",{parentName:"div"},"Consider the sample ",(0,l.kt)("inlineCode",{parentName:"p"},"numbers.csv")," file:"),(0,l.kt)("pre",{parentName:"div"},(0,l.kt)("code",{parentName:"pre",className:"language-c",metastring:'title="/Files/numbers.csv"',title:'"/Files/numbers.csv"'},"key\n10\n5\n75\n20\n.\n.\n.\n")),(0,l.kt)("p",{parentName:"div"},"Assume an index is created on the attribute ",(0,l.kt)("inlineCode",{parentName:"p"},"key"),". Now to print the index blocks corresponding to that index the following command can be used:\n",(0,l.kt)("inlineCode",{parentName:"p"},"print b+ blocks numbers.key"),". This will give the following output:"),(0,l.kt)("pre",{parentName:"div"},(0,l.kt)("code",{parentName:"pre",className:"language-c"},"----- B+ TREE BLOCKS -----\nBLOCK 15\nBlock Type: IND_INTERNAL\nParent Block: -1\nNo of entries: 1\nlchild: 9, key_val: 40, rchild: 14\n---------\nBLOCK 9\nBlock Type: IND_INTERNAL\nParent Block: 15\nNo of entries: 2\nlchild: 7, key_val: 10, rchild: 8\nlchild: 8, key_val: 20, rchild: 11\n---------\nBLOCK 7\nBlock Type: IND_LEAF\nParent Block: 9\nNo of entries: 2\nleft node: -1, right node: 8\nkey_val: 5\nkey_val: 10\n---------\nBLOCK 8\nBlock Type: IND_LEAF\nParent Block: 9\nNo of entries: 2\nleft node: 7, right node: 11\nkey_val: 15\nkey_val: 20\n---------\nBLOCK 11\nBlock Type: IND_LEAF\nParent Block: 9\nNo of entries: 3\nleft node: 8, right node: 13\nkey_val: 25\nkey_val: 40\nkey_val: 40\n---------\nBLOCK 14\nBlock Type: IND_INTERNAL\nParent Block: 15\nNo of entries: 2\nlchild: 13, key_val: 55, rchild: 10\nlchild: 10, key_val: 65, rchild: 12\n---------\nBLOCK 13\nBlock Type: IND_LEAF\nParent Block: 14\nNo of entries: 2\nleft node: 11, right node: 10\nkey_val: 45\nkey_val: 55\n---------\nBLOCK 10\nBlock Type: IND_LEAF\nParent Block: 14\nNo of entries: 2\nleft node: 13, right node: 12\nkey_val: 60\nkey_val: 65\n---------\nBLOCK 12\nBlock Type: IND_LEAF\nParent Block: 14\nNo of entries: 2\nleft node: 10, right node: -1\nkey_val: 70\nkey_val: 75\n---------\n")),(0,l.kt)("blockquote",{parentName:"div"},(0,l.kt)("p",{parentName:"blockquote"},"The b+ tree blocks is printed in a level-order manner.\n:::")))),(0,l.kt)("p",null,"In the above example, output shown is for a B+ tree which allows that maximum ",(0,l.kt)("inlineCode",{parentName:"p"},"4")," keys in the internal node and maximum ",(0,l.kt)("inlineCode",{parentName:"p"},"3")," keys in the leaf nodes. In NITCbase B+ tree design, maximum ",(0,l.kt)("inlineCode",{parentName:"p"},"100")," keys are allowed in the internal node and maximum ",(0,l.kt)("inlineCode",{parentName:"p"},"63")," keys are allowed in the leaf node.\n:::"))}c.isMDXComponent=!0}}]);