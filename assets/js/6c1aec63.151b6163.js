"use strict";(self.webpackChunknitcbase=self.webpackChunknitcbase||[]).push([[4725],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>h});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var c=a.createContext({}),s=function(e){var t=a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},d=function(e){var t=s(e.components);return a.createElement(c.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},p=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,c=e.parentName,d=o(e,["components","mdxType","originalType","parentName"]),p=s(n),h=r,m=p["".concat(c,".").concat(h)]||p[h]||u[h]||i;return n?a.createElement(m,l(l({ref:t},d),{},{components:n})):a.createElement(m,l({ref:t},d))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,l=new Array(i);l[0]=p;var o={};for(var c in t)hasOwnProperty.call(t,c)&&(o[c]=t[c]);o.originalType=e,o.mdxType="string"==typeof e?e:r,l[1]=o;for(var s=2;s<i;s++)l[s]=n[s];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}p.displayName="MDXCreateElement"},4694:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>l,default:()=>u,frontMatter:()=>i,metadata:()=>o,toc:()=>s});var a=n(7462),r=(n(7294),n(3905));const i={title:"Stage 11: Index Creation and Deletion"},l="Stage 11: Index Creation and Deletion (30 hours)",o={unversionedId:"Roadmap/Stage11",id:"Roadmap/Stage11",title:"Stage 11: Index Creation and Deletion",description:"- Implement the creation and insertion operations on a B+ tree on the XFS disk",source:"@site/docs/Roadmap/Stage11.md",sourceDirName:"Roadmap",slug:"/Roadmap/Stage11",permalink:"/docs/Roadmap/Stage11",draft:!1,tags:[],version:"current",frontMatter:{title:"Stage 11: Index Creation and Deletion"},sidebar:"Roadmap",previous:{title:"Stage 10: B+ Tree Search on Relations",permalink:"/docs/Roadmap/Stage10"},next:{title:"Stage 12: Join on Relations",permalink:"/docs/Roadmap/Stage12"}},c={},s=[{value:"Introduction",id:"introduction",level:2},{value:"Implementation",id:"implementation",level:2},{value:"Cache Update and Write-back",id:"cache-update-and-write-back",level:3},{value:"Writing to Index Blocks",id:"writing-to-index-blocks",level:3},{value:"Creating and Deleting B+ Trees",id:"creating-and-deleting-b-trees",level:3},{value:"Exercises",id:"exercises",level:2}],d={toc:s};function u(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"stage-11-index-creation-and-deletion-30-hours"},"Stage 11: Index Creation and Deletion (30 hours)"),(0,r.kt)("admonition",{title:"Learning Objectives",type:"note"},(0,r.kt)("ul",{parentName:"admonition"},(0,r.kt)("li",{parentName:"ul"},"Implement the creation and insertion operations on a B+ tree on the XFS disk"),(0,r.kt)("li",{parentName:"ul"},"Implement the deletion of an index from the XFS disk"))),(0,r.kt)("admonition",{title:"PREREQUISITE READING",type:"tip"},(0,r.kt)("ul",{parentName:"admonition"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/docs/Misc/B+%20Trees"},"B+ Trees")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/docs/Misc/Indexing"},"Indexing in NITCbase")))),(0,r.kt)("h2",{id:"introduction"},"Introduction"),(0,r.kt)("p",null,"You must now already be familiar with the usage of indexes to speed up search operations. An index can be created on any attribute of a relation using the ",(0,r.kt)("a",{parentName:"p",href:"/docs/User%20Interface%20Commands/ddl#create-index"},"CREATE INDEX")," command. Once an index is created on the attribute, all search operations involving that attribute will proceed through the index instead of a linear search through all the records. An index can be deleted with the ",(0,r.kt)("a",{parentName:"p",href:"/docs/User%20Interface%20Commands/ddl#drop-index"},"DROP INDEX")," command. Note that NITCbase does not allow you to create/delete indexes for the relation catalog and the attribute catalog."),(0,r.kt)("p",null,"Thus far, index creation and deletion could only be done through the XFS Interface. In this stage, we will implement this functionality in NITCbase."),(0,r.kt)("h2",{id:"implementation"},"Implementation"),(0,r.kt)("p",null,"When an index is created for an attribute of a relation, the ",(0,r.kt)("inlineCode",{parentName:"p"},"RootBlock")," field in the corresponding attribute catalog entry will have to be updated with the block number of the root block of the B+ tree. In practice, this value is updated in the attribute cache and then written back to the buffer (and subsequently the disk) when the relation is closed. Thus, we will need to implement attribute cache update and write back in the ",(0,r.kt)("a",{parentName:"p",href:"/docs/Design/Cache%20Layer/intro"},"Cache Layer"),"."),(0,r.kt)("p",null,"In the ",(0,r.kt)("a",{parentName:"p",href:"/docs/Design/Buffer%20Layer/intro"},"Buffer Layer"),", we will need to update the ",(0,r.kt)("a",{parentName:"p",href:"/docs/Design/Buffer%20Layer/IndBuffer#class-indleaf"},"IndLeaf")," and ",(0,r.kt)("a",{parentName:"p",href:"/docs/Design/Buffer%20Layer/IndBuffer#class-indinternal"},"IndInternal")," classes to implement the ",(0,r.kt)("inlineCode",{parentName:"p"},"setEntry()")," function we discussed in the previous stage. This function allows us to write to an index block."),(0,r.kt)("p",null,"A sequence diagram showing the call sequence involved in the implementation of index creation and deletion are shown below."),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},(0,r.kt)("strong",{parentName:"p"},"NOTE"),": The functions are denoted with circles as follows.",(0,r.kt)("br",null),"\n\ud83d\udd35 -> methods that are already in their final state",(0,r.kt)("br",null),"\n\ud83d\udfe2 -> methods that will attain their final state in this stage",(0,r.kt)("br",null))),(0,r.kt)("mermaid",{value:" %%{init: { 'sequence': {'mirrorActors':false} } }%%\nsequenceDiagram\n    actor User\n    participant Frontend User Interface\n    participant Frontend Programming Interface\n    participant Schema Layer\n    participant B-Plus Tree Layer\n    participant Cache Layer\n    participant Buffer Layer\n    User->>Frontend User Interface: CREATE INDEX\n    activate Frontend User Interface\n    Frontend User Interface->>Frontend Programming Interface: create_index()\ud83d\udfe2\n    activate Frontend Programming Interface\n    Frontend Programming Interface->>Schema Layer: createIndex()\ud83d\udfe2\n    activate Schema Layer\n    Schema Layer->>B-Plus Tree Layer: bPlusCreate()\ud83d\udfe2\n    activate B-Plus Tree Layer\n    note over B-Plus Tree Layer, Buffer Layer: get new root block\n    B-Plus Tree Layer->>Buffer Layer: IndLeaf()\ud83d\udd35\n    activate Buffer Layer\n    Buffer Layer--\x3e>B-Plus Tree Layer: blockNum (member field)\n    deactivate Buffer Layer\n    note over B-Plus Tree Layer, Cache Layer: set root block in cache\n    B-Plus Tree Layer->>Cache Layer: setAttrCatEntry()\ud83d\udfe2\n    activate Cache Layer\n    Cache Layer--\x3e>B-Plus Tree Layer: operation status\n    deactivate Cache Layer\n    loop for every record of the relation\n      B-Plus Tree Layer->>Buffer Layer: getRecord()\ud83d\udd35\n      activate Buffer Layer\n      Buffer Layer--\x3e>B-Plus Tree Layer: record\n      deactivate Buffer Layer\n      B-Plus Tree Layer->>B-Plus Tree Layer: bPlusInsert()\ud83d\udfe2\n      activate B-Plus Tree Layer\n      B-Plus Tree Layer->>Buffer Layer: setEntry()\ud83d\udfe2\n      activate Buffer Layer\n      Buffer Layer--\x3e>B-Plus Tree Layer:operation status\n      deactivate Buffer Layer\n      deactivate B-Plus Tree Layer\n    end\n    B-Plus Tree Layer--\x3e>Schema Layer: operation status\n    deactivate B-Plus Tree Layer\n    Schema Layer--\x3e>User: operation status\n    deactivate Schema Layer\n    deactivate Frontend Programming Interface\n    deactivate Frontend User Interface"}),(0,r.kt)("mermaid",{value:" %%{init: { 'sequence': {'mirrorActors':false} } }%%\nsequenceDiagram\n    actor User\n    participant Frontend User Interface\n    participant Frontend Programming Interface\n    participant Schema Layer\n    participant B-Plus Tree Layer\n    participant Cache Layer\n    participant Buffer Layer\n    User->>Frontend User Interface: DROP INDEX\n    activate Frontend User Interface\n    Frontend User Interface->>Frontend Programming Interface: drop_index()\ud83d\udfe2\n    activate Frontend Programming Interface\n    Frontend Programming Interface->>Schema Layer: dropIndex()\ud83d\udfe2\n    activate Schema Layer\n    note over Schema Layer, Cache Layer: get root block of index\n    Schema Layer->>Cache Layer: getAttrCatEntry()\ud83d\udd35\n    activate Cache Layer\n    Cache Layer--\x3e>Schema Layer: attribute catalog entry\n    deactivate Cache Layer\n    Schema Layer->>B-Plus Tree Layer: bPlusDestroy()\ud83d\udfe2\n    activate B-Plus Tree Layer\n    note over B-Plus Tree Layer: recursively call bPlusDestroy()<br/>on all children\n    B-Plus Tree Layer->>B-Plus Tree Layer: bPlusDestroy()\ud83d\udfe2\n    B-Plus Tree Layer->>Buffer Layer: releaseBlock()\ud83d\udd35\n    activate Buffer Layer\n    Buffer Layer--\x3e>B-Plus Tree Layer: operation status\n    deactivate Buffer Layer\n    B-Plus Tree Layer--\x3e>Schema Layer: operation status\n    deactivate B-Plus Tree Layer\n    note over Schema Layer, Cache Layer: remove root block in attribute cache\n    Schema Layer->>Cache Layer: setAttrCatEntry()\ud83d\udfe2\n    activate Cache Layer\n    Cache Layer--\x3e>Schema Layer: operation status\n    deactivate Cache Layer\n    Schema Layer--\x3e>User: operation status\n    deactivate Schema Layer\n    deactivate Frontend Programming Interface\n    deactivate Frontend User Interface"}),(0,r.kt)("h3",{id:"cache-update-and-write-back"},"Cache Update and Write-back"),(0,r.kt)("p",null,"An index can only be created for an open relation. When an index is created for a relation on an attribute, the ",(0,r.kt)("inlineCode",{parentName:"p"},"RootBlock")," field is set for the corresponding ",(0,r.kt)("strong",{parentName:"p"},"attribute catalog entry in the attribute cache entry")," of the relation. Similar to how we had implemented the updation of the relation cache in previous stages, this updated value will be written to the buffer when the relation is closed (or at system exit, when all open relations are closed.)."),(0,r.kt)("p",null,"Thus, we will need to implement methods to write to the attribute cache. Additionally, we will also modify the ",(0,r.kt)("inlineCode",{parentName:"p"},"OpenRelTable::closeRel()")," function to write-back any ",(0,r.kt)("em",{parentName:"p"},"dirty")," attribute cache entries on relation closing. Note that we do not need to update the destructor of the OpenRelTable class to handle write-back for the attribute cache entries of the relation catalog and the attribute catalog (why?)."),(0,r.kt)("p",null,"A class diagram of the ",(0,r.kt)("a",{parentName:"p",href:"/docs/Design/Cache%20Layer/intro"},"Cache Layer")," highlighting the methods relevant to this functionality is shown below."),(0,r.kt)("mermaid",{value:"classDiagram\ndirection BT\n  RelCacheTable <|.. OpenRelTable : friend\n  AttrCacheTable <|.. OpenRelTable : friend\n  class RelCacheTable{\n    -relCache[MAX_OPEN] : RelCacheEntry*\n    -recordToRelCatEntry(union Attribute record[RELCAT_NO_ATTRS], RelCatEntry *relCatEntry)$ void\ud83d\udd35\n    -relCatEntryToRecord(RelCatEntry *relCatEntry, union Attribute record[RELCAT_NO_ATTRS])$ void\ud83d\udd35\n    +getRelCatEntry(int relId, RelCatEntry *relCatBuf)$ int\ud83d\udd35\n    +setRelCatEntry(int relId, RelCatEntry *relCatBuf)$ int\ud83d\udd35\n    +getSearchIndex(int relId, RecId *searchIndex)$ int\ud83d\udd35\n    +setSearchIndex(int relId, RecId *searchIndex)$ int\ud83d\udd35\n    +resetSearchIndex(int relId)$ int\ud83d\udd35\n  }\n  class AttrCacheTable{\n    -attrCache[MAX_OPEN] : AttrCacheEntry*\n    -recordToAttrCatEntry(union Attribute record[ATTRCAT_NO_ATTRS], AttrCatEntry *attrCatEntry)$ void\ud83d\udd35\n    -attrCatEntryToRecord(AttrCatEntry *attrCatEntry, union Attribute record[ATTRCAT_NO_ATTRS])$ void\ud83d\udfe2\n    +getAttrCatEntry(int relId, int attrOffset, AttrCatEntry *attrCatBuf)$ int\ud83d\udd35\n    +getAttrCatEntry(int relId, char attrName[ATTR_SIZE], AttrCatEntry *attrCatBuf)$ int\ud83d\udd35\n    +setAttrCatEntry(int relId, char attrName[ATTR_SIZE], AttrCatEntry *attrCatBuf)$ int\ud83d\udfe2\n    +setAttrCatEntry(int relId, int attrOffset, AttrCatEntry *attrCatBuf)$ int\ud83d\udfe2\n    +getSearchIndex(int relId, char attrName[ATTR_SIZE], IndexId *searchIndex)$ int\ud83d\udd35\n    +getSearchIndex(int relId, int attrOffset, IndexId *searchIndex)$ int\ud83d\udd35\n    +setSearchIndex(int relId, char attrName[ATTR_SIZE], IndexId *searchIndex)$ int\ud83d\udd35\n    +setSearchIndex(int relId, int attrOffset, IndexId *searchIndex)$ int\ud83d\udd35\n    +resetSearchIndex(int relId, char attrName[ATTR_SIZE])$ int\ud83d\udd35\n    +resetSearchIndex(int relId, int attrOffset)$ int\ud83d\udd35\n\n  }\n  class OpenRelTable{\n    -tableMetaInfo[MAX_OPEN] : OpenRelTableMetaInfo\n    +OpenRelTable(): \ud83d\udd35\n    +~OpenRelTable(): \ud83d\udd35\n    -getFreeOpenRelTableEntry()$ int\ud83d\udd35\n    +getRelId(char relName[ATTR_SIZE])$ int\ud83d\udd35\n    +openRel(char relName[ATTR_SIZE])$ int\ud83d\udd35\n    +closeRel(int relId)$ int\ud83d\udfe2\n  }\n"}),(0,r.kt)("br",null),(0,r.kt)("p",null,"In class ",(0,r.kt)("inlineCode",{parentName:"p"},"AttrCacheTable"),", we implement the method ",(0,r.kt)("inlineCode",{parentName:"p"},"setAttrCatEntry()")," which is overloaded to find the entry in the attribute cache using the attribute's name or offset."),(0,r.kt)("p",null,"We also implement the ",(0,r.kt)("inlineCode",{parentName:"p"},"attrCatEntryToRecord()")," function which converts from a ",(0,r.kt)("a",{parentName:"p",href:"/docs/Design/Cache%20Layer/intro#attrcatentry"},"struct AttrCatEntry")," to a record of the attribute catalog (a ",(0,r.kt)("a",{parentName:"p",href:"/docs/Design/Buffer%20Layer/intro#attribute"},"union Attribute")," array). This function will be useful when writing the dirty cache entry back to the buffer in record form."),(0,r.kt)("details",null,(0,r.kt)("summary",null,"Cache/AttrCacheTable.cpp"),(0,r.kt)("p",null,"Implement the following functions looking at their respective design docs"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/docs/Design/Cache%20Layer/AttrCacheTable#attrcachetable--setattrcatentry"},(0,r.kt)("inlineCode",{parentName:"a"},"AttrCacheTable::setAttrCatEntry(relId, attrOffset, attrCatEntry)"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/docs/Design/Cache%20Layer/AttrCacheTable#attrcachetable--setattrcatentry"},(0,r.kt)("inlineCode",{parentName:"a"},"AttrCacheTable::setAttrCatEntry(relId, attrName, attrCatEntry)"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/docs/Design/Cache%20Layer/AttrCacheTable#attrcachetable--attrcatentrytorecord"},(0,r.kt)("inlineCode",{parentName:"a"},"AttrCacheTable::attrCatEntryToRecord()"))))),(0,r.kt)("p",null,"In class ",(0,r.kt)("inlineCode",{parentName:"p"},"OpenRelTable"),", we update ",(0,r.kt)("inlineCode",{parentName:"p"},"closeRel()")," to check for dirty attribute cache entries and write them back to the buffer using ",(0,r.kt)("inlineCode",{parentName:"p"},"attrCatEntryToRecord()")," and the ",(0,r.kt)("a",{parentName:"p",href:"/docs/Design/Buffer%20Layer/intro"},"Buffer Layer")," functions we are familiar with."),(0,r.kt)("details",null,(0,r.kt)("summary",null,"Cache/OpenRelTable.cpp"),(0,r.kt)("p",null,"Implement the ",(0,r.kt)("inlineCode",{parentName:"p"},"OpenRelTable::closeRel()")," function by looking at the ",(0,r.kt)("a",{parentName:"p",href:"/docs/Design/Cache%20Layer/OpenRelTable#openreltable--closerel"},"design docs"),".")),(0,r.kt)("h3",{id:"writing-to-index-blocks"},"Writing to Index Blocks"),(0,r.kt)("p",null,"In the previous stage, we had talked about the abstract class ",(0,r.kt)("a",{parentName:"p",href:"/docs/Design/Buffer%20Layer/IndBuffer#class-indbuffer"},"IndBuffer")," and it's children ",(0,r.kt)("a",{parentName:"p",href:"/docs/Design/Buffer%20Layer/IndBuffer#class-indleaf"},"IndLeaf")," and ",(0,r.kt)("a",{parentName:"p",href:"/docs/Design/Buffer%20Layer/IndBuffer#class-indinternal"},"IndInternal")," representing leaf index blocks and internal index blocks respectively. We had implemented the ",(0,r.kt)("inlineCode",{parentName:"p"},"getEntry()")," function in both the classes to read an entry from an index block. In this stage, we will implement the ",(0,r.kt)("inlineCode",{parentName:"p"},"setEntry()")," function which allows us to write an entry to an index block."),(0,r.kt)("p",null,"A class diagram of the ",(0,r.kt)("a",{parentName:"p",href:"/docs/Design/Buffer%20Layer/intro"},"Buffer Layer")," highlighting these functions is shown below."),(0,r.kt)("mermaid",{value:"classDiagram\n    direction TB\n    StaticBuffer <|.. BlockBuffer : friend\n    BlockBuffer <|-- IndBuffer\n    IndBuffer <|-- IndInternal\n    IndBuffer <|-- IndLeaf\n    class StaticBuffer{\n        -blocks[BUFFER_CAPACITY][BLOCK_SIZE]: unsigned char\n        -metainfo[BUFFER_CAPACITY]: struct BufferMetaInfo\n        -blockAllocMap[DISK_BLOCKS]: unsigned char\n        +StaticBuffer() \ud83d\udd35\n        +~StaticBuffer() \ud83d\udd35\n        -getFreeBuffer(int blockNum)$ int\ud83d\udd35\n        -getBufferNum(int blockNum)$ int\ud83d\udd35\n        +setDirtyBit(int blockNum)$ int\ud83d\udd35\n        +getStaticBlockType(int blockNum)$ int\ud83d\udd35\n    }\n    class BlockBuffer{\n        #blockNum: int\n        +BlockBuffer(char blockType) \ud83d\udd35\n        +BlockBuffer(int blockNum) \ud83d\udd35\n        +getHeader(struct HeadInfo *head) int\ud83d\udd35\n        +setHeader(struct HeadInfo *head) int\ud83d\udd35\n        +releaseBlock() void\ud83d\udd35\n        #setBlockType(int blockType) int\ud83d\udd35\n        #getFreeBlock(int blockType) int\ud83d\udd35\n        #loadBlockAndGetBufferPtr(unsigned char **buffPtr) int\ud83d\udd35\n    }\n    class IndBuffer{\n        +IndBuffer(char blockType): \ud83d\udd35\n        +IndBuffer(int blockType): \ud83d\udd35\n        +getEntry(void *ptr, int indexNum)* int\n        +setEntry(void *ptr, int indexNum)* int\n    }\n    class IndInternal{\n        +IndInternal(): \ud83d\udd35\n        +IndInternal(int blockNum): \ud83d\udd35\n        +getEntry(void *ptr, int indexNum) int\ud83d\udd35\n        +setEntry(void *ptr, int indexNum) int\ud83d\udfe2\n    }\n    class IndLeaf{\n        +IndLeaf(): \ud83d\udd35\n        +IndLeaf(int blockNum): \ud83d\udd35\n        +getEntry(void *ptr, int indexNum) int\ud83d\udd35\n        +setEntry(void *ptr, int indexNum) int\ud83d\udfe2\n    }\n"}),(0,r.kt)("br",null),(0,r.kt)("p",null,"Implement these functions as shown in the links below."),(0,r.kt)("details",null,(0,r.kt)("summary",null,"Buffer/BlockBuffer.cpp"),(0,r.kt)("p",null,"Implement the following functions looking at their respective design docs"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/docs/Design/Buffer%20Layer/IndBuffer#indleaf--setentry"},(0,r.kt)("inlineCode",{parentName:"a"},"IndLeaf::setEntry()"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/docs/Design/Buffer%20Layer/IndBuffer#indinternal--setentry"},(0,r.kt)("inlineCode",{parentName:"a"},"IndInternal::setEntry()"))))),(0,r.kt)("h3",{id:"creating-and-deleting-b-trees"},"Creating and Deleting B+ Trees"),(0,r.kt)("p",null,"In the ",(0,r.kt)("a",{parentName:"p",href:"/docs/Design/B+%20Tree%20Layer"},"B+ Tree Layer"),", we implement methods to create a B+ tree, insert into a B+ tree and free all the index blocks associated with a B+ tree. Note that we do not need to implement the functionality to delete an individual entry from a B+ tree because NITCbase does not support individual deletion of records."),(0,r.kt)("p",null,"A class diagram highlighting all the functions that will be modified to implement this functionality is shown below."),(0,r.kt)("mermaid",{value:"classDiagram\n  class Schema{\n    +openRel(char relName[ATTR_SIZE])$ int\ud83d\udd35\n    +closeRel(char relName[ATTR_SIZE])$ int\ud83d\udd35\n    +renameRel(char oldRelName[ATTR_SIZE], char newRelName[ATTR_SIZE])$ int\ud83d\udd35\n    +renameAttr(char relName[ATTR_SIZE], char oldAttrName[ATTR_SIZE], char newAttrName[ATTR_SIZE])$ int\ud83d\udd35\n    +createRel(char relName[ATTR_SIZE], int numOfAttributes, char attrNames[][ATTR_SIZE], int attrType[])$ int\ud83d\udd35\n    +deleteRel(char relName[ATTR_SIZE])$ \ud83d\udd35\n    +createIndex(char relName[ATTR_SIZE], char attrName[ATTR_SIZE])$ int\ud83d\udfe2\n    +dropIndex(char relName[ATTR_SIZE], char attrName[ATTR_SIZE])$ int\ud83d\udfe2\n  }"}),(0,r.kt)("mermaid",{value:"classDiagram\n  class BlockAccess{\n    +linearSearch(int relId, char attrName[ATTR_SIZE], Attribute attrVal, int op)$ RecId\ud83d\udd35\n    +renameRelation(char oldName[ATTR_SIZE], char newName[ATTR_SIZE])$ int\ud83d\udd35\n    +renameAttribute(char relName[ATTR_SIZE], char oldName[ATTR_SIZE], char newName[ATTR_SIZE])$ int\ud83d\udd35\n    +insert(int relId, union Attribute* record)$ int\ud83d\udfe2\n    +deleteRelation(char relName[ATTR_SIZE])$ int\ud83d\udfe2\n\t\t+project(int relId, Attribute *record)$ int\ud83d\udd35\n    +search(int relId, Attribute *record, char attrName[ATTR_SIZE], Attribute attrVal, int op)$ int\ud83d\udd35\n  }"}),(0,r.kt)("mermaid",{value:"classDiagram\n  class BPlusTree{\n    +bPlusSearch(int relId, char attrName[ATTR_SIZE], Attribute attrVal, int op)$ int\ud83d\udd35\n    +bPlusCreate(int relId, char attrName[ATTR_SIZE])$ int\ud83d\udfe2\n    +bPlusInsert(int relId, char attrName[ATTR_SIZE], Attribute attrVal, RecId recId)$ int\ud83d\udfe2\n    +bPlusDestroy(int rootBlockNum)$ int\ud83d\udfe2\n  }"}),(0,r.kt)("br",null),(0,r.kt)("p",null,"As shown in the sequence diagram above, the Frontend User Interface will parse the ",(0,r.kt)("inlineCode",{parentName:"p"},"CREATE INDEX")," command and call the ",(0,r.kt)("inlineCode",{parentName:"p"},"Frontend::create_index()")," function in the Frontend Programming Interface. This call is then transferred along to the ",(0,r.kt)("a",{parentName:"p",href:"/docs/Design/Schema%20Layer"},"Schema Layer"),". Hence, the implementation of the ",(0,r.kt)("inlineCode",{parentName:"p"},"Frontend::create_index()")," function only involves a call to the ",(0,r.kt)("inlineCode",{parentName:"p"},"Schema::createIndex()")," function. Similarly, the ",(0,r.kt)("inlineCode",{parentName:"p"},"DROP INDEX")," command leads to the ",(0,r.kt)("inlineCode",{parentName:"p"},"Frontend::drop_index()")," function which in turn transfers control to ",(0,r.kt)("inlineCode",{parentName:"p"},"Schema::dropIndex()"),"."),(0,r.kt)("details",null,(0,r.kt)("summary",null,"Frontend/Frontend.cpp"),(0,r.kt)("p",null,"Implement the following functions looking at their respective design docs"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/docs/Design/Frontend#frontend--create_index"},(0,r.kt)("inlineCode",{parentName:"a"},"Frontend::create_index()"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/docs/Design/Frontend#frontend--drop_index"},(0,r.kt)("inlineCode",{parentName:"a"},"Frontend::drop_index()"))))),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"Schema::createIndex()")," function verifies that the relation is open and passes the rel-id and attribute name along to the ",(0,r.kt)("inlineCode",{parentName:"p"},"BPlusTree::bPlusCreate()")," function to create an index (to be implemented later in this stage)."),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"Schema::dropIndex()")," function fetches the root block of the index on a specified attribute from the attribute cache and then calls the ",(0,r.kt)("inlineCode",{parentName:"p"},"BPlusTree::bPlusDestroy()")," function to free the index blocks. The corresponding attribute cache entry is then updated to indicate that there no longer exists a B+ tree on the attribute."),(0,r.kt)("admonition",{title:"note",type:"caution"},(0,r.kt)("p",{parentName:"admonition"},"Although the ",(0,r.kt)("a",{parentName:"p",href:"/docs/Design/Schema%20Layer"},"Schema Layer")," function ",(0,r.kt)("inlineCode",{parentName:"p"},"Schema::dropIndex()")," is responsible for removing the ",(0,r.kt)("inlineCode",{parentName:"p"},"RootBlock")," field during index deletion, during index creation, the attribute cache entry is updated with the value of the root block in the ",(0,r.kt)("a",{parentName:"p",href:"/docs/Design/B+%20Tree%20Layer"},"B+ Tree Layer")," function ",(0,r.kt)("inlineCode",{parentName:"p"},"BPlusTree::bPlusCreate()")," (and not in the ",(0,r.kt)("inlineCode",{parentName:"p"},"Schema::createIndex()")," function).")),(0,r.kt)("details",null,(0,r.kt)("summary",null,"Schema/Schema.cpp"),(0,r.kt)("p",null,"Implement the following functions looking at their respective design docs"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/docs/Design/Schema%20Layer#schema--createindex"},(0,r.kt)("inlineCode",{parentName:"a"},"Schema::createIndex()"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/docs/Design/Schema%20Layer#schema--dropindex"},(0,r.kt)("inlineCode",{parentName:"a"},"Schema::dropIndex()"))))),(0,r.kt)("p",null,"We implement the core functionality of this stage in the ",(0,r.kt)("a",{parentName:"p",href:"/docs/Design/B+%20Tree%20Layer"},"B+ Tree Layer"),"."),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"BPlusTree::bPlusCreate()")," is used to create an index on attribute for a relation. It allocates a new index block and sets the ",(0,r.kt)("inlineCode",{parentName:"p"},"RootBlock")," field in the corresponding attribute cache entry. It then reads every record of the relation and inserts the attribute value into the index using ",(0,r.kt)("inlineCode",{parentName:"p"},"BPlusTree::bPlusInsert()"),"."),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"BPlusTree::bPlusDestroy()")," function recursively traverses all the blocks of the index and frees them using ",(0,r.kt)("inlineCode",{parentName:"p"},"BlockBuffer::releaseBlock()"),"."),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"BPlusTree::bPlusInsert()")," function is used to insert an entry into the B+ tree of an attribute. This is quite possibly the most complicated function in the implementation of NITCbase. In pursuit of clarity, the functionality involved in this task has been split among many helper functions in the ",(0,r.kt)("inlineCode",{parentName:"p"},"BPlusTree")," class."),(0,r.kt)("details",null,(0,r.kt)("summary",null,"BPlusTree/BPlusTree.cpp"),(0,r.kt)("p",null,"Implement the following functions looking at their respective design docs"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/docs/Design/B+%20Tree%20Layer#bplustreebpluscreate"},(0,r.kt)("inlineCode",{parentName:"a"},"BPlusTree::bPlusCreate()"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/docs/Design/B+%20Tree%20Layer#bplustreebplusdestroy"},(0,r.kt)("inlineCode",{parentName:"a"},"BPlusTree::bPlusDestroy()"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/docs/Design/B+%20Tree%20Layer#bplustreebplusinsert"},(0,r.kt)("inlineCode",{parentName:"a"},"BPlusTree::bPlusInsert()")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/docs/Design/B+%20Tree%20Layer#bplustreebplusinsert"},(0,r.kt)("inlineCode",{parentName:"a"},"BPlusTree::insertIntoLeaf()"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/docs/Design/B+%20Tree%20Layer#bplustreesplitleaf"},(0,r.kt)("inlineCode",{parentName:"a"},"BPlusTree::splitLeaf()"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/docs/Design/B+%20Tree%20Layer#bplustreeinsertintointernal"},(0,r.kt)("inlineCode",{parentName:"a"},"BPlusTree::insertIntoInternal()"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/docs/Design/B+%20Tree%20Layer#bplustreesplitinternal"},(0,r.kt)("inlineCode",{parentName:"a"},"BPlusTree::splitInternal()"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/docs/Design/B+%20Tree%20Layer#bplustreecreatenewroot"},(0,r.kt)("inlineCode",{parentName:"a"},"BPlusTree::createNewRoot()"))))))),(0,r.kt)("p",null,"Lastly, in the ",(0,r.kt)("a",{parentName:"p",href:"/docs/Design/Block%20Access%20Layer"},"Block Access Layer"),", we update the ",(0,r.kt)("inlineCode",{parentName:"p"},"insert()")," method to insert the new record into any existing indexes of the relation using ",(0,r.kt)("inlineCode",{parentName:"p"},"BPlusTree::bPlusInsert()"),". The ",(0,r.kt)("inlineCode",{parentName:"p"},"deleteRelation()")," method is updated to free up any indexes associated with the relation by calling ",(0,r.kt)("inlineCode",{parentName:"p"},"BPlusTree::bPlusDestroy()"),"."),(0,r.kt)("details",null,(0,r.kt)("summary",null,"BlockAccess/BlockAccess.cpp"),(0,r.kt)("p",null,"Implement the following functions looking at their respective design docs"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/docs/Design/Block%20Access%20Layer#blockaccess--insert"},(0,r.kt)("inlineCode",{parentName:"a"},"BlockAccess::insert()"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/docs/Design/Block%20Access%20Layer#blockaccess--deleterelation"},(0,r.kt)("inlineCode",{parentName:"a"},"BlockAccess::deleteRelation()"))))),(0,r.kt)("p",null,"And with that, your NITCbase now supports the creation and deletion of indexes! Verify your implementation with the exercises below."),(0,r.kt)("h2",{id:"exercises"},"Exercises"))}u.isMDXComponent=!0}}]);