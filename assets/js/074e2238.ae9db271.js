"use strict";(self.webpackChunknitcbase=self.webpackChunknitcbase||[]).push([[534],{3905:(e,t,n)=>{n.d(t,{Zo:()=>f,kt:()=>h});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},l=Object.keys(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var c=a.createContext({}),s=function(e){var t=a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},f=function(e){var t=s(e.components);return a.createElement(c.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,l=e.originalType,c=e.parentName,f=o(e,["components","mdxType","originalType","parentName"]),d=s(n),h=r,p=d["".concat(c,".").concat(h)]||d[h]||u[h]||l;return n?a.createElement(p,i(i({ref:t},f),{},{components:n})):a.createElement(p,i({ref:t},f))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var l=n.length,i=new Array(l);i[0]=d;var o={};for(var c in t)hasOwnProperty.call(t,c)&&(o[c]=t[c]);o.originalType=e,o.mdxType="string"==typeof e?e:r,i[1]=o;for(var s=2;s<l;s++)i[s]=n[s];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},9261:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>u,frontMatter:()=>l,metadata:()=>o,toc:()=>s});var a=n(7462),r=(n(7294),n(3905));const l={title:"Stage 7 : Inserting Records Into Relations"},i="Stage 7 : Inserting Records Into Relations (10 hours)",o={unversionedId:"Roadmap/Stage07",id:"Roadmap/Stage07",title:"Stage 7 : Inserting Records Into Relations",description:"- Implement",source:"@site/docs/Roadmap/Stage07.md",sourceDirName:"Roadmap",slug:"/Roadmap/Stage07",permalink:"/docs/Roadmap/Stage07",draft:!1,tags:[],version:"current",frontMatter:{title:"Stage 7 : Inserting Records Into Relations"},sidebar:"Roadmap",previous:{title:"Stage 6 : Buffer Management and Disk Write-back",permalink:"/docs/Roadmap/Stage06"}},c={},s=[{value:"Introduction",id:"introduction",level:2},{value:"Implementation",id:"implementation",level:2},{value:"Allocating New Blocks",id:"allocating-new-blocks",level:3},{value:"Handling Cache Updates",id:"handling-cache-updates",level:3},{value:"Inserting a Record",id:"inserting-a-record",level:3}],f={toc:s};function u(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},f,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"stage-7--inserting-records-into-relations-10-hours"},"Stage 7 : Inserting Records Into Relations (10 hours)"),(0,r.kt)("admonition",{title:"Learning Objectives",type:"note"},(0,r.kt)("ul",{parentName:"admonition"},(0,r.kt)("li",{parentName:"ul"},"Implement"))),(0,r.kt)("h2",{id:"introduction"},"Introduction"),(0,r.kt)("p",null,"Inserting records is quite possibly one of the most essential features of a DBMS. In this stage, we will implement all the methods required to finally start populating the relations that we have in NITCbase. Inserting a record into a relation primarily involves three main steps"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"iterate through the last block of the relation and find a free slot or allocate a new block if the previous block is full."),(0,r.kt)("li",{parentName:"ul"},"set the value of the record in the block and update the slotmap"),(0,r.kt)("li",{parentName:"ul"},"update the relation catalog/cache to reflect the change")),(0,r.kt)("p",null,"A new record can be inserted using the ",(0,r.kt)("a",{parentName:"p",href:"/docs/User%20Interface%20Commands/dml#insert-into-table-values"},"INSERT INTO TABLE VALUES")," command which is handled by the ",(0,r.kt)("a",{parentName:"p",href:"/docs/Design/Algebra%20Layer"},"Algebra Layer"),". The allocation of a new block is handled by the ",(0,r.kt)("a",{parentName:"p",href:"/docs/Design/Buffer%20Layer"},"Buffer Layer"),"."),(0,r.kt)("h2",{id:"implementation"},"Implementation"),(0,r.kt)("h3",{id:"allocating-new-blocks"},"Allocating New Blocks"),(0,r.kt)("p",null,"We have already implemented a constructor for the ",(0,r.kt)("a",{parentName:"p",href:"/docs/Design/Buffer%20Layer#class-recbuffer"},"RecBuffer class")," which takes a block number as an argument and creates an instance of ",(0,r.kt)("inlineCode",{parentName:"p"},"RecBuffer")," that handles operations on that block using the buffer (referred to as ",(0,r.kt)("a",{parentName:"p",href:"/docs/Design/Buffer%20Layer#recbuffer--recbuffer-constructor-2"},(0,r.kt)("strong",{parentName:"a"},"constructor 2"))," in the docs). The ",(0,r.kt)("a",{parentName:"p",href:"/docs/Design/Buffer%20Layer#class-recbuffer"},"RecBuffer class")," also supports a default constructor (referred to as ",(0,r.kt)("a",{parentName:"p",href:"/docs/Design/Buffer%20Layer#recbuffer--recbuffer-constructor-1"},(0,r.kt)("strong",{parentName:"a"},"constructor 1"))," in the docs) which can be used to allocate a new block on the disk and create an instance of ",(0,r.kt)("inlineCode",{parentName:"p"},"RecBuffer")," to handle operations on that block using the buffer."),(0,r.kt)("p",null,"To find a free block, we iterate through the ",(0,r.kt)("a",{parentName:"p",href:"/docs/Design/Physical%20Layer#disk-model"},"block allocation map")," to find an unoccupied block. Similar to other disk data structures, the block allocation map too is loaded into memory during the runtime of the database."),(0,r.kt)("p",null,"The methods relevant to adding this functionality are shown in the class diagram below."),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},(0,r.kt)("strong",{parentName:"p"},"NOTE"),": The functions are denoted with circles as follows.",(0,r.kt)("br",null),"\n\ud83d\udd35 -> methods that are already in their final state",(0,r.kt)("br",null),"\n\ud83d\udfe2 -> methods that will attain their final state in this stage",(0,r.kt)("br",null),"\n\ud83d\udfe0 -> methods that we will modify in this stage, and in subsequent stages ",(0,r.kt)("br",null),"\n\ud83d\udfe4 -> methods that we built earlier and require more work later, but will leave as is in this stage")),(0,r.kt)("br",null),(0,r.kt)("mermaid",{value:"classDiagram\n  direction RL\n  BlockBuffer <|-- RecBuffer\n  StaticBuffer<|..RecBuffer : uses\n  StaticBuffer<|..BlockBuffer : uses\n  class RecBuffer{\n    +RecBuffer() \ud83d\udfe2\n    +RecBuffer(int blockNum) \ud83d\udd35\n    +getRecord(union Attribute *rec, int slotNum) int\ud83d\udd35\n    +getSlotMap(unsigned char *slotMap) int\ud83d\udd35\n    +setRecord(union Attribute *rec, int slotNum) int\ud83d\udd35\n  }\n  class BlockBuffer{\n    #blockNum: int\n    +BlockBuffer(char blockType) \ud83d\udfe2\n    +BlockBuffer(int blockNum) \ud83d\udd35\n    +getHeader(struct HeadInfo *head) int\ud83d\udd35\n    +setHeader(struct HeadInfo *head) int\ud83d\udfe2\n    #setBlockType(int blockType) int\ud83d\udfe2\n    #getFreeBlock(int blockType) int\ud83d\udfe2\n    #loadBlockAndGetBufferPtr(unsigned char **buffPtr) int\ud83d\udd35\n  }\n  class StaticBuffer{\n    -blocks[BUFFER_CAPACITY][BLOCK_SIZE]: unsigned char\n    -metainfo[BUFFER_CAPACITY]: struct BufferMetaInfo\n    -blockAllocMap[DISK_BLOCKS]: unsigned char\n    +StaticBuffer() \ud83d\udfe2\n    +~StaticBuffer() \ud83d\udfe2\n    -getFreeBuffer(int blockNum)$ int\ud83d\udd35\n    -getBufferNum(int blockNum)$ int\ud83d\udd35\n    +setDirtyBit(int blockNum)$ int\ud83d\udd35\n  }"}),(0,r.kt)("br",null),(0,r.kt)("p",null,"An instance declared using ",(0,r.kt)("a",{parentName:"p",href:"/docs/Design/Buffer%20Layer#blockbuffer--blockbuffer-constructor1"},"constructor 1")," will call the ",(0,r.kt)("inlineCode",{parentName:"p"},"BlockBuffer::getFreeBlock()")," method to get a free block. This method makes use of the ",(0,r.kt)("inlineCode",{parentName:"p"},"setHeader()")," method to and ",(0,r.kt)("inlineCode",{parentName:"p"},"setBlockType()")," set up the header in the newly acquired disk block and the ",(0,r.kt)("inlineCode",{parentName:"p"},"setBlockType()")," method to update the type of the block in the block allocation map."),(0,r.kt)("p",null,"In the ",(0,r.kt)("inlineCode",{parentName:"p"},"StaticBuffer")," file, we declare the ",(0,r.kt)("inlineCode",{parentName:"p"},"blockAllocMap")," member field and update our constructor and destructor to handle this array as well."),(0,r.kt)("details",null,(0,r.kt)("summary",null,"Buffer/StaticBuffer.cpp"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"// declare the blockAllocMap array\nunsigned char StaticBuffer::blockAllocMap[DISK_BLOCKS];\n\nStaticBuffer::StaticBuffer() {\n  // copy blockAllocMap blocks from disk to buffer (using readblock() of disk)\n  // blocks 0 to 3\n\n  /* initialise metainfo of all the buffer blocks with\n     dirty:false, free:true, timestamp:-1 and blockNum:-1\n     (you did this already)\n  */\n}\n\nStaticBuffer::~StaticBuffer() {\n  // copy blockAllocMap blocks from buffer to disk(using writeblock() of disk)\n\n  /*iterate through all the buffer blocks,\n    write back blocks with meta info as free:false,dirty:true (using writeblock() of disk)\n    (you did this already)\n  */\n}\n"))),(0,r.kt)("details",null,(0,r.kt)("summary",null,"Buffer/BlockBuffer.cpp"),(0,r.kt)("p",null,"Implement the following functions looking at their respective design docs"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/docs/Design/Buffer%20Layer#blockbuffer--blockbuffer-constructor1"},(0,r.kt)("inlineCode",{parentName:"a"},"BlockBuffer::BlockBuffer(char blockType)"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/docs/Design/Buffer%20Layer#recbuffer--recbuffer-constructor-1"},(0,r.kt)("inlineCode",{parentName:"a"},"RecBuffer::RecBuffer()"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/docs/Design/Buffer%20Layer#blockbuffer--setheader"},(0,r.kt)("inlineCode",{parentName:"a"},"BlockBuffer::setHeader()"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/docs/Design/Buffer%20Layer#blockbuffer--setblocktype"},(0,r.kt)("inlineCode",{parentName:"a"},"BlockBuffer::setBlockType()"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/docs/Design/Buffer%20Layer#blockbuffer--getfreeblock"},(0,r.kt)("inlineCode",{parentName:"a"},"BlockBuffer::getFreeBlock()"))))),(0,r.kt)("h3",{id:"handling-cache-updates"},"Handling Cache Updates"),(0,r.kt)("p",null,"Recall that the relation catalog and consequently the relation cache contain a field ",(0,r.kt)("inlineCode",{parentName:"p"},"numRecords")," which stores the number of records that are part of the relation. After we insert a record, this value will have to be incremented. Thus far, we have only been reading from the caches. In this stage, we will implement write-back for the relation cache."),(0,r.kt)("p",null,"Similar to the buffer, each entry in the caches contain a ",(0,r.kt)("inlineCode",{parentName:"p"},"dirty")," field which stores whether that entry has been modified. If a cache entry is dirty, it will need to be written back either when the relation is closed (with the ",(0,r.kt)("a",{parentName:"p",href:"/docs/User%20Interface%20Commands/ddl#close-table"},"CLOSE TABLE")," command) or at system exit when all open relations are closed. The cache entry can be written back to the disk using an instance of the ",(0,r.kt)("inlineCode",{parentName:"p"},"RecBuffer")," class."),(0,r.kt)("p",null,"A class diagram indicating the relevant methods in the ",(0,r.kt)("a",{parentName:"p",href:"/docs/Design/Cache%20Layer"},"Cache Layer")," is shown below."),(0,r.kt)("mermaid",{value:"classDiagram\ndirection RL\n  RelCacheTable <|.. OpenRelTable : friend\n  AttrCacheTable <|.. OpenRelTable : friend\n  class RelCacheTable{\n    -relCache[MAX_OPEN] : RelCacheEntry*\n    -recordToRelCatEntry(union Attribute record[RELCAT_NO_ATTRS], RelCatEntry *relCatEntry)$ void\ud83d\udd35\n    -relCatEntryToRecord(RelCatEntry *relCatEntry, union Attribute record[RELCAT_NO_ATTRS])$ void\ud83d\udfe2\n    +getRelCatEntry(int relId, RelCatEntry *relCatBuf)$ int\ud83d\udd35\n    +setRelCatEntry(int relId, RelCatEntry *relCatBuf)$ int\ud83d\udfe2\n    +getSearchIndex(int relId, RecId *searchIndex)$ int\ud83d\udd35\n    +setSearchIndex(int relId, RecId *searchIndex)$ int\ud83d\udd35\n    +resetSearchIndex(int relId)$ int\ud83d\udd35\n  }\n  class AttrCacheTable{\n    -attrCache[MAX_OPEN] : AttrCacheEntry*\n    -recordToAttrCatEntry(union Attribute record[ATTRCAT_NO_ATTRS], AttrCatEntry *attrCatEntry)$ void\ud83d\udd35\n    +getAttrCatEntry(int relId, int attrOffset, AttrCatEntry *attrCatBuf)$ int\ud83d\udd35\n    +getAttrCatEntry(int relId, char attrName[ATTR_SIZE], AttrCatEntry *attrCatBuf)$ int\ud83d\udd35\n  }\n  class OpenRelTable{\n    -tableMetaInfo[MAX_OPEN] : OpenRelTableMetaInfo\n    +OpenRelTable(): \ud83d\udd35\n    +~OpenRelTable(): \ud83d\udfe0\n    -getFreeOpenRelTableEntry()$ int\ud83d\udd35\n    +getRelId(char relName[ATTR_SIZE])$ int\ud83d\udd35\n    +openRel(char relName[ATTR_SIZE])$ int\ud83d\udd35\n    +closeRel(int relId)$ int\ud83d\udfe0\n  }\n"}),(0,r.kt)("br",null),(0,r.kt)("p",null,"In earlier stages, we had implemented the ",(0,r.kt)("inlineCode",{parentName:"p"},"RelCacheTable::getRelCatEntry()")," function to get an entry from the relation cache. In this stage, we will implement it's counterpart ",(0,r.kt)("inlineCode",{parentName:"p"},"RelCacheTable::setRelCatEntry()")," which is how we update the values stored in the relation cache during runtime. We will also implement the ",(0,r.kt)("inlineCode",{parentName:"p"},"RelCacheTable::relCatEntryToRecord()")," which we'll be using while closing the relation."),(0,r.kt)("details",null,(0,r.kt)("summary",null,"Cache/RelCacheTable.cpp"),(0,r.kt)("p",null,"Implement the following functions looking at their respective design docs"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/docs/Design/Cache%20Layer#relcachetable--setrelcatentry"},(0,r.kt)("inlineCode",{parentName:"a"},"RelCacheTable::setRelCatEntry()"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/docs/Design/Cache%20Layer#relcachetable--relcatentrytorecord"},(0,r.kt)("inlineCode",{parentName:"a"},"RelCacheTable::relCatEntryToRecord()"))))),(0,r.kt)("p",null,"Now, we modify our ",(0,r.kt)("inlineCode",{parentName:"p"},"OpenRelTable::closeRel()")," function and the ",(0,r.kt)("inlineCode",{parentName:"p"},"OpenRelTable")," destructor to handle write-back for the relation cache."),(0,r.kt)("details",null,(0,r.kt)("summary",null,"Cache/OpenRelTable.cpp"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"OpenRelTable::~OpenRelTable() {\n  // close all open relations i.e rel-id 2 to MAX_OPEN using OpenRelTable::closeRel()\n  //    (you did this already)\n\n  /************ Closing the entries in the relation cache ************/\n\n  /****** releasing the entry corresponding to Attribute Catalog relation from Relation Cache Table ******/\n  if (/* the RelCatEntry of the ATTRCAT_RELIDth Relation Cache entry has been modified */) {\n\n    /* Get the Relation Catalog entry from Cache using RelCacheTable::relCatEntryToRecord().\n    Write back that entry by instantiating RecBuffer class. Use recId member\n    field and recBuffer.setRecord() */\n  }\n  // free the memory dynamically allocated to this RelCacheEntry\n\n\n  /****** releasing the entry corresponding to Relation Catalog relation from Relation Cache Table ******/\n  if(/* Relation Catalog entry of the RELCAT_RELIDth RelCacheEntry has been modified */) {\n\n    /* Get the Relation Catalog entry from Cache using RelCacheTable::relCatEntryToRecord().\n    Write back that entry by instantiating RecBuffer class. Use recId member\n    field and recBuffer.setRecord() */\n  }\n  // free the memory dynamically allocated for this RelCacheEntry\n\n\n  /************ Closing the entries in the attribute cache ************/\n\n  // free the memory allocated for the attribute cache entries of rel-id 0 and 1\n}\n\n\nint OpenRelTable::closeRel(int relId) {\n  // confirm that rel-id fits the following conditions\n  //     - does not correspond to relation or attribute catalog\n  //     - 0 <=relId < MAX_OPEN\n  //     - corresponds to a free slot\n  //  (you did this already)\n\n  /****** Releasing the Relation Cache entry of the relation ******/\n\n  if (/* RelCatEntry of the relIdth Relation Cache entry has been modified */)\n  {\n    /* Get the Relation Catalog entry from Cache using\n    RelCacheTable::relCatEntryToRecord().\n    Write back that entry by instantiating RecBuffer class. Use recId member\n    field and recBuffer.setRecord() */\n  }\n\n  /****** Releasing the Attribute Cache entry of the relation ******/\n\n  // free the memory allocated in the attribute caches which was\n  // allocated in the OpenRelTable::openRel() function\n\n\n  /****** Updating metadata in the Open Relation Table of the relation  ******/\n\n  // update `tableMetaInfo` to set `relId` as a free slot\n\n  return SUCCESS;\n}\n"))),(0,r.kt)("h3",{id:"inserting-a-record"},"Inserting a Record"),(0,r.kt)("p",null,"A sequence diagram documenting the call sequence for a record insertion is shown below."),(0,r.kt)("mermaid",{value:" %%{init: { 'sequence': {'mirrorActors':false} } }%%\nsequenceDiagram\n  actor User\n  participant Frontend User Interface\n  participant Frontend Programming Interface\n  participant Algebra Layer\n  participant Block Access Layer\n  participant Cache Layer\n  participant Buffer Layer\n  User->>Frontend User Interface: INSERT INTO TABLE VALUES\n  activate Frontend User Interface\n  Frontend User Interface->>Frontend Programming Interface :insert_into_table_values\ud83d\udfe2\n  activate Frontend Programming Interface\n  Frontend Programming Interface->>Algebra Layer:insert()\ud83d\udfe2\n  activate Algebra Layer\n  Algebra Layer->>Block Access Layer:insert()\ud83d\udfe0\n  activate Block Access Layer\n  Note over Block Access Layer, Block Access Layer: find an empty slot\n  Block Access Layer ->> Buffer Layer: setRecord()\ud83d\udd35, setHeader()\ud83d\udd35, setSlotMap()\ud83d\udfe2\n  activate Buffer Layer\n  Buffer Layer--\x3e>Block Access Layer:operation status\n  deactivate Buffer Layer\n  Block Access Layer->>Cache Layer:setRelCatEntry()\ud83d\udfe2\n  activate Cache Layer\n  Cache Layer--\x3e>Block Access Layer:operation status\n  deactivate Cache Layer\n  Block Access Layer--\x3e>User:operation status\n  deactivate Block Access Layer\n  deactivate Algebra Layer\n  deactivate Frontend Programming Interface\n  deactivate Frontend User Interface\n"}),(0,r.kt)("br",null),(0,r.kt)("mermaid",{value:"classDiagram\n  class Algebra{\n    +select(char srcRel[ATTR_SIZE], char targetRel[ATTR_SIZE], char attr[ATTR_SIZE], int op, char strVal[ATTR_SIZE])$ int\ud83d\udfe4\n    +insert(char relName[ATTR_SIZE], int nAttrs, char record[][ATTR_SIZE])$ int\ud83d\udfe2\n  }"}),(0,r.kt)("mermaid",{value:"classDiagram\n  class BlockAccess{\n    +linearSearch(int relId, char attrName[ATTR_SIZE], Attribute attrVal, int op)$ RecId\ud83d\udd35\n    +renameRelation(char oldName[ATTR_SIZE], char newName[ATTR_SIZE])$ int\ud83d\udd35\n    +renameAttribute(char relName[ATTR_SIZE], char oldName[ATTR_SIZE], char newName[ATTR_SIZE])$ int\ud83d\udd35\n    +insert(int relId, union Attribute* record)$ int\ud83d\udfe0\n  }"}),(0,r.kt)("hr",null),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Buffer Layer")),(0,r.kt)("mermaid",{value:"classDiagram\n  direction LR\n  BlockBuffer <|-- RecBuffer\n  StaticBuffer<|..RecBuffer : uses\n  StaticBuffer<|..BlockBuffer : uses\n  class RecBuffer{\n    +RecBuffer() \ud83d\udd35\n    +RecBuffer(int blockNum) \ud83d\udd35\n    +getRecord(union Attribute *rec, int slotNum) int\ud83d\udd35\n    +setRecord(union Attribute *rec, int slotNum) int\ud83d\udd35\n    +getSlotMap(unsigned char *slotMap) int\ud83d\udd35\n    +setSlotMap(unsigned char *slotMap) int\ud83d\udfe2\n  }\n  class BlockBuffer{\n    #blockNum: int\n    +BlockBuffer(char blockType) \ud83d\udd35\n    +BlockBuffer(int blockNum) \ud83d\udd35\n    +getHeader(struct HeadInfo *head) int\ud83d\udd35\n    +setHeader(struct HeadInfo *head) int\ud83d\udd35\n    #setBlockType(int blockType) int\ud83d\udd35\n    #getFreeBlock(int blockType) int\ud83d\udd35\n    #loadBlockAndGetBufferPtr(unsigned char **buffPtr) int\ud83d\udd35\n  }\n  class StaticBuffer{\n    -blocks[BUFFER_CAPACITY][BLOCK_SIZE]: unsigned char\n    -metainfo[BUFFER_CAPACITY]: struct BufferMetaInfo\n    -blockAllocMap[DISK_BLOCKS]: unsigned char\n    +StaticBuffer() \ud83d\udd35\n    +~StaticBuffer() \ud83d\udd35\n    -getFreeBuffer(int blockNum)$ int\ud83d\udd35\n    -getBufferNum(int blockNum)$ int\ud83d\udd35\n    +setDirtyBit(int blockNum)$ int\ud83d\udd35\n  }"}),(0,r.kt)("br",null),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"todo verify if the caches and catalogs have right values.",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"didn't check during implementatoin"))),(0,r.kt)("li",{parentName:"ul"},"todo exercises should test new block allocatoin")))}u.isMDXComponent=!0}}]);