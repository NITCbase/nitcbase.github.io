"use strict";(self.webpackChunknitcbase=self.webpackChunknitcbase||[]).push([[53],{1109:e=>{e.exports=JSON.parse('{"pluginId":"default","version":"current","label":"Next","banner":null,"badge":false,"noIndex":false,"className":"docs-version-current","isLast":true,"docsSidebars":{"Design":[{"type":"link","label":"Architecture","href":"/docs/Design/Architecture","docId":"Design/Architecture"},{"type":"link","label":"System Design","href":"/docs/Design/DesignDiagram","docId":"Design/DesignDiagram"},{"type":"link","label":"Frontend Interface","href":"/docs/Design/Frontend","docId":"Design/Frontend"},{"type":"link","label":"Algebra Layer","href":"/docs/Design/Algebra Layer","docId":"Design/Algebra Layer"},{"type":"link","label":"Schema Layer","href":"/docs/Design/Schema Layer","docId":"Design/Schema Layer"},{"type":"link","label":"Block Access Layer","href":"/docs/Design/Block Access Layer","docId":"Design/Block Access Layer"},{"type":"link","label":"B+ Tree Layer","href":"/docs/Design/B+ Tree Layer","docId":"Design/B+ Tree Layer"},{"type":"category","label":"Cache Layer","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Introduction","href":"/docs/Design/Cache Layer/intro","docId":"Design/Cache Layer/intro"},{"type":"link","label":"class RelCacheTable","href":"/docs/Design/Cache Layer/RelCacheTable","docId":"Design/Cache Layer/RelCacheTable"},{"type":"link","label":"class AttrCacheTable","href":"/docs/Design/Cache Layer/AttrCacheTable","docId":"Design/Cache Layer/AttrCacheTable"},{"type":"link","label":"class OpenRelTable","href":"/docs/Design/Cache Layer/OpenRelTable","docId":"Design/Cache Layer/OpenRelTable"}]},{"type":"category","label":"Buffer Layer","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Introduction","href":"/docs/Design/Buffer Layer/intro","docId":"Design/Buffer Layer/intro"},{"type":"link","label":"class StaticBuffer","href":"/docs/Design/Buffer Layer/StaticBuffer","docId":"Design/Buffer Layer/StaticBuffer"},{"type":"link","label":"class BlockBuffer","href":"/docs/Design/Buffer Layer/BlockBuffer","docId":"Design/Buffer Layer/BlockBuffer"},{"type":"link","label":"class RecBuffer","href":"/docs/Design/Buffer Layer/RecBuffer","docId":"Design/Buffer Layer/RecBuffer"},{"type":"link","label":"classes IndBuffer, IndInternal, IndLeaf","href":"/docs/Design/Buffer Layer/IndBuffer","docId":"Design/Buffer Layer/IndBuffer"}]},{"type":"link","label":"Physical Layer","href":"/docs/Design/Physical Layer","docId":"Design/Physical Layer"}],"Roadmap":[{"type":"link","label":"Introduction","href":"/docs/Roadmap/","docId":"Roadmap/index"},{"type":"link","label":"Stage 0 : Installation and Preparation","href":"/docs/Roadmap/Stage00","docId":"Roadmap/Stage00"},{"type":"link","label":"Stage 1 : Understanding the Disk Interface","href":"/docs/Roadmap/Stage01","docId":"Roadmap/Stage01"},{"type":"link","label":"Stage 2: Record Blocks and Catalogs","href":"/docs/Roadmap/Stage02","docId":"Roadmap/Stage02"},{"type":"link","label":"Stage 3 : The Disk Buffer and Catalog Caches","href":"/docs/Roadmap/Stage03","docId":"Roadmap/Stage03"},{"type":"link","label":"Stage 4 : Linear Search on Relations","href":"/docs/Roadmap/Stage04","docId":"Roadmap/Stage04"},{"type":"link","label":"Stage 5 : Opening Relations","href":"/docs/Roadmap/Stage05","docId":"Roadmap/Stage05"},{"type":"link","label":"Stage 6 : Buffer Management and Disk Write-back","href":"/docs/Roadmap/Stage06","docId":"Roadmap/Stage06"},{"type":"link","label":"Stage 7 : Inserting Records Into Relations","href":"/docs/Roadmap/Stage07","docId":"Roadmap/Stage07"},{"type":"link","label":"Stage 8 : Creating and Deleting Relations","href":"/docs/Roadmap/Stage08","docId":"Roadmap/Stage08"},{"type":"link","label":"Stage 9 : Selection and Projection on Relations","href":"/docs/Roadmap/Stage09","docId":"Roadmap/Stage09"}],"Commands":[{"type":"link","label":"User Interface Commands","href":"/docs/User Interface Commands/","docId":"User Interface Commands/index"},{"type":"link","label":"Data Definition Language Commands","href":"/docs/User Interface Commands/ddl","docId":"User Interface Commands/ddl"},{"type":"link","label":"Data Manipulation Language Commands","href":"/docs/User Interface Commands/dml","docId":"User Interface Commands/dml"},{"type":"link","label":"XFS Commands","href":"/docs/User Interface Commands/efs","docId":"User Interface Commands/efs"},{"type":"link","label":"Script Commands","href":"/docs/User Interface Commands/script-cmds","docId":"User Interface Commands/script-cmds"}]},"docs":{"Design/Algebra Layer":{"id":"Design/Algebra Layer","title":"Algebra Layer","description":"The Schema Layer code is to be written in Algebra.cpp and it\'s header file Algebra.h","sidebar":"Design"},"Design/Architecture":{"id":"Design/Architecture","title":"Architecture","description":"NITCbase has a seven layer design. This section provides documentation for each of the seven layers and certain additional design specific details.","sidebar":"Design"},"Design/B+ Tree Layer":{"id":"Design/B+ Tree Layer","title":"B+ Tree Layer","description":"- B+ Trees","sidebar":"Design"},"Design/Block Access Layer":{"id":"Design/Block Access Layer","title":"Block Access Layer","description":"The Block Access Layer code is to be written in BlockAccess.cpp and it\'s header file BlockAccess.h","sidebar":"Design"},"Design/Buffer Layer/BlockBuffer":{"id":"Design/Buffer Layer/BlockBuffer","title":"class BlockBuffer","description":"The class BlockBuffer is a generic class for representing a disk block of any type (Record, Internal Index, or Leaf Index). Its only field is blockNum. The field blockNum stores the disk block number corresponding to the block object. The block has to be loaded and stored in one of the 32 buffers of the StaticBuffer class before its data can be accessed. Adding to the complexity is the fact that the block, once loaded, may not even be present in the buffer memory later on because of the buffer replacement algorithm implemented by Buffer Layer. In order to work with data of the block, any method of the BlockBuffer class or its descendent classes need to know the address of the buffer memory to which the block has been loaded. Hence any method of this class operating on the block data should first get the pointer to the buffer memory that holds the contents of the block. The loadBlockAndGetBufferPtr() method is used for this purpose. The public methods of BlockBuffer deal with information like header and block type, which are generic to all blocks. RecBuffer and IndBuffer classes extend the class BlockBuffer, thereby, inheriting all the fields and methods of BlockBuffer.","sidebar":"Design"},"Design/Buffer Layer/IndBuffer":{"id":"Design/Buffer Layer/IndBuffer","title":"classes IndBuffer, IndInternal, IndLeaf","description":"class IndBuffer","sidebar":"Design"},"Design/Buffer Layer/intro":{"id":"Design/Buffer Layer/intro","title":"Introduction","description":"The Buffer Layer code is to be written in 2 pairs of files:","sidebar":"Design"},"Design/Buffer Layer/RecBuffer":{"id":"Design/Buffer Layer/RecBuffer","title":"class RecBuffer","description":"An object of the RecBuffer class is associated with a record block. In a Record block, a slot can store one record, and each record is a fixed sized set of Attributes. Ordering of data as records and making use of slotmap are done only in a record block. Public methods of this class deal with access/modification of the records and the slotmap. RecBuffer class extends the BlockBuffer class. Thus, all its protected fields and methods can be accessed by RecBuffer class.","sidebar":"Design"},"Design/Buffer Layer/StaticBuffer":{"id":"Design/Buffer Layer/StaticBuffer","title":"class StaticBuffer","description":"The class StaticBuffer contains as its member field, blocksBUFFERCAPACITY, a two-dimensional array of unsigned characters with size sufficient to store 32 disk blocks in memory at any given time. Logically blocks[i] can be used to buffer one disk block for each 0 \u2264 i \u2264 31. Each entry of blocks, i.e., blocks[i], is referred to as buffer block in the NITCbase documentation. Buffer blocks will be committed back to the disk as and when required. In addition to storing the data of a block, class StaticBuffer also maintains meta-information for each loaded block in an array of BufferMetaInfo structures through the metaInfo[BUFFERCAPACITY] field. StaticBuffer class also maintains a copy of the **Block Allocation Map** in its blockAllocMap[DISKBLOCKS] field. The ith entry of the Block Allocation Map specifies whether the ith block is occupied or free. If occupied, it stores the type (REC/INDINTERNAL/INDLEAF) of the block, else it stores UNUSED_BLK.","sidebar":"Design"},"Design/Cache Layer/AttrCacheTable":{"id":"Design/Cache Layer/AttrCacheTable","title":"class AttrCacheTable","description":"The class AttrCacheTable is used to cache Attribute Catalog entries of the attributes of open relations in NITCbase. The first two entries of the Attribute Cache Table corresponding to RELCATRELID and ATTRCATRELID are reserved for storing the entries of Relation Catalog relation and Attribute Catalog relation, respectively. These are loaded into the cache by the _OpenRelTable constructor_ at the start of the session. These relations remain in the cache memory throughout the session and can only be closed by the _OpenRelTable destructor_ during shutdown.","sidebar":"Design"},"Design/Cache Layer/intro":{"id":"Design/Cache Layer/intro","title":"Introduction","description":"The Cache Layer code is to be written in 3 pairs of files:","sidebar":"Design"},"Design/Cache Layer/OpenRelTable":{"id":"Design/Cache Layer/OpenRelTable","title":"class OpenRelTable","description":"NITCbase requires that a relation be cached for the duration it is accessed to improve the processing time. The Open Relation Table is a data structure used as an interface for operations that accesses both Relation Cache and Attribute Cache together. The OpenRelTable class is used for this purpose. As per the NITCbase design, the ith entry of the OpenRelTable corresponds to the ith entry of the RelCacheTable and AttrCacheTable and is used to store the data of a single relation whose relation id is i. The public getRelId() method of the OpenRelTable returns the relation id of the input relation name.","sidebar":"Design"},"Design/Cache Layer/RelCacheTable":{"id":"Design/Cache Layer/RelCacheTable","title":"class RelCacheTable","description":"The class RelCacheTable is used to cache Relation Catalog entries of all the open relations in NITCbase. The first two entries of the Relation Cache Table corresponding to RELCATRELID and ATTRCATRELID are reserved for storing the entries of Relation Catalog relation and Attribute Catalog relation, respectively. These are loaded into the cache by the _OpenRelTable constructor_ at the start of the session. These relations remain in the cache memory throughout the session and can only be closed by the _OpenRelTable destructor_ during shutdown.","sidebar":"Design"},"Design/DesignDiagram":{"id":"Design/DesignDiagram","title":"System Design","description":"The following System Design Diagram shows the commands / functions to be implemented by students at each layer and also shows their invocation order:","sidebar":"Design"},"Design/Frontend":{"id":"Design/Frontend","title":"Frontend Interface","description":"Introduction","sidebar":"Design"},"Design/Physical Layer":{"id":"Design/Physical Layer","title":"Physical Layer","description":"The disk binary file that simulates the NITCbase disk (and the run copy of disk called diskruncopy) is located in the Disk/ directory.","sidebar":"Design"},"Design/Schema Layer":{"id":"Design/Schema Layer","title":"Schema Layer","description":"The Schema Layer code is to be written in Schema.cpp and it\'s header file Schema.h","sidebar":"Design"},"Misc/B+ Trees":{"id":"Misc/B+ Trees","title":"B+ Trees","description":"We know that the objective of indexing is to make the retrieval of records quicker. The key to achieve this lies in the choice of a suitable underlying data structure that defines the structure of index in the disk. NITCbase uses the B+ tree data structure for indexing."},"Misc/GDB":{"id":"Misc/GDB","title":"GNU Debugger(GDB)","description":"Introduction"},"Misc/index":{"id":"Misc/index","title":"Miscellaneous Pages","description":"This page contains supplementary guides and documentation which are to be referenced by you as you proceed through the roadmap. You will be linked to the appropriate pages as needed. However, an index of the pages present are provided below in case you want to quickly jump to a page."},"Misc/Indexing":{"id":"Misc/Indexing","title":"Indexing in NITCbase","description":"Introduction"},"Misc/Installation Guidelines":{"id":"Misc/Installation Guidelines","title":"Installation Guidelines","description":"The recommended way to work on NITCbase is using a dedicated docker container. Docker allows us to maintain a consistent experience across all the Linux distributions and versions of core utilities you might have installed."},"Misc/ManualSetup":{"id":"Misc/ManualSetup","title":"Manual Setup","description":"The following setup instructions assume that you have a Linux based machine."},"Misc/XFS Interface":{"id":"Misc/XFS Interface","title":"XFS Interface","description":"XFS Interface is an external command-line interface to access the NITCbase filesystem from the host (UNIX) system."},"Roadmap/index":{"id":"Roadmap/index","title":"Introduction","description":"This roadmap is divided into stages. From Stage 2, you will build NITCbase incrementally. Links are provided throughout the document for further reference. There are two kinds of links. The contents of the important links must be read immediately before proceeding with the roadmap. The informative links may be clicked for more information about a particular concept. However this information may not be necessary at that point and you may proceed with the roadmap without visiting these links.","sidebar":"Roadmap"},"Roadmap/Stage00":{"id":"Roadmap/Stage00","title":"Stage 0 : Installation and Preparation","description":"- Setup the environment to build NITCbase","sidebar":"Roadmap"},"Roadmap/Stage01":{"id":"Roadmap/Stage01","title":"Stage 1 : Understanding the Disk Interface","description":"- Learn to read/write disk blocks to/from the XFS disk to memory using the Disk class.","sidebar":"Roadmap"},"Roadmap/Stage02":{"id":"Roadmap/Stage02","title":"Stage 2: Record Blocks and Catalogs","description":"- Understand the storage model for records in NITCbase","sidebar":"Roadmap"},"Roadmap/Stage03":{"id":"Roadmap/Stage03","title":"Stage 3 : The Disk Buffer and Catalog Caches","description":"- Understand disk buffering in NITCbase in the Buffer Layer","sidebar":"Roadmap"},"Roadmap/Stage04":{"id":"Roadmap/Stage04","title":"Stage 4 : Linear Search on Relations","description":"- Familiarise with the mechanism of receiving commands from the Frontend User Interface and calling the appropriate function in the lower layers through the Frontend Programming Interface","sidebar":"Roadmap"},"Roadmap/Stage05":{"id":"Roadmap/Stage05","title":"Stage 5 : Opening Relations","description":"- Familiarise with the design of the Cache Layer and understand the maintenance of the catalog caches","sidebar":"Roadmap"},"Roadmap/Stage06":{"id":"Roadmap/Stage06","title":"Stage 6 : Buffer Management and Disk Write-back","description":"- Implement the commands to rename relations and attributes","sidebar":"Roadmap"},"Roadmap/Stage07":{"id":"Roadmap/Stage07","title":"Stage 7 : Inserting Records Into Relations","description":"- Implement the record insertion functionality in NITCbase","sidebar":"Roadmap"},"Roadmap/Stage08":{"id":"Roadmap/Stage08","title":"Stage 8 : Creating and Deleting Relations","description":"- Implement the creation of relations by inserting records into the catalogs","sidebar":"Roadmap"},"Roadmap/Stage09":{"id":"Roadmap/Stage09","title":"Stage 9 : Selection and Projection on Relations","description":"- Complete the implementation of the NITCbase commands that do the following operations","sidebar":"Roadmap"},"User Interface Commands/ddl":{"id":"User Interface Commands/ddl","title":"Data Definition Language Commands","description":"The Data Definition Language(DDL) commands are used to define the database schema. They are used to create and delete relations, modify the structure of relations in the database and also create and delete indexes on the attributes of relations. DDL Commands are supported by both XFS Interface and Frontend Interface. The following are the DDL commands supported by NITCbase.","sidebar":"Commands"},"User Interface Commands/dml":{"id":"User Interface Commands/dml","title":"Data Manipulation Language Commands","description":"The Data Manipulation Language(DML) commands are used to manipulate the data stored in the relations of the database. DML Commands are supported by both XFS Interface and Frontend Interface. The following are the DML commands supported by NITCbase.","sidebar":"Commands"},"User Interface Commands/efs":{"id":"User Interface Commands/efs","title":"XFS Commands","description":"The XFS commands are used to format the disk, dump disk data structures like Block Allocation Map, Relation Catalog and Attribute Catalog, load / remove relations, list relations and copy the records of a relation on the NITCbase disk to a UNIX file. These commands are only available for the XFS Interface. The following are the XFS commands supported by NITCbase.","sidebar":"Commands"},"User Interface Commands/index":{"id":"User Interface Commands/index","title":"User Interface Commands","description":"NITCbase supports two user interfaces namely, XFS Interface and Frontend Interface. The commands supported by the two interfaces fall into the following four categories:","sidebar":"Commands"},"User Interface Commands/script-cmds":{"id":"User Interface Commands/script-cmds","title":"Script Commands","description":"Script commands are available for both XFS interface and frontend interface. These commands help the user to execute mutliple commands sequentially from a file and also to print out custom useful messages into terminal for debugging and informational purposes.","sidebar":"Commands"}}}')}}]);