"use strict";(self.webpackChunknitcbase_beta=self.webpackChunknitcbase_beta||[]).push([[6736],{3905:function(e,t,a){a.d(t,{Zo:function(){return u},kt:function(){return c}});var n=a(7294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function l(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?l(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):l(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},l=Object.keys(e);for(n=0;n<l.length;n++)a=l[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(n=0;n<l.length;n++)a=l[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var m=n.createContext({}),d=function(e){var t=n.useContext(m),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},u=function(e){var t=d(e.components);return n.createElement(m.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},s=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,l=e.originalType,m=e.parentName,u=o(e,["components","mdxType","originalType","parentName"]),s=d(a),c=r,h=s["".concat(m,".").concat(c)]||s[c]||p[c]||l;return a?n.createElement(h,i(i({ref:t},u),{},{components:a})):n.createElement(h,i({ref:t},u))}));function c(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var l=a.length,i=new Array(l);i[0]=s;var o={};for(var m in t)hasOwnProperty.call(t,m)&&(o[m]=t[m]);o.originalType=e,o.mdxType="string"==typeof e?e:r,i[1]=o;for(var d=2;d<l;d++)i[d]=a[d];return n.createElement.apply(null,i)}return n.createElement.apply(null,a)}s.displayName="MDXCreateElement"},9960:function(e,t,a){a.d(t,{Z:function(){return c}});var n=a(3366),r=a(7294),l=a(3727),i=a(2263),o=a(3919),m=a(412),d=(0,r.createContext)({collectLink:function(){}}),u=a(4996),p=a(8780),s=["isNavLink","to","href","activeClassName","isActive","data-noBrokenLinkCheck","autoAddBaseUrl"];var c=function(e){var t,a,c=e.isNavLink,h=e.to,N=e.href,k=e.activeClassName,g=e.isActive,T=e["data-noBrokenLinkCheck"],f=e.autoAddBaseUrl,b=void 0===f||f,E=(0,n.Z)(e,s),R=(0,i.Z)().siteConfig,A=R.trailingSlash,v=R.baseUrl,y=(0,u.C)().withBaseUrl,C=(0,r.useContext)(d),I=h||N,_=(0,o.Z)(I),O=null==I?void 0:I.replace("pathname://",""),S=void 0!==O?(a=O,b&&function(e){return e.startsWith("/")}(a)?y(a):a):void 0;S&&_&&(S=(0,p.applyTrailingSlash)(S,{trailingSlash:A,baseUrl:v}));var L=(0,r.useRef)(!1),w=c?l.OL:l.rU,D=m.Z.canUseIntersectionObserver,P=(0,r.useRef)();(0,r.useEffect)((function(){return!D&&_&&null!=S&&window.docusaurus.prefetch(S),function(){D&&P.current&&P.current.disconnect()}}),[P,S,D,_]);var B=null!==(t=null==S?void 0:S.startsWith("#"))&&void 0!==t&&t,x=!S||!_||B;return S&&_&&!B&&!T&&C.collectLink(S),x?r.createElement("a",Object.assign({href:S},I&&!_&&{target:"_blank",rel:"noopener noreferrer"},E)):r.createElement(w,Object.assign({},E,{onMouseEnter:function(){L.current||null==S||(window.docusaurus.preload(S),L.current=!0)},innerRef:function(e){var t,a;D&&e&&_&&(t=e,a=function(){null!=S&&window.docusaurus.prefetch(S)},P.current=new window.IntersectionObserver((function(e){e.forEach((function(e){t===e.target&&(e.isIntersecting||e.intersectionRatio>0)&&(P.current.unobserve(t),P.current.disconnect(),a())}))})),P.current.observe(t))},to:S||""},c&&{isActive:g,activeClassName:k}))}},3919:function(e,t,a){function n(e){return!0===/^(\w*:|\/\/)/.test(e)}function r(e){return void 0!==e&&!n(e)}a.d(t,{b:function(){return n},Z:function(){return r}})},4996:function(e,t,a){a.d(t,{C:function(){return l},Z:function(){return i}});var n=a(2263),r=a(3919);function l(){var e=(0,n.Z)().siteConfig,t=(e=void 0===e?{}:e).baseUrl,a=void 0===t?"/":t,l=e.url;return{withBaseUrl:function(e,t){return function(e,t,a,n){var l=void 0===n?{}:n,i=l.forcePrependBaseUrl,o=void 0!==i&&i,m=l.absolute,d=void 0!==m&&m;if(!a)return a;if(a.startsWith("#"))return a;if((0,r.b)(a))return a;if(o)return t+a;var u=a.startsWith(t)?a:t+a.replace(/^\//,"");return d?e+u:u}(l,a,e,t)}}}function i(e,t){return void 0===t&&(t={}),(0,l().withBaseUrl)(e,t)}},8802:function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t){var a=t.trailingSlash,n=t.baseUrl;if(e.startsWith("#"))return e;if(void 0===a)return e;var r,l=e.split(/[#?]/)[0],i="/"===l||l===n?l:(r=l,a?function(e){return e.endsWith("/")?e:e+"/"}(r):function(e){return e.endsWith("/")?e.slice(0,-1):e}(r));return e.replace(l,i)}},8780:function(e,t,a){var n=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0}),t.uniq=t.applyTrailingSlash=void 0;var r=a(8802);Object.defineProperty(t,"applyTrailingSlash",{enumerable:!0,get:function(){return n(r).default}});var l=a(9964);Object.defineProperty(t,"uniq",{enumerable:!0,get:function(){return n(l).default}})},9964:function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e){return Array.from(new Set(e))}},6741:function(e,t,a){a.r(t),a.d(t,{frontMatter:function(){return m},contentTitle:function(){return d},metadata:function(){return u},toc:function(){return p},default:function(){return c}});var n=a(7462),r=a(3366),l=(a(7294),a(3905)),i=a(9960),o=["components"],m={sidebar_position:4,title:"Schema Layer"},d=void 0,u={unversionedId:"Design/Schema Layer",id:"Design/Schema Layer",isDocsHomePage:!1,title:"Schema Layer",description:"https://nitcbase.github.io/archived-site/design/schema.html",source:"@site/docs/Design/Schema Layer.md",sourceDirName:"Design",slug:"/Design/Schema Layer",permalink:"/docs/Design/Schema Layer",tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4,title:"Schema Layer"},sidebar:"Design",previous:{title:"Algebra Layer",permalink:"/docs/Design/Algebra Layer"},next:{title:"Block Access Layer",permalink:"/docs/Design/Block Access Layer"}},p=[{value:"Layout",id:"layout",children:[],level:2},{value:"class Schema",id:"class-schema",children:[],level:2},{value:"Schema :: createRel()",id:"schema--createrel",children:[{value:"Description",id:"description",children:[],level:4},{value:"Arguments",id:"arguments",children:[],level:4},{value:"Return value",id:"return-value",children:[],level:4},{value:"Algorithm",id:"algorithm",children:[],level:4}],level:2},{value:"Schema :: deleteRel()",id:"schema--deleterel",children:[{value:"Description",id:"description-1",children:[],level:4},{value:"Arguments",id:"arguments-1",children:[],level:4},{value:"Return value",id:"return-value-1",children:[],level:4},{value:"Algorithm",id:"algorithm-1",children:[],level:4}],level:2},{value:"Schema :: createIndex()",id:"schema--createindex",children:[{value:"Description",id:"description-2",children:[],level:4},{value:"Arguments",id:"arguments-2",children:[],level:4},{value:"Return value",id:"return-value-2",children:[],level:4},{value:"Algorithm",id:"algorithm-2",children:[],level:4}],level:2},{value:"Schema :: dropIndex()",id:"schema--dropindex",children:[{value:"Description",id:"description-3",children:[],level:4},{value:"Arguments",id:"arguments-3",children:[],level:4},{value:"Return value",id:"return-value-3",children:[],level:4},{value:"Algorithm",id:"algorithm-3",children:[],level:4}],level:2},{value:"Schema :: renameRel()",id:"schema--renamerel",children:[{value:"Description",id:"description-4",children:[],level:4},{value:"Arguments",id:"arguments-4",children:[],level:4},{value:"Return value",id:"return-value-4",children:[],level:4},{value:"Algorithm",id:"algorithm-4",children:[],level:4}],level:2},{value:"Schema :: renameAttr()",id:"schema--renameattr",children:[{value:"Description",id:"description-5",children:[],level:4},{value:"Arguments",id:"arguments-5",children:[],level:4},{value:"Return value",id:"return-value-5",children:[],level:4},{value:"Algorithm",id:"algorithm-5",children:[],level:4}],level:2},{value:"Schema :: openRel()",id:"schema--openrel",children:[{value:"Description",id:"description-6",children:[],level:4},{value:"Arguments",id:"arguments-6",children:[],level:4},{value:"Return value",id:"return-value-6",children:[],level:4},{value:"Algorithm",id:"algorithm-6",children:[],level:4}],level:2},{value:"Schema :: closeRel()",id:"schema--closerel",children:[{value:"Description",id:"description-7",children:[],level:4},{value:"Arguments",id:"arguments-7",children:[],level:4},{value:"Return value",id:"return-value-7",children:[],level:4},{value:"Algorithm",id:"algorithm-7",children:[],level:4}],level:2},{value:"Schema :: getSchema()",id:"schema--getschema",children:[],level:2}],s={toc:p};function c(e){var t=e.components,a=(0,r.Z)(e,o);return(0,l.kt)("wrapper",(0,n.Z)({},s,a,{components:t,mdxType:"MDXLayout"}),(0,l.kt)("p",null,(0,l.kt)("a",{parentName:"p",href:"https://nitcbase.github.io/archived-site/design/schema.html"},"https://nitcbase.github.io/archived-site/design/schema.html")),(0,l.kt)("div",{className:"admonition admonition-info alert alert--info"},(0,l.kt)("div",{parentName:"div",className:"admonition-heading"},(0,l.kt)("h5",{parentName:"div"},(0,l.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,l.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,l.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"}))),"note ")),(0,l.kt)("div",{parentName:"div",className:"admonition-content"},(0,l.kt)("p",{parentName:"div"},"The Schema Layer code is to be written in ",(0,l.kt)("inlineCode",{parentName:"p"},"Schema.cpp")," and it's header file ",(0,l.kt)("inlineCode",{parentName:"p"},"Schema.h")),(0,l.kt)("p",{parentName:"div"},(0,l.kt)("strong",{parentName:"p"},(0,l.kt)(i.Z,{to:"/schema_stub",mdxType:"Link"},"The stub code for these files can be found here."))))),(0,l.kt)("h2",{id:"layout"},"Layout"),(0,l.kt)("p",null,"The SQL-Like queries that alter the schema of the database are converted into a sequence of schema layer function calls by front end. These schema layer function calls processes the ",(0,l.kt)("strong",{parentName:"p"},"basic schema alteration requests to the database.")," "),(0,l.kt)("p",null,"The functions of Schema layer include:"),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("a",{parentName:"li",href:"#schema--createrel"},(0,l.kt)("strong",{parentName:"a"},"createRel"))),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("a",{parentName:"li",href:"#schema--deleterel"},(0,l.kt)("strong",{parentName:"a"},"deleteRel"))),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("a",{parentName:"li",href:"#schema--renamerel"},(0,l.kt)("strong",{parentName:"a"},"renameRel"))),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("a",{parentName:"li",href:"#schema--renameattr"},(0,l.kt)("strong",{parentName:"a"},"renameAttr"))),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("a",{parentName:"li",href:"#schema--createindex"},(0,l.kt)("strong",{parentName:"a"},"createIndex"))),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("a",{parentName:"li",href:"#schema--dropindex"},(0,l.kt)("strong",{parentName:"a"},"deleteIndex"))),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("a",{parentName:"li",href:"#schema--openrel"},(0,l.kt)("strong",{parentName:"a"},"openRel"))),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("a",{parentName:"li",href:"#schema--closerel"},(0,l.kt)("strong",{parentName:"a"},"closeRel"))),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("a",{parentName:"li",href:"#schema--getschema"},(0,l.kt)("strong",{parentName:"a"},"getSchema"))," - YET TO BE DESIGNED")),(0,l.kt)("p",null,"The method ",(0,l.kt)("inlineCode",{parentName:"p"},"openRel")," is used to the open a relations for access, ",(0,l.kt)("inlineCode",{parentName:"p"},"closeRel")," to close a relation and ",(0,l.kt)("inlineCode",{parentName:"p"},"getSchema")," to get the schema of the relation. NITCbase follows an Object-Oriented design for Schema Layer. The class definition is as shown below:"),(0,l.kt)("h2",{id:"class-schema"},"class Schema"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},"class Schema {\npublic:\n    static int createRel(char relName[], int numOfAttributes, char attrNames[][ATTR_SIZE], int attrType[]);\n    static int deleteRel(char relName[ATTR_SIZE]);\n    static int createIndex(char relName[ATTR_SIZE], char attrName[ATTR_SIZE]);\n    static int dropIndex(char relName[ATTR_SIZE], char attrName[ATTR_SIZE]);\n    static int renameRel(char oldRelName[ATTR_SIZE], char newRelName[ATTR_SIZE]);\n    static int renameAttr(char relName[ATTR_SIZE], char oldAttrName[ATTR_SIZE], char newAttrName[ATTR_SIZE]);\n    static int openRel(char relName[ATTR_SIZE]);\n    static int closeRel(char relName[ATTR_SIZE]);\n};\n")),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"schema--createrel"},"Schema :: createRel()"),(0,l.kt)("h4",{id:"description"},"Description"),(0,l.kt)("p",null,"This method creates a new Relation with the name, attribute/column list as specified in arguments."),(0,l.kt)("h4",{id:"arguments"},"Arguments"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"relName"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"char[ATTR_SIZE]")),(0,l.kt)("td",{parentName:"tr",align:null},"Name of the Relation.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"nAttrs"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"int")),(0,l.kt)("td",{parentName:"tr",align:null},"No. of attributes in the relation.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"attrs"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"char [][ATTR_SIZE]")),(0,l.kt)("td",{parentName:"tr",align:null},"pointer to array of Attribute/column names of the Relation.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"attrtype"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"int []")),(0,l.kt)("td",{parentName:"tr",align:null},"pointer to an array of attribute types.")))),(0,l.kt)("h4",{id:"return-value"},"Return value"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Value"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"SUCCESS")),(0,l.kt)("td",{parentName:"tr",align:null},"On successful creation of the relation")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"E_RELEXIST")),(0,l.kt)("td",{parentName:"tr",align:null},"If the relation with name relName already exists.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"E_DUPLICATEATTR")),(0,l.kt)("td",{parentName:"tr",align:null},"If two any two of the given attributes have same name.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"E_DISKFULL")),(0,l.kt)("td",{parentName:"tr",align:null},"If disk space is not sufficient for creating the new relation.")))),(0,l.kt)("h4",{id:"algorithm"},"Algorithm"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},'int createRel(char relName[],int nAttrs, char attrs[][ATTR_SIZE],int attrtype[]){\n\n    // let relNameAsAttribute be of type Attribute\n    // copy the relName into relNameAsAttribute.sVal\n\n    // let targetRelId be of type recId\n\n    /*\n        Search the relation RELCAT(relId RELCAT_RELID,which is equal to 0) for attribute value attribute "RelName" = relNameAsAttribute\n        using search() of Block Access Layer with OP = EQ and flagValidAttrName = True\n        Let the return value of search be retVal\n        Hint: retVal = BlockAccess::search(RELCAT_RELID, relCatSearchResultRecord, "RelName",\n                                        relNameAsAttribute, EQ, true);\n    */\n    \n    // if retVal == SUCCESS (i.e relation with relation name as relName already exists)\n    // return E_RELEXIST;\n\n    // compare every pair of attributes of attrNames[] array\n    // if any attribute names have same string value, return E_DUPLICATEATTR (i.e 2 attributes have same value)\n\n    // let Attribute relCatRecord[6] be the new record to be inserted into relation catalog corresponding to new relation)\n    // fill relCatRecord fields as given below\n    // offset RELCAT_REL_NAME_INDEX: relName\n    // offset RELCAT_NO_ATTRIBUTES_INDEX: numOfAttributes\n    // offset RELCAT_NO_RECORDS_INDEX: 0\n    // offset RELCAT_FIRST_BLOCK_INDEX: -1\n    // offset RELCAT_LAST_BLOCK_INDEX: -1\n    // offset RELCAT_NO_SLOTS_PER_BLOCK_INDEX: floor((2016 / (16 * nAttrs + 1)))\n\n    // retVal = BlockAccess::insert(RELCAT_RELID(=0), relCatRecord);\n    // if BlockAccess::insert fails return retVal\n\n    // iterate through 0 to numOfAttributes - 1 :\n    {\n        // let Attribute attrCatRecord[6] be the record in attribute catalog corresponding to i\'th Attribute)\n        // (where i is the iterator of the loop)\n        // fill attrCatRecord fields(corresponding to i\'th attribute of the relation) as given below\n        // offset ATTRCAT_REL_NAME_INDEX: relName\n        // offset ATTRCAT_ATTR_NAME_INDEX: attrNames[i]\n        // offset ATTRCAT_ATTR_TYPE_INDEX: attrTypes[i]\n        // offset ATTRCAT_PRIMARY_FLAG_INDEX: -1\n        // offset ATTRCAT_ROOT_BLOCK_INDEX: -1\n        // offset ATTRCAT_OFFSET_INDEX: i\n\n        // retVal = BlockAccess::insert(ATTRCAT_RELID(=1), attrCatRecord);\n        /* if insert fails:\n            delete the relation by calling deleteRel(targetrel) of schema layer\n            return E_DISKFULL\n        */\n    }\n\n    // return SUCCESS\n}\n')),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"schema--deleterel"},"Schema :: deleteRel()"),(0,l.kt)("h4",{id:"description-1"},"Description"),(0,l.kt)("p",null,"This method deletes the Relation with name as specified in arguments."),(0,l.kt)("h4",{id:"arguments-1"},"Arguments"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"relName"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"char[ATTR_SIZE]")),(0,l.kt)("td",{parentName:"tr",align:null},"Name of the Relation.")))),(0,l.kt)("h4",{id:"return-value-1"},"Return value"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Value"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"SUCCESS")),(0,l.kt)("td",{parentName:"tr",align:null},"On successful deletion of the relation.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"E_RELOPEN")),(0,l.kt)("td",{parentName:"tr",align:null},"If the relation is open.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"E_RELNOTEXIST")),(0,l.kt)("td",{parentName:"tr",align:null},"If the relation does not exist")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"E_NOTPERMITTED")),(0,l.kt)("td",{parentName:"tr",align:null},"If relName is either ",(0,l.kt)("em",{parentName:"td"},'"RELATIONCAT"')," or ",(0,l.kt)("em",{parentName:"td"},'"ATTRIBUTECAT"'),". i.e., when the user tries to delete the catalogs.")))),(0,l.kt)("h4",{id:"algorithm-1"},"Algorithm"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},'int Schema::deleteRel(char *relName) {\n    // if the relation to delete is either Relation Catalog or Attribute Catalog, return E_NOTPERMITTED\n        // compare the input relName with "RELATIONCAT" and "ATTRIBUTECAT"\n        // OR use the following constants: RELCAT_NAME and ATTRCAT_NAME\n\n\n    // get the open relation id using appropriate method of OpenRelTable class by passing relation name as argument\n\n    // if relation is opened in open relation table, return E_RELOPEN\n\n    // Call deleteRelation method of the Block Access Layer by passing appropriate argument.\n\n    // return the value returned by the above deleteRelation() call\n    // Errors from deleteRelation -> E_RELNOTEXIST\n        //  AS OF NOW, It can return E_OUT_OF_BOUND from loadBlockAndGetBufferPtr call,\n        //  but if done properly we will not reach this point\n        //  this comes up only when BlockBuffer(or RecBuffer) was initialized with an Invalid Block Number\n\n}\n')),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"schema--createindex"},"Schema :: createIndex()"),(0,l.kt)("h4",{id:"description-2"},"Description"),(0,l.kt)("p",null,"This method creates a bplus indexing on an attribute attrName in a relation relName as specified in arguments."),(0,l.kt)("h4",{id:"arguments-2"},"Arguments"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"relName"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"char[ATTR_SIZE]")),(0,l.kt)("td",{parentName:"tr",align:null},"Name of the Relation.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"attrName"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"char [ATTR_SIZE]")),(0,l.kt)("td",{parentName:"tr",align:null},"Name of the Attribute.")))),(0,l.kt)("h4",{id:"return-value-2"},"Return value"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Value"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"SUCCESS")),(0,l.kt)("td",{parentName:"tr",align:null},"On successful creation of B+ tree.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"E_RELNOTOPEN")),(0,l.kt)("td",{parentName:"tr",align:null},"If the relation is not open.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"E_ATTRNOTEXIST")),(0,l.kt)("td",{parentName:"tr",align:null},"If the attribute with name attrName does not exist.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"E_DISKFULL")),(0,l.kt)("td",{parentName:"tr",align:null},"If there is no enough space in the disk to create the tree")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"E_NOTPERMITTED")),(0,l.kt)("td",{parentName:"tr",align:null},"If the relName is either ",(0,l.kt)("em",{parentName:"td"},'"RELATIONCAT"')," or ",(0,l.kt)("em",{parentName:"td"},'"ATTRIBUTECAT"'),". i.e, when the user tries to create an index for catalogs.")))),(0,l.kt)("h4",{id:"algorithm-2"},"Algorithm"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},'int createIndex(char relName[ATTR_SIZE],char attrName[ATTR_SIZE]){\n    // if the relation name is either Relation Catalog or Attribute Catalog, return E_NOTPERMITTED\n        // compare the input relName with "RELATIONCAT" and "ATTRIBUTECAT"\n        // OR use the following constants: RELCAT_NAME and ATTRCAT_NAME\n    // get the relation\'s open relation id using OpenRelTable::getRelId() method\n\n    // if relation is not open in open relation table, return E_RELNOTOPEN\n    // (check if the value returned from getRelationId function call = E_RELNOTOPEN)\n\n    // TODO: Update once BPlus Layer algorithms are completed\n    // BPlusTree bPlusTree = BPlusTree(relId, attrName);\n    // if(bPlusTree.blockNum == DISK_FULL)\n    // return DISK_FULL;\n}\n')),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"schema--dropindex"},"Schema :: dropIndex()"),(0,l.kt)("h4",{id:"description-3"},"Description"),(0,l.kt)("p",null,"This method drops the bplus indexing on an attribute attrName in a relation relName as specified in arguments."),(0,l.kt)("h4",{id:"arguments-3"},"Arguments"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"relName"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"char[ATTR_SIZE]")),(0,l.kt)("td",{parentName:"tr",align:null},"Name of the Relation.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"attrName"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"char [ATTR_SIZE]")),(0,l.kt)("td",{parentName:"tr",align:null},"Name of the Attribute.")))),(0,l.kt)("h4",{id:"return-value-3"},"Return value"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Value"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"SUCCESS")),(0,l.kt)("td",{parentName:"tr",align:null},"On successful deletion of the B+ tree")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"E_RELNOTOPEN")),(0,l.kt)("td",{parentName:"tr",align:null},"If the relation is not open.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"E_ATTRNOTEXIST")),(0,l.kt)("td",{parentName:"tr",align:null},"If the attribute with name attrName does not exist.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"E_NOTPERMITTED")),(0,l.kt)("td",{parentName:"tr",align:null},"If the relName is either ",(0,l.kt)("em",{parentName:"td"},'"RELATIONCAT"')," or ",(0,l.kt)("em",{parentName:"td"},'"ATTRIBUTECAT"'),".")))),(0,l.kt)("h4",{id:"algorithm-3"},"Algorithm"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},'int Schema::dropIndex(char *relName, char *attrName) {\n    // if the relation name is either Relation Catalog or Attribute Catalog, return E_NOTPERMITTED\n        // compare the input relName with "RELATIONCAT" and "ATTRIBUTECAT"\n        // OR use the following constants: RELCAT_NAME and ATTRCAT_NAME\n    // get the open relation id using appropriate method of OpenRelTable class by passing relation name as argument\n\n    // if relation is opened in open relation table, return E_RELOPEN\n\n    // ret = bplus_destroy(relid,attrName);\n    \n    // return ret\n}\n')),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"schema--renamerel"},"Schema :: renameRel()"),(0,l.kt)("h4",{id:"description-4"},"Description"),(0,l.kt)("p",null,"This method changes the relation name of specified relation to new name as specified in arguments."),(0,l.kt)("h4",{id:"arguments-4"},"Arguments"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"oldRelName"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"char[ATTR_SIZE]")),(0,l.kt)("td",{parentName:"tr",align:null},"Old Name of Relation to which name has to be changed.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"newRelName"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"char[ATTR_SIZE"),"]"),(0,l.kt)("td",{parentName:"tr",align:null},"New name for the Relation.")))),(0,l.kt)("h4",{id:"return-value-4"},"Return value"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Value"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"SUCCESS")),(0,l.kt)("td",{parentName:"tr",align:null},"On successful renaming of the relation")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"E_RELOPEN")),(0,l.kt)("td",{parentName:"tr",align:null},"If the relation is open.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"E_RELNOTEXIST")),(0,l.kt)("td",{parentName:"tr",align:null},"If the relation with name oldRelName does not exist")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"E_RELEXIST")),(0,l.kt)("td",{parentName:"tr",align:null},"If the relation with name newRelName already exists")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"E_NOTPERMITTED")),(0,l.kt)("td",{parentName:"tr",align:null},"If the oldrelName is either ",(0,l.kt)("em",{parentName:"td"},'"RELATIONCAT"')," or ",(0,l.kt)("em",{parentName:"td"},'"ATTRIBUTECAT"'),". i.e, when the user tries to rename either of the catalogs.")))),(0,l.kt)("h4",{id:"algorithm-4"},"Algorithm"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},'int renameRel(char oldRelName[ATTR_SIZE], char newRelName[ATTR_SIZE]) {\n    // if the oldRelName or newRelName is either Relation Catalog or Attribute Catalog, return E_NOTPERMITTED\n        // compare the input relName with "RELATIONCAT" and "ATTRIBUTECAT"\n        // OR use the following constants: RELCAT_NAME and ATTRCAT_NAME\n    // get the relation\'s open relation id using OpenRelTable::getRelId() method\n\n    // if relation is open in open relation table, return E_RELOPEN\n    // (check if the value returned from getRelId function call != E_RELNOTOPEN)\n\n    // retVal = BlockAccess::renameRelation(oldRelName, newRelName);\n    // return retVal\n}\n')),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"schema--renameattr"},"Schema :: renameAttr()"),(0,l.kt)("h4",{id:"description-5"},"Description"),(0,l.kt)("p",null,"This method changes the name of an attribute/column present in a specified relation, to new name as specified in arguments."),(0,l.kt)("h4",{id:"arguments-5"},"Arguments"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"relName"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"char[ATTR_SIZE]")),(0,l.kt)("td",{parentName:"tr",align:null},"Name of the Relation.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"oldAttrName"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"char[ATTR_SIZE]")),(0,l.kt)("td",{parentName:"tr",align:null},"Old Name of attribute.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"newAttrName"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"char[ATTR_SIZE]")),(0,l.kt)("td",{parentName:"tr",align:null},"New name for attribute.")))),(0,l.kt)("h4",{id:"return-value-5"},"Return value"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Value"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"SUCCESS")),(0,l.kt)("td",{parentName:"tr",align:null},"On successful renaming of the attribute")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"E_RELOPEN")),(0,l.kt)("td",{parentName:"tr",align:null},"If the relation is open.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"E_RELNOTEXIST")),(0,l.kt)("td",{parentName:"tr",align:null},"If the relation with name relName does not exist")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"E_ATTRNOTEXIST")),(0,l.kt)("td",{parentName:"tr",align:null},"If the attribute with name oldAttrName does not exist")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"E_ATTREXIST")),(0,l.kt)("td",{parentName:"tr",align:null},"If the attribute with name newAttrName already exists")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"E_NOTPERMITTED")),(0,l.kt)("td",{parentName:"tr",align:null},"If the relName is either ",(0,l.kt)("em",{parentName:"td"},'"RELATIONCAT"')," or ",(0,l.kt)("em",{parentName:"td"},'"ATTRIBUTECAT"'),". i.e, when the user tries to rename any attribute value of either of the catalogs.")))),(0,l.kt)("h4",{id:"algorithm-5"},"Algorithm"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},'int Schema::renameAttr(char *relName, char *oldAttrName, char *newAttrName) {\n    // if the relName is either Relation Catalog or Attribute Catalog, return E_NOTPERMITTED\n        // compare the input relName with "RELATIONCAT" and "ATTRIBUTECAT"\n        // OR use the following constants: RELCAT_NAME and ATTRCAT_NAME\n\n    // get the open relation id using appropriate method of OpenRelTable class by passing relation name as argument\n\n    // if relation is opened in open relation table, return E_RELOPEN\n\n    // Call renameAttribute method of Block Access Layer by passing appropriate arguments.\n\n    // return the value returned by the above renameAttribute() call\n}\n')),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"schema--openrel"},"Schema :: openRel()"),(0,l.kt)("h4",{id:"description-6"},"Description"),(0,l.kt)("p",null,"This method opens the relation specified as name in cache/OpenRelTable."),(0,l.kt)("h4",{id:"arguments-6"},"Arguments"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"relName"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"char[ATTR_SIZE]")),(0,l.kt)("td",{parentName:"tr",align:null},"Name of the Relation.")))),(0,l.kt)("h4",{id:"return-value-6"},"Return value"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Value"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"relId")),(0,l.kt)("td",{parentName:"tr",align:null},"Returns the relId on succesful opening of the relation")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"E_RELNOTEXIST")),(0,l.kt)("td",{parentName:"tr",align:null},"If the relation with name relName does not exist in the disk")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"E_CACHEFULL")),(0,l.kt)("td",{parentName:"tr",align:null},"If there are no free slots in the Open Relation table.")))),(0,l.kt)("h4",{id:"algorithm-6"},"Algorithm"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},"int Schema::openRel(char *relName) {\n    // Call openRelation method of OpenRelTable by passing appropriate arguments\n    int ret = OpenRelTable::openRel(relName);\n\n    // return the value returned by the above openRelation() call\n    return ret;\n}\n")),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"schema--closerel"},"Schema :: closeRel()"),(0,l.kt)("h4",{id:"description-7"},"Description"),(0,l.kt)("p",null,"This method closes the relation specified as name in cache/OpenRelTable."),(0,l.kt)("h4",{id:"arguments-7"},"Arguments"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"relName"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"char[ATTR_SIZE]")),(0,l.kt)("td",{parentName:"tr",align:null},"Name of the Relation.")))),(0,l.kt)("h4",{id:"return-value-7"},"Return value"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Value"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"SUCCESS")),(0,l.kt)("td",{parentName:"tr",align:null},"On successful closing of the relation")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"E_NOTOPEN")),(0,l.kt)("td",{parentName:"tr",align:null},"If relation with given name is not open")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"E_NOTPERMITTED")),(0,l.kt)("td",{parentName:"tr",align:null},"If the relName is either ",(0,l.kt)("em",{parentName:"td"},'"RELATIONCAT"')," or ",(0,l.kt)("em",{parentName:"td"},'"ATTRIBUTECAT"'),". i.e, when the user tries to close either of the catalogs.")))),(0,l.kt)("h4",{id:"algorithm-7"},"Algorithm"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},'int closeRel(char relName[ATTR_SIZE]) {\n    // check if relName is either "RELATIONCAT" or "ATTRIBUTECAT". If so then return E_NOTPERMITTED.\n\n    // get the relation\'s open relation id using OpenRelTable::getRelationId() method\n\n    // if relation is not open in open relation table, return E_RELNOTOPEN\n    // (check if the value returned from getRelationId function call = E_RELNOTOPEN)\n\n    // close the relId\'th relation using OpenRelTable::closeRelation(relId) of Cache Layer\n    // let the return value be retVal\n    // return retVal;\n}\n')),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"schema--getschema"},"Schema :: getSchema()"),(0,l.kt)("p",null,"YET TO BE DESIGNED"))}c.isMDXComponent=!0}}]);