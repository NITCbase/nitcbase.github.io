"use strict";(self.webpackChunknitcbase=self.webpackChunknitcbase||[]).push([[190],{3905:(t,e,n)=>{n.d(e,{Zo:()=>d,kt:()=>h});var a=n(7294);function r(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}function l(t,e){var n=Object.keys(t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(t);e&&(a=a.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),n.push.apply(n,a)}return n}function i(t){for(var e=1;e<arguments.length;e++){var n=null!=arguments[e]?arguments[e]:{};e%2?l(Object(n),!0).forEach((function(e){r(t,e,n[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(n,e))}))}return t}function o(t,e){if(null==t)return{};var n,a,r=function(t,e){if(null==t)return{};var n,a,r={},l=Object.keys(t);for(a=0;a<l.length;a++)n=l[a],e.indexOf(n)>=0||(r[n]=t[n]);return r}(t,e);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(t);for(a=0;a<l.length;a++)n=l[a],e.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(t,n)&&(r[n]=t[n])}return r}var s=a.createContext({}),c=function(t){var e=a.useContext(s),n=e;return t&&(n="function"==typeof t?t(e):i(i({},e),t)),n},d=function(t){var e=c(t.components);return a.createElement(s.Provider,{value:e},t.children)},p={inlineCode:"code",wrapper:function(t){var e=t.children;return a.createElement(a.Fragment,{},e)}},u=a.forwardRef((function(t,e){var n=t.components,r=t.mdxType,l=t.originalType,s=t.parentName,d=o(t,["components","mdxType","originalType","parentName"]),u=c(n),h=r,m=u["".concat(s,".").concat(h)]||u[h]||p[h]||l;return n?a.createElement(m,i(i({ref:e},d),{},{components:n})):a.createElement(m,i({ref:e},d))}));function h(t,e){var n=arguments,r=e&&e.mdxType;if("string"==typeof t||r){var l=n.length,i=new Array(l);i[0]=u;var o={};for(var s in e)hasOwnProperty.call(e,s)&&(o[s]=e[s]);o.originalType=t,o.mdxType="string"==typeof t?t:r,i[1]=o;for(var c=2;c<l;c++)i[c]=n[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},9469:(t,e,n)=>{n.r(e),n.d(e,{assets:()=>s,contentTitle:()=>i,default:()=>p,frontMatter:()=>l,metadata:()=>o,toc:()=>c});var a=n(7462),r=(n(7294),n(3905));const l={sidebar_position:3,title:"Algebra Layer"},i=void 0,o={unversionedId:"Design/Algebra Layer",id:"Design/Algebra Layer",title:"Algebra Layer",description:"The Schema Layer code is to be written in Algebra.cpp and it's header file Algebra.h",source:"@site/docs/Design/Algebra Layer.md",sourceDirName:"Design",slug:"/Design/Algebra Layer",permalink:"/docs/Design/Algebra Layer",draft:!1,tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3,title:"Algebra Layer"},sidebar:"Design",previous:{title:"Frontend Interface",permalink:"/docs/Design/Frontend"},next:{title:"Schema Layer",permalink:"/docs/Design/Schema Layer"}},s={},c=[{value:"Layout",id:"layout",level:2},{value:"class Algebra",id:"class-algebra",level:2},{value:"Insert",id:"insert",level:2},{value:"Description",id:"description",level:4},{value:"Arguments",id:"arguments",level:4},{value:"Return values",id:"return-values",level:4},{value:"Algorithm",id:"algorithm",level:4},{value:"Select",id:"select",level:2},{value:"Description",id:"description-1",level:4},{value:"Arguments",id:"arguments-1",level:4},{value:"Return values",id:"return-values-1",level:4},{value:"Algorithm",id:"algorithm-1",level:4},{value:"Project",id:"project",level:2},{value:"Project Specified Attributes",id:"project-specified-attributes",level:3},{value:"Description",id:"description-2",level:4},{value:"Arguments",id:"arguments-2",level:4},{value:"Return values",id:"return-values-2",level:4},{value:"Algorithm",id:"algorithm-2",level:4},{value:"Project All Attributes (Copy Relation)",id:"project-all-attributes-copy-relation",level:3},{value:"Description",id:"description-3",level:4},{value:"Arguments",id:"arguments-3",level:4},{value:"Return values",id:"return-values-3",level:4},{value:"Algorithm",id:"algorithm-3",level:4},{value:"Join",id:"join",level:2},{value:"Description",id:"description-4",level:4},{value:"Arguments",id:"arguments-4",level:4},{value:"Return values",id:"return-values-4",level:4},{value:"Algorithm",id:"algorithm-4",level:4},{value:"Miscellaneous",id:"miscellaneous",level:2},{value:"isNumber()",id:"isnumber",level:3},{value:"Description",id:"description-5",level:4},{value:"Arguments",id:"arguments-5",level:4},{value:"Return Values",id:"return-values-5",level:4}],d={toc:c};function p(t){let{components:e,...n}=t;return(0,r.kt)("wrapper",(0,a.Z)({},d,n,{components:e,mdxType:"MDXLayout"}),(0,r.kt)("admonition",{title:"note",type:"info"},(0,r.kt)("p",{parentName:"admonition"},"The Schema Layer code is to be written in ",(0,r.kt)("inlineCode",{parentName:"p"},"Algebra.cpp")," and it's header file ",(0,r.kt)("inlineCode",{parentName:"p"},"Algebra.h")),(0,r.kt)("p",{parentName:"admonition"},(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("a",{parentName:"strong",href:"/stub/algebra_stub"},"The stub code for these files can be found here.")))),(0,r.kt)("h2",{id:"layout"},"Layout"),(0,r.kt)("p",null,"The Front End parses SQL-Like queries and converts them into a sequence of algebra layer and schema layer method calls.\nThe algebra layer functions process the basic ",(0,r.kt)("strong",{parentName:"p"},"insert")," and ",(0,r.kt)("strong",{parentName:"p"},"retrieval")," requests ",(0,r.kt)("strong",{parentName:"p"},"to")," and ",(0,r.kt)("strong",{parentName:"p"},"from")," the database.\n",(0,r.kt)("em",{parentName:"p"},"Retrieval functions will create a ",(0,r.kt)("strong",{parentName:"em"},"target relation")," into which the retrieved data will be stored.")),(0,r.kt)("p",null,"The functions of the Algebra layer are:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("a",{parentName:"li",href:"#insert"},(0,r.kt)("strong",{parentName:"a"},"Insert"))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("a",{parentName:"li",href:"#project"},(0,r.kt)("strong",{parentName:"a"},"Project"))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("a",{parentName:"li",href:"#select"},(0,r.kt)("strong",{parentName:"a"},"Select"))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("a",{parentName:"li",href:"#join"},(0,r.kt)("strong",{parentName:"a"},"Join")))),(0,r.kt)("p",null,"NITCbase follows an Object-Oriented design for Algebra Layer. The class definition is as shown below:"),(0,r.kt)("h2",{id:"class-algebra"},"class Algebra"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"class Algebra {\npublic:\n    static int insert(char relName[ATTR_SIZE], int numberOfAttributes, char record[][ATTR_SIZE]);\n\n    static int select(char srcRel[ATTR_SIZE], char targetRel[ATTR_SIZE], char attr[ATTR_SIZE], int op, char strVal[ATTR_SIZE]);\n\n    static int project(char srcRel[ATTR_SIZE], char targetRel[ATTR_SIZE]); // project all(copy)\n\n    static int project(char srcRel[ATTR_SIZE], char targetRel[ATTR_SIZE], int tar_nAttrs, char tar_Attrs[][ATTR_SIZE]);\n\n    static int join(char srcRelOne[ATTR_SIZE], char srcRelTwo[ATTR_SIZE], char targetRel[ATTR_SIZE],\n                    char attrOne[ATTR_SIZE], char attrTwo[ATTR_SIZE]);\n};\n\n")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"insert"},"Insert"),(0,r.kt)("h4",{id:"description"},"Description"),(0,r.kt)("p",null,"This method ",(0,r.kt)("strong",{parentName:"p"},"inserts the given record")," into the specified Relation. Insertion is only done if the Relation is open and attribute number and types match."),(0,r.kt)("h4",{id:"arguments"},"Arguments"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Name")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Type")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Description")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"relName"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"char[ATTR_SIZE]")),(0,r.kt)("td",{parentName:"tr",align:null},"Name of the relation into which insert operation has to be performed.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"nAttrs"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"int")),(0,r.kt)("td",{parentName:"tr",align:null},"Number of attributes in the inserting record(which has to match with ",(0,r.kt)("inlineCode",{parentName:"td"},"numAttrs")," field in the relation cache entry for the relation)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"record"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"char[][ATTR_SIZE]")),(0,r.kt)("td",{parentName:"tr",align:null},"An array of strings with each string containing value of corresponding attribute.")))),(0,r.kt)("h4",{id:"return-values"},"Return values"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Value")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Description")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/constants"},(0,r.kt)("inlineCode",{parentName:"a"},"SUCCESS"))),(0,r.kt)("td",{parentName:"tr",align:null},"On successful insert of the given record into the relation")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/constants"},(0,r.kt)("inlineCode",{parentName:"a"},"E_RELNOTOPEN"))),(0,r.kt)("td",{parentName:"tr",align:null},"If the relation is not open.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/constants"},(0,r.kt)("inlineCode",{parentName:"a"},"E_NATTRMISMATCH"))),(0,r.kt)("td",{parentName:"tr",align:null},"If the actual number of attributes in the relation is different from the provided number of attributes")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/constants"},(0,r.kt)("inlineCode",{parentName:"a"},"E_ATTRTYPEMISMATCH"))),(0,r.kt)("td",{parentName:"tr",align:null},"If the actual type of the attribute in the relation is different from the type of provided attribute in the record.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/constants"},(0,r.kt)("inlineCode",{parentName:"a"},"E_DISKFULL"))),(0,r.kt)("td",{parentName:"tr",align:null},"If disk space is not sufficient for inserting the record / index")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/constants"},(0,r.kt)("inlineCode",{parentName:"a"},"E_NOTPERMITTED"))),(0,r.kt)("td",{parentName:"tr",align:null},"If relName is either ",(0,r.kt)("inlineCode",{parentName:"td"},"RELATIONCAT")," or ",(0,r.kt)("inlineCode",{parentName:"td"},"ATTRIBUTECAT"),". i.e, when the user tries to insert a record into any of the catalogs")))),(0,r.kt)("h4",{id:"algorithm"},"Algorithm"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'int Algebra::insert(char relName[ATTR_SIZE], int nAttrs, char record[][ATTR_SIZE]){\n    // if relName is equal to "RELATIONCAT" or "ATTRIBUTECAT"\n    // return E_NOTPERMITTED;\n\n    // get the relation\'s rel-id using OpenRelTable::getRelId() method\n    int relId = OpenRelTable::getRelId(relName);\n\n    // if relation is not open in open relation table, return E_RELNOTOPEN\n    // (check if the value returned from getRelId function call = E_RELNOTOPEN)\n    // get the relation catalog entry from relation cache\n    // (use RelCacheTable::getRelCatEntry() of Cache Layer)\n\n    /* if relCatEntry.numAttrs != numberOfAttributes in relation,\n       return E_NATTRMISMATCH */\n\n    // let recordValues[numberOfAttributes] be an array of type union Attribute\n\n    /*\n        Converting 2D char array of record values to Attribute array recordValues\n     */\n    // iterate through 0 to nAttrs-1: (let i be the iterator)\n    {\n        // get the attr-cat entry for the i\'th attribute from the attr-cache\n        // (use AttrCacheTable::getAttrCatEntry())\n\n        // let type = attrCatEntry.attrType;\n\n        if (type == NUMBER)\n        {\n            // if the char array record[i] can be converted to a number\n            // (check this using isNumber() function)\n            {\n                /* convert the char array to numeral and store it\n                   at recordValues[i].nVal using atof() */\n            }\n            // else\n            {\n                return E_ATTRTYPEMISMATCH;\n            }\n        }\n        else if (type == STRING)\n        {\n            // copy record[i] to recordValues[i].sVal\n        }\n    }\n\n    // insert the record by calling BlockAccess::insert() function\n    // let retVal denote the return value of insert call\n\n    return retVal;\n}\n')),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"select"},"Select"),(0,r.kt)("h4",{id:"description-1"},"Description"),(0,r.kt)("p",null,"This function creates a new target relation with attributes as that of source relation. It inserts the records of source relation which ",(0,r.kt)("strong",{parentName:"p"},"satisfies the given condition")," into the target Relation."),(0,r.kt)("h4",{id:"arguments-1"},"Arguments"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Name")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Type")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Description")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"srcRel"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"char[ATTR_SIZE]")),(0,r.kt)("td",{parentName:"tr",align:null},"Name of Source Relation.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"targetRel"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"char [ATTR_SIZE]")),(0,r.kt)("td",{parentName:"tr",align:null},"Name of the target Relation")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"attr"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"char [ATTR_SIZE]")),(0,r.kt)("td",{parentName:"tr",align:null},"Attribute/column name to which 'select' condition need to be checked with.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"op"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"int")),(0,r.kt)("td",{parentName:"tr",align:null},"The conditional operator (which can be one among ",(0,r.kt)("inlineCode",{parentName:"td"},"EQ"),", ",(0,r.kt)("inlineCode",{parentName:"td"},"LE"),", ",(0,r.kt)("inlineCode",{parentName:"td"},"LT"),", ",(0,r.kt)("inlineCode",{parentName:"td"},"GE"),", ",(0,r.kt)("inlineCode",{parentName:"td"},"GT"),", ",(0,r.kt)("inlineCode",{parentName:"td"},"NE")," corresponding to the following operators: ",(0,r.kt)("em",{parentName:"td"},"equal to, less than or equal to, less than, greater than or equal to, greater than, not equal to"),")")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"strVal"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"char [ATTR_SIZE]")),(0,r.kt)("td",{parentName:"tr",align:null},"value of attribute.")))),(0,r.kt)("h4",{id:"return-values-1"},"Return values"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Value")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Description")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/constants"},(0,r.kt)("inlineCode",{parentName:"a"},"SUCCESS"))),(0,r.kt)("td",{parentName:"tr",align:null},"On successful creation of new relation.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/constants"},(0,r.kt)("inlineCode",{parentName:"a"},"E_RELNOTOPEN"))),(0,r.kt)("td",{parentName:"tr",align:null},"If the source relation is not open.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/constants"},(0,r.kt)("inlineCode",{parentName:"a"},"E_RELEXIST"))),(0,r.kt)("td",{parentName:"tr",align:null},"If a relation with name ",(0,r.kt)("inlineCode",{parentName:"td"},"targetRel")," already exists.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/constants"},(0,r.kt)("inlineCode",{parentName:"a"},"E_ATTRNOTEXIST"))),(0,r.kt)("td",{parentName:"tr",align:null},"If a attribute with name ",(0,r.kt)("inlineCode",{parentName:"td"},"attr")," does not exist.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/constants"},(0,r.kt)("inlineCode",{parentName:"a"},"E_ATTRTYPEMISMATCH"))),(0,r.kt)("td",{parentName:"tr",align:null},"If the actual type of the attribute in the relation is different from the type of provided attribute.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/constants"},(0,r.kt)("inlineCode",{parentName:"a"},"E_CACHEFULL"))),(0,r.kt)("td",{parentName:"tr",align:null},"If target relation cannot be operated on due to lack of free slots in open relation table")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/constants"},(0,r.kt)("inlineCode",{parentName:"a"},"E_DISKFULL"))),(0,r.kt)("td",{parentName:"tr",align:null},"If disk space is not sufficient for creating the new relation.")))),(0,r.kt)("h4",{id:"algorithm-1"},"Algorithm"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"int Algebra::select(char srcRel[ATTR_SIZE], char targetRel[ATTR_SIZE], char attr[ATTR_SIZE], int op, char strVal[ATTR_SIZE]) {\n    // get the srcRel's rel-id(let it be srcRelid), using OpenRelTable::getRelId()\n    // if srcRel is not open in open relation table, return E_RELNOTOPEN\n\n    // get the attr-cat entry for attr, using AttrCacheTable::getAttrCatEntry()\n    // if getAttrcatEntry() call fails return E_ATTRNOTEXIST\n\n\n    /*** Convert strVal to an attribute of data type NUMBER or STRING ***/\n\n    Attribute attrVal;\n    int type = attrCatEntry.attrType;\n\n    if (type == NUMBER)\n    {\n        // if the char array record[i] can be converted to a number\n        // (check this using isNumber() function)\n        {\n            /* convert the char array to numeral and store it\n                at attrVal.nVal using atof() */\n        }\n        // else\n        {\n            return E_ATTRTYPEMISMATCH;\n        }\n    }\n    else if (type == STRING)\n    {\n        // copy record[i] to attrVal.sVal\n    }\n\n    /*** Creating and opening the target relation ***/\n    // Prepare arguments for createRel() in the following way:\n    // get RelcatEntry of srcRel using RelCacheTable::getRelCatEntry()\n    int src_nAttrs = /* the no. of attributes present in src relation */ ;\n\n\n    /* let attr_names[src_nAttrs][ATTR_SIZE] be a 2D array of type char\n        (will store the attribute names of rel). */\n    // let attr_types[src_nAttrs] be an array of type int\n\n    /*iterate through 0 to src_nAttrs-1 :\n        get the i'th attribute's AttrCatEntry using AttrCacheTable::getAttrCatEntry()\n        fill the attr_names, attr_types arrays that we declared with the entries\n        of corresponding attributes\n    */\n\n\n    /* Create the relation for target relation by calling Schema::createRel()\n       by providing appropriate arguments */\n    // if the createRel returns an error code, then return that value.\n\n    /* Open the newly created target relation by calling OpenRelTable::openRel()\n       method and store the target relid */\n    /* If opening fails, delete the target relation by calling Schema::deleteRel()\n       and return the error value returned from openRel() */\n\n    /*** Selecting and inserting records into the target relation ***/\n    /* Before calling the search function, reset the search to start from the\n       first using RelCacheTable::resetSearchIndex() */\n\n    Attribute record[src_nAttrs];\n\n    /*\n        The BlockAccess::search() function can either do a linearSearch or\n        a B+ tree search. Hence, reset the search index of the relation in the\n        relation cache using RelCacheTable::resetSearchIndex().\n        Also, reset the search index in the attribute cache for the select\n        condition attribute with name given by the argument `attr`. Use\n        AttrCacheTable::resetSearchIndex().\n        Both these calls are necessary to ensure that search begins from the\n        first record.\n    */\n    RelCacheTable::resetSearchIndex(/* fill arguments */);\n    AttrCacheTable::resetSearchIndex(/* fill arguments */);\n\n    // read every record that satisfies the condition by repeatedly calling\n    // BlockAccess::search() until there are no more records to be read\n\n    while (/* BlockAccess::search() returns success */) {\n\n        // ret = BlockAccess::insert(targetRelId, record);\n\n        // if (insert fails) {\n        //     close the targetrel(by calling Schema::closeRel(targetrel))\n        //     delete targetrel (by calling Schema::deleteRel(targetrel))\n        //     return ret;\n        // }\n    }\n\n    // Close the targetRel by calling closeRel() method of schema layer\n\n    // return SUCCESS.\n}\n")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"project"},"Project"),(0,r.kt)("h3",{id:"project-specified-attributes"},"Project Specified Attributes"),(0,r.kt)("h4",{id:"description-2"},"Description"),(0,r.kt)("p",null,"This function creates a new target relation with list of attributes specified in the arguments. For each record of the source relation, it inserts a new record into the target relation ",(0,r.kt)("strong",{parentName:"p"},"with the attribute values corresponding to the attributes specified in the attribute list.")),(0,r.kt)("h4",{id:"arguments-2"},"Arguments"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Name")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Type")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Description")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"srcRel"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"char[ATTR_SIZE]")),(0,r.kt)("td",{parentName:"tr",align:null},"Name of source relation.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"targetRel"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"char [ATTR_SIZE]")),(0,r.kt)("td",{parentName:"tr",align:null},"Name of the target relation(target relation is the Project of source relation)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"tar_nAttrs"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"int")),(0,r.kt)("td",{parentName:"tr",align:null},"Number of attributes that have to be projected from source relation to target relation.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"tar_attrs"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"char[][ATTR_SIZE]")),(0,r.kt)("td",{parentName:"tr",align:null},"Array of attribute names that have to be projected from source relation to target relation.")))),(0,r.kt)("h4",{id:"return-values-2"},"Return values"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Value")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Description")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/constants"},(0,r.kt)("inlineCode",{parentName:"a"},"SUCCESS"))),(0,r.kt)("td",{parentName:"tr",align:null},"On successful creation of new relation.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/constants"},(0,r.kt)("inlineCode",{parentName:"a"},"E_RELNOTOPEN"))),(0,r.kt)("td",{parentName:"tr",align:null},"If the source relation is not open.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/constants"},(0,r.kt)("inlineCode",{parentName:"a"},"E_RELEXIST"))),(0,r.kt)("td",{parentName:"tr",align:null},"If a relation with name ",(0,r.kt)("inlineCode",{parentName:"td"},"targetRel")," already exists.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/constants"},(0,r.kt)("inlineCode",{parentName:"a"},"E_ATTRNOTEXIST"))),(0,r.kt)("td",{parentName:"tr",align:null},"If any attribute with name given in attribute name array does not exist.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/constants"},(0,r.kt)("inlineCode",{parentName:"a"},"E_DISKFULL"))),(0,r.kt)("td",{parentName:"tr",align:null},"If disk space is not sufficient for creating the new relation.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/constants"},(0,r.kt)("inlineCode",{parentName:"a"},"E_CACHEFULL"))),(0,r.kt)("td",{parentName:"tr",align:null},"If target relation cannot be operated on due to lack of free slots in open relation table")))),(0,r.kt)("h4",{id:"algorithm-2"},"Algorithm"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"int Algebra::project(char srcRel[ATTR_SIZE], char targetRel[ATTR_SIZE], int tar_nAttrs, char tar_Attrs[][ATTR_SIZE]) {\n\n    int srcRelId = /*srcRel's rel-id (use OpenRelTable::getRelId() function)*/\n\n    // if srcRel is not open in open relation table, return E_RELNOTOPEN\n\n    // get RelCatEntry of srcRel using RelCacheTable::getRelCatEntry()\n\n    // get the no. of attributes present in relation from the fetched RelCatEntry.\n\n    // declare attr_offset[tar_nAttrs] an array of type int.\n    // where i-th entry will store the offset in a record of srcRel for the\n    // i-th attribute in the target relation.\n\n    // let attr_types[tar_nAttrs] be an array of type int.\n    // where i-th entry will store the type of the i-th attribute in the\n    // target relation.\n\n\n    /*** Checking if attributes of target are present in the source relation\n         and storing its offsets and types ***/\n\n    /*iterate through 0 to tar_nAttrs-1 :\n        - get the attribute catalog entry of the attribute with name tar_attrs[i].\n        - if the attribute is not found return E_ATTRNOTEXIST\n        - fill the attr_offset, attr_types arrays of target relation from the\n          corresponding attribute catalog entries of source relation\n    */\n\n\n    /*** Creating and opening the target relation ***/\n\n    // Create a relation for target relation by calling Schema::createRel()\n\n    // if the createRel returns an error code, then return that value.\n\n    // Open the newly created target relation by calling OpenRelTable::openRel()\n    // and get the target relid\n\n    // If opening fails, delete the target relation by calling Schema::deleteRel()\n    // and return the error value from openRel()\n\n\n    /*** Inserting projected records into the target relation ***/\n\n    // Take care to reset the searchIndex before calling the project function\n    // using RelCacheTable::resetSearchIndex()\n\n    Attribute record[src_nAttrs];\n\n    while (/* BlockAccess::project(srcRelId, record) returns SUCCESS */) {\n        // the variable `record` will contain the next record\n\n        Attribute proj_record[tar_nAttrs];\n\n        //iterate through 0 to tar_attrs-1:\n        //    proj_record[attr_iter] = record[attr_offset[attr_iter]]\n\n        // ret = BlockAccess::insert(targetRelId, proj_record);\n\n        if (/* insert fails */) {\n            // close the targetrel by calling Schema::closeRel()\n            // delete targetrel by calling Schema::deleteRel()\n            // return ret;\n        }\n    }\n\n    // Close the targetRel by calling Schema::closeRel()\n\n    // return SUCCESS.\n}\n")),(0,r.kt)("h3",{id:"project-all-attributes-copy-relation"},"Project All Attributes (Copy Relation)"),(0,r.kt)("h4",{id:"description-3"},"Description"),(0,r.kt)("p",null,"This function creates a copy of the source relation in the target relation. ",(0,r.kt)("strong",{parentName:"p"},"Every record")," of the source relation is inserted into the target relation."),(0,r.kt)("h4",{id:"arguments-3"},"Arguments"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Name")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Type")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Description")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"srcRel"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"char[ATTR_SIZE]")),(0,r.kt)("td",{parentName:"tr",align:null},"Name of source relation.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"targetRel"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"char [ATTR_SIZE]")),(0,r.kt)("td",{parentName:"tr",align:null},"Name of the target relation (target relation is the Project of source relation)")))),(0,r.kt)("h4",{id:"return-values-3"},"Return values"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Value")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Description")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/constants"},(0,r.kt)("inlineCode",{parentName:"a"},"SUCCESS"))),(0,r.kt)("td",{parentName:"tr",align:null},"On successful creation of new relation.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/constants"},(0,r.kt)("inlineCode",{parentName:"a"},"E_RELNOTOPEN"))),(0,r.kt)("td",{parentName:"tr",align:null},"If the source relation is not open.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/constants"},(0,r.kt)("inlineCode",{parentName:"a"},"E_RELEXIST"))),(0,r.kt)("td",{parentName:"tr",align:null},"If a relation with name ",(0,r.kt)("inlineCode",{parentName:"td"},"targetRel")," already exists.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/constants"},(0,r.kt)("inlineCode",{parentName:"a"},"E_DISKFULL"))),(0,r.kt)("td",{parentName:"tr",align:null},"If disk space is not sufficient for creating the new relation.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/constants"},(0,r.kt)("inlineCode",{parentName:"a"},"E_CACHEFULL"))),(0,r.kt)("td",{parentName:"tr",align:null},"If target relation cannot be operated on due to lack of free slots in open relation table")))),(0,r.kt)("h4",{id:"algorithm-3"},"Algorithm"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"int Algebra::project(char srcRel[ATTR_SIZE], char targetRel[ATTR_SIZE], int tar_nAttrs, char tar_Attrs[][ATTR_SIZE]) {\n\n    int srcRelId = /*srcRel's rel-id (use OpenRelTable::getRelId() function)*/\n\n    // if srcRel is not open in open relation table, return E_RELNOTOPEN\n\n    // get RelCatEntry of srcRel using RelCacheTable::getRelCatEntry()\n\n    // get the no. of attributes present in relation from the fetched RelCatEntry.\n\n    // attrNames and attrTypes will be used to store the attribute names\n    // and types of the source relation respectively\n    char attrNames[numAttrs][ATTR_SIZE];\n    int attrTypes[numAttrs];\n\n    /*iterate through every attribute of the source relation :\n        - get the AttributeCat entry of the attribute with offset.\n          (using AttrCacheTable::getAttrCatEntry())\n        - fill the arrays `attrNames` and `attrTypes` that we declared earlier\n          with the data about each attribute\n    */\n\n\n    /*** Creating and opening the target relation ***/\n\n    // Create a relation for target relation by calling Schema::createRel()\n\n    // if the createRel returns an error code, then return that value.\n\n    // Open the newly created target relation by calling OpenRelTable::openRel()\n    // and get the target relid\n\n    // If opening fails, delete the target relation by calling Schema::deleteRel() of\n    // return the error value returned from openRel().\n\n\n    /*** Inserting projected records into the target relation ***/\n\n    // Take care to reset the searchIndex before calling the project function\n    // using RelCacheTable::resetSearchIndex()\n\n    Attribute record[numAttrs];\n\n\n    while (/* BlockAccess::project(srcRelId, record) returns SUCCESS */)\n    {\n        // record will contain the next record\n\n        // ret = BlockAccess::insert(targetRelId, proj_record);\n\n        if (/* insert fails */) {\n            // close the targetrel by calling Schema::closeRel()\n            // delete targetrel by calling Schema::deleteRel()\n            // return ret;\n        }\n    }\n\n    // Close the targetRel by calling Schema::closeRel()\n\n    // return SUCCESS.\n}\n")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"join"},"Join"),(0,r.kt)("h4",{id:"description-4"},"Description"),(0,r.kt)("p",null,"This function creates a new target relation with ",(0,r.kt)("em",{parentName:"p"},"attributes constituting from both the source relations (excluding the specified join-attribute from the second source relation)"),". It inserts the records obtained by ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"Equi-join"))," of both the source relations into the target relation. An attribute from each relation specified in arguments is used for ",(0,r.kt)("em",{parentName:"p"},"equi-join called the join-attributes.")),(0,r.kt)("admonition",{title:"NOTE",type:"info"},(0,r.kt)("p",{parentName:"admonition"},"The resulting relation will have columns ordered such that all the columns of ",(0,r.kt)("inlineCode",{parentName:"p"},"srcRelOne")," come first followed by the columns of ",(0,r.kt)("inlineCode",{parentName:"p"},"srcRelTwo")," excluding the join attribute ",(0,r.kt)("inlineCode",{parentName:"p"},"attrTwo"),"."),(0,r.kt)("p",{parentName:"admonition"},"An example for the join operation can be seen ",(0,r.kt)("a",{parentName:"p",href:"/docs/User%20Interface%20Commands/dml#select--from-join-where"},"here"),".")),(0,r.kt)("h4",{id:"arguments-4"},"Arguments"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Name")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Type")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Description")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"srcRelOne"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"char[ATTR_SIZE]")),(0,r.kt)("td",{parentName:"tr",align:null},"Name of 1st Source Relation.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"srcRelTwo"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"char[ATTR_SIZE]")),(0,r.kt)("td",{parentName:"tr",align:null},"Name of 2nd Source Relation.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"targetRel"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"char [ATTR_SIZE]")),(0,r.kt)("td",{parentName:"tr",align:null},"Name of the target Relation")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"attrOne"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"char [ATTR_SIZE]")),(0,r.kt)("td",{parentName:"tr",align:null},"Attribute/column name in srcrel1.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"attrTwo"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"char [ATTR_SIZE]")),(0,r.kt)("td",{parentName:"tr",align:null},"Attribute/column name in srcrel2.")))),(0,r.kt)("h4",{id:"return-values-4"},"Return values"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Value")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Description")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/constants"},(0,r.kt)("inlineCode",{parentName:"a"},"SUCCESS"))),(0,r.kt)("td",{parentName:"tr",align:null},"On successful creation of new relation.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/constants"},(0,r.kt)("inlineCode",{parentName:"a"},"E_RELNOTOPEN"))),(0,r.kt)("td",{parentName:"tr",align:null},"If any of the source relations is not open.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/constants"},(0,r.kt)("inlineCode",{parentName:"a"},"E_RELEXIST"))),(0,r.kt)("td",{parentName:"tr",align:null},"If a relation with name ",(0,r.kt)("inlineCode",{parentName:"td"},"targetRel")," already exists.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/constants"},(0,r.kt)("inlineCode",{parentName:"a"},"E_ATTRNOTEXIST"))),(0,r.kt)("td",{parentName:"tr",align:null},"If an attribute with name attr1 in srcrel1 or attr2 in srcrel2 does not exist.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/constants"},(0,r.kt)("inlineCode",{parentName:"a"},"E_DISKFULL"))),(0,r.kt)("td",{parentName:"tr",align:null},"If disk space is not sufficient for creating the new relation.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/constants"},(0,r.kt)("inlineCode",{parentName:"a"},"E_ATTRTYPEMISMATCH"))),(0,r.kt)("td",{parentName:"tr",align:null},"If the actual type of any of the attributes in the source relations is different from the type of provided attribute.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/constants"},(0,r.kt)("inlineCode",{parentName:"a"},"E_DUPLICATEATTR"))),(0,r.kt)("td",{parentName:"tr",align:null},"If there are duplicate attribute names between srcrel1 and srcrel2 aside from the join attributes.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/constants"},(0,r.kt)("inlineCode",{parentName:"a"},"E_CACHEFULL"))),(0,r.kt)("td",{parentName:"tr",align:null},"If target relation cannot be operated on due to lack of free slots in open relation table")))),(0,r.kt)("h4",{id:"algorithm-4"},"Algorithm"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"int join(char srcRelation1[ATTR_SIZE], char srcRelation2[ATTR_SIZE], char targetRelation[ATTR_SIZE], char attribute1[ATTR_SIZE], char attribute2[ATTR_SIZE]) {\n\n    // get the srcRelation1's open relation id using OpenRelTable::getRelId() method\n\n    // get the srcRelation2's open relation id using OpenRelTable::getRelId() method\n\n    // if either of the two source relations is not open in open relation table, return E_RELNOTOPEN\n    // (check if the value returned from getRelId function call = E_RELNOTOPEN)\n\n    // get the attribute catalog entries for the following from the attribute cache\n    // - attribute1 of srcRelation1 (call AttrCacheTable::getAttrCatEntry() function with arguments srcRel1Id and attribute1)\n    // - attribute2 of srcRelation2 (call AttrCacheTable::getAttrCatEntry() function with arguments srcRel2Id and attribute2)\n    // Let retVal1 & retVal2 denote the return values of the above function calls respectively\n\n    // if attribute1 is not present in srcRelation1 or attribute2 is not present in srcRelation2\n    // (check using return values retVal1, retVal2)\n    // return E_ATTRNOTEXIST.\n\n    // if attribute1 and attribute2 are of different types return E_ATTRTYPEMISMATCH\n\n    // get the relation catalog entries for the relations from the relation cache\n    // (use RelCacheTable::getRelCatEntry() function)\n\n    // let numOfAttributes1, numOfAttributes2 be the number of attributes in srcRelation1 and srcRelation2 respectively\n    // (note: the number of attributes field is present in relation catalog entry)\n\n    // if rel2 does not have an index on attr2\n    //   create it using BPlusTree:bPlusCreate()\n    //   if call fails, return the appropriate error code\n    //   (if your implementation is correct, the only error code that will\n    //    be returned here is E_DISKFULL)\n\n    // let numOfAttributesInTarget = numOfAttributes1 + numOfAttributes2 - 1\n    // let targetRelAttrNames[numOfAttributesInTarget][ATTR_SIZE] be an array of type char\n    // let targetRelAttrTypes[numOfAttributesInTarget] be an array of type int\n    // Note: The target relation has number of attributes one less than nAttrs1+nAttrs2 (Why?)\n\n    /*\n        iterate through all the attributes in both the source relations and\n        update targetRelAttrNames[],targetRelAttrTypes[] arrays (except for attribute2 in srcRelation2),\n        by getting attribute catalog of each attribute from attribute cache\n        (using method AttrCacheTable::getAttrCatEntry() of Cache Layer)\n        Also check if there are any other pair attributes other than join attributes(i.e. attribute1 and attribute2)\n        with the same name in srcRelation1 and srcRelation2.\n        If yes, return error code E_DUPLICATEATTR (as this will lead to duplicate attribute names\n        in the target relation)\n    */\n\n    // retVal = Schema::createRel(targetRelation, numOfAttributesInTarget, targetRelAttrNames , targetRelAttrTypes);\n\n    // if create fails return retVal\n\n    // Open the targetRelation in OpenRelTable using OpenRelTable::openRel() function\n\n    // if openRel() fails (No free entries left in the Open Relation Table)\n    {\n        // delete target relation by calling deleteRel(targetRelation) of schema layer\n        // return error value targetRelId\n    }\n\n    Attribute record1[numOfAttributes1];\n    Attribute record2[numOfAttributes2];\n    Attribute targetRecord[numOfAttributesInTarget];\n\n    // this loop is to get every record of the srcRelation1 one by one\n    while (BlockAccess::project(srcRelId1, record1) == SUCCESS) {\n\n        // reset the search index of `srcRelation2` in the relation cache\n        // using RelCacheTable::resetSearchIndex()\n\n        // reset the search index of `attribute2` in the attribute cache\n        // using AttrCacheTable::resetSearchIndex()\n\n        // this loop is to get every record of the srcRelation2 which satisfies the following condition:\n        // record1.attribute1 = record2.attribute2 (i.e. Equi-Join condition)\n        while (BlockAccess::search(srcRelId2, record2, attribute2, record1[attrCatEntry1.offset], EQ) == SUCCESS) {\n\n            // copy srcRelation1's and srcRelation2's attribute values(except for attribute2 in rel2) from\n            // record1 and record2 to targetRecord\n            // (iterate offset from 0 to numOfAttributes1-1 in record1 and 0 to numOfAttributes2-1 in record2\n\n            // insert the current record into the target relation by calling BlockAccess::insert()\n\n            // if insert fails (insert should fail only due to DISK being FULL)\n            {\n                // close the target relation by calling OpenRelTable::closeRel() of Cache layer\n                // delete targetRelation (by calling Schema::deleteRel() of Schema layer)\n                return E_DISKFULL;\n            }\n        }\n    }\n\n    // close the target relation by calling OpenRelTable::closeRel() of Cache layer\n    // return SUCCESS;\n}\n")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"miscellaneous"},"Miscellaneous"),(0,r.kt)("p",null,"Given below are the definitions of two functions which have been used in this layer for validation of various inputs."),(0,r.kt)("h3",{id:"isnumber"},"isNumber()"),(0,r.kt)("h4",{id:"description-5"},"Description"),(0,r.kt)("p",null,"This function takes a string and checks whether it can be parsed as a floating point number. Leading and trailing whitespace is ignored. It can be used to validate if a given input corresponds to the ",(0,r.kt)("inlineCode",{parentName:"p"},"NUMBER")," type."),(0,r.kt)("h4",{id:"arguments-5"},"Arguments"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Name")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Type")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Description")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"str"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"char[ATTR_SIZE]")),(0,r.kt)("td",{parentName:"tr",align:null},"The string to be checked")))),(0,r.kt)("h4",{id:"return-values-5"},"Return Values"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Value")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Description")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"true"),(0,r.kt)("td",{parentName:"tr",align:null},"Value in ",(0,r.kt)("inlineCode",{parentName:"td"},"str")," is parse-able as a ",(0,r.kt)("inlineCode",{parentName:"td"},"NUMBER"),".")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"false"),(0,r.kt)("td",{parentName:"tr",align:null},"Value in ",(0,r.kt)("inlineCode",{parentName:"td"},"str")," is not parse-able as a ",(0,r.kt)("inlineCode",{parentName:"td"},"NUMBER"),".")))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"bool isNumber(char *str) {\n    int len;\n    float ignore;\n    /*\n        sscanf returns the number of elements read, so if there is no float matching\n        the first %f, ret will be 0, else it'll be 1\n\n        %n gets the number of characters read. this scanf sequence will read the\n        first float ignoring all the whitespace before and after. and the number of\n        characters read that far will be stored in len. if len == strlen(str), then\n        the string only contains a float with/without whitespace. else, there's other\n        characters.\n    */\n    int ret = sscanf(str, \"%f %n\", &ignore, &len);\n    return ret == 1 && len == strlen(str);\n}\n")))}p.isMDXComponent=!0}}]);