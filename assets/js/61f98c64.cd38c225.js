"use strict";(self.webpackChunknitcbase=self.webpackChunknitcbase||[]).push([[5338],{3905:(e,t,a)=>{a.d(t,{Zo:()=>m,kt:()=>d});var n=a(7294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function l(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var c=n.createContext({}),s=function(e){var t=n.useContext(c),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},m=function(e){var t=s(e.components);return n.createElement(c.Provider,{value:t},e.children)},f={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},u=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,i=e.originalType,c=e.parentName,m=l(e,["components","mdxType","originalType","parentName"]),u=s(a),d=r,p=u["".concat(c,".").concat(d)]||u[d]||f[d]||i;return a?n.createElement(p,o(o({ref:t},m),{},{components:a})):n.createElement(p,o({ref:t},m))}));function d(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=a.length,o=new Array(i);o[0]=u;var l={};for(var c in t)hasOwnProperty.call(t,c)&&(l[c]=t[c]);l.originalType=e,l.mdxType="string"==typeof e?e:r,o[1]=l;for(var s=2;s<i;s++)o[s]=a[s];return n.createElement.apply(null,o)}return n.createElement.apply(null,a)}u.displayName="MDXCreateElement"},6635:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>c,contentTitle:()=>o,default:()=>f,frontMatter:()=>i,metadata:()=>l,toc:()=>s});var n=a(7462),r=(a(7294),a(3905));const i={title:"Stage 6 : Buffer Management and Disk Write-back"},o="Stage 6 : Buffer Management and Disk Write-back (10 hours)",l={unversionedId:"Roadmap/Stage06",id:"Roadmap/Stage06",title:"Stage 6 : Buffer Management and Disk Write-back",description:"- Implement the commands to rename relations and attributes",source:"@site/docs/Roadmap/Stage06.md",sourceDirName:"Roadmap",slug:"/Roadmap/Stage06",permalink:"/docs/Roadmap/Stage06",draft:!1,tags:[],version:"current",frontMatter:{title:"Stage 6 : Buffer Management and Disk Write-back"},sidebar:"Roadmap",previous:{title:"Stage 5 : Opening Relations",permalink:"/docs/Roadmap/Stage05"},next:{title:"Stage 7 : Inserting Records Into Relations",permalink:"/docs/Roadmap/Stage07"}},c={},s=[{value:"Introduction",id:"introduction",level:2},{value:"Block Replacement",id:"block-replacement",level:3},{value:"Implementation",id:"implementation",level:2},{value:"Exercises",id:"exercises",level:2}],m={toc:s};function f(e){let{components:t,...a}=e;return(0,r.kt)("wrapper",(0,n.Z)({},m,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"stage-6--buffer-management-and-disk-write-back-10-hours"},"Stage 6 : Buffer Management and Disk Write-back (10 hours)"),(0,r.kt)("admonition",{title:"Learning Objectives",type:"note"},(0,r.kt)("ul",{parentName:"admonition"},(0,r.kt)("li",{parentName:"ul"},"Implement the commands to rename relations and attributes"),(0,r.kt)("li",{parentName:"ul"},"Implement the LRU algorithm to free up space in the buffer by writing back to the disk when the buffer becomes fully occupied"))),(0,r.kt)("admonition",{title:"PREREQUISITE READING",type:"tip"},(0,r.kt)("ul",{parentName:"admonition"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/docs/User%20Interface%20Commands/ddl"},"Data Definition Language (DDL) Commands")))),(0,r.kt)("h2",{id:"introduction"},"Introduction"),(0,r.kt)("p",null,"This far, we've covered a lot of the functionality of NITCbase involving reading from the disk. You've implemented a read-only buffer and a cache for the catalog entries. In this stage, we will discuss operations involving writing back to the disk. You will implement the ",(0,r.kt)("a",{parentName:"p",href:"/docs/User%20Interface%20Commands/ddl#alter-table-rename"},"ALTER TABLE RENAME")," and ",(0,r.kt)("a",{parentName:"p",href:"/docs/User%20Interface%20Commands/ddl#alter-table-rename-column"},"ALTER TABLE RENAME COLUMN")," commands which are used to rename a relation and it's attributes respectively."),(0,r.kt)("h3",{id:"block-replacement"},"Block Replacement"),(0,r.kt)("p",null,"In our implementation so far, every time we want to access a block, we load it into a buffer and then do all our read operations from that. Recall that in the ",(0,r.kt)("a",{parentName:"p",href:"/docs/Design/Buffer%20Layer"},"Buffer Layer"),", ",(0,r.kt)("a",{parentName:"p",href:"/docs/Design/Buffer%20Layer#class-staticbuffer"},"StaticBuffer")," allows us to buffer ",(0,r.kt)("inlineCode",{parentName:"p"},"BUFFER_CAPACITY"),"(=32) blocks at any given time. What if we want to read from a new block? We will obviously have to reuse an existing slot to load in our new block."),(0,r.kt)("p",null,"NITCbase uses the ",(0,r.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Cache_replacement_policies#Least_recently_used_(LRU)"},"LRU(least recently used) algorithm")," to decide on the block that will be replaced. Each entry in the buffer has a corresponding ",(0,r.kt)("a",{parentName:"p",href:"/docs/Design/Buffer%20Layer#buffer-structure"},(0,r.kt)("inlineCode",{parentName:"a"},"timestamp")," field")," which keeps track of how long it has been since the disk block buffered in that particular location has been used. When a position needs to be freed up, the disk block with the highest timestamp is chosen and changes, if any, are written back to the disk."),(0,r.kt)("p",null,"Each entry in the buffer also has a corresponding ",(0,r.kt)("a",{parentName:"p",href:"/docs/Design/Buffer%20Layer#buffer-structure"},(0,r.kt)("inlineCode",{parentName:"a"},"dirty")," field")," which is a boolean value storing if the values in that buffer entry have been updated since they were loaded from the disk block. If the dirty bit is set for an entry, we will write it back to the disk when the entry is replaced in the buffer or at system exit."),(0,r.kt)("h2",{id:"implementation"},"Implementation"),(0,r.kt)("p",null,"The ",(0,r.kt)("a",{parentName:"p",href:"/docs/User%20Interface%20Commands/ddl#alter-table-rename"},"ALTER TABLE RENAME")," and ",(0,r.kt)("a",{parentName:"p",href:"/docs/User%20Interface%20Commands/ddl#alter-table-rename-column"},"ALTER TABLE RENAME COLUMN")," commands modify the schema of a relation and are hence handled by the ",(0,r.kt)("a",{parentName:"p",href:"/docs/Design/Schema%20Layer"},"Schema Layer"),". NITCbase requires that a relation be closed before its schema can be edited. To update a relation name or attribute name, we will need to update the corresponding entries in the relation and/or attribute catalog blocks. These changes will subsequently be written back to the disk from the disk buffer."),(0,r.kt)("p",null,"A sequence diagram showing the call sequence involved in the implementation of this functionality is shown below."),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},(0,r.kt)("strong",{parentName:"p"},"NOTE"),": The functions are denoted with circles as follows.",(0,r.kt)("br",null),"\n\ud83d\udd35 -> methods that are already in their final state",(0,r.kt)("br",null),"\n\ud83d\udfe2 -> methods that will attain their final state in this stage",(0,r.kt)("br",null),"\n\ud83d\udfe0 -> methods that we will modify in this stage, and in subsequent stages")),(0,r.kt)("mermaid",{value:" %%{init: { 'sequence': {'mirrorActors':false} } }%%\nsequenceDiagram\n  actor User\n  participant Frontend User Interface\n  participant Frontend Programming Interface\n  participant Schema Layer\n  participant Block Access Layer\n  participant Buffer Layer\n  User->>Frontend User Interface: ALTER TABLE RENAME\n  activate Frontend User Interface\n  Frontend User Interface->>Frontend Programming Interface :alter_table_rename()\ud83d\udfe2\n  activate Frontend Programming Interface\n  Frontend Programming Interface->>Schema Layer:renameRel()\ud83d\udfe2\n  activate Schema Layer\n  Schema Layer->>Block Access Layer:renameRelation()\ud83d\udfe2\n  activate Block Access Layer\n  Note over Block Access Layer, Block Access Layer: find relation catalog entry\n  Block Access Layer ->> Buffer Layer: setRecord()\ud83d\udfe2\n  activate Buffer Layer\n  Buffer Layer--\x3e>Block Access Layer:operation status\n  deactivate Buffer Layer\n  loop for all attribute catalog entries of the relation\n    Note over Block Access Layer, Block Access Layer: find attribute catalog entry\n    Block Access Layer ->> Buffer Layer: setRecord()\ud83d\udfe2\n    activate Buffer Layer\n    Buffer Layer--\x3e>Block Access Layer:operation status\n    deactivate Buffer Layer\n  end\n  Block Access Layer--\x3e>User:operation status\n  deactivate Block Access Layer\n  deactivate Schema Layer\n  deactivate Frontend Programming Interface\n  deactivate Frontend User Interface\n"}),(0,r.kt)("br",null),(0,r.kt)("p",null,"A class diagram showing the methods relevant to this functionality in the ",(0,r.kt)("a",{parentName:"p",href:"/docs/Design/Schema%20Layer"},"Schema Layer"),", ",(0,r.kt)("a",{parentName:"p",href:"/docs/Design/Block%20Access%20Layer"},"Block Access Layer")," and ",(0,r.kt)("a",{parentName:"p",href:"/docs/Design/Buffer%20Layer"},"Buffer Layer")," is shown below."),(0,r.kt)("mermaid",{value:"classDiagram\n  class Schema{\n    +openRel(char relName[ATTR_SIZE])$ int\ud83d\udd35\n    +closeRel(char relName[ATTR_SIZE])$ int\ud83d\udd35\n    +renameRel(char oldRelName[ATTR_SIZE], char newRelName[ATTR_SIZE])$ int\ud83d\udfe2\n    +renameAttr(char relName[ATTR_SIZE], char oldAttrName[ATTR_SIZE], char newAttrName[ATTR_SIZE])$ int\ud83d\udfe2\n  }"}),(0,r.kt)("mermaid",{value:"classDiagram\n  class BlockAccess{\n    +linearSearch(int relId, char attrName[ATTR_SIZE], Attribute attrVal, int op)$ RecId\ud83d\udd35\n    +renameRelation(char oldName[ATTR_SIZE], char newName[ATTR_SIZE])$ int\ud83d\udfe2\n    +renameAttribute(char relName[ATTR_SIZE], char oldName[ATTR_SIZE], char newName[ATTR_SIZE])$ int\ud83d\udfe2\n  }"}),(0,r.kt)("hr",null),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Buffer Layer")),(0,r.kt)("mermaid",{value:"classDiagram\n  direction LR\n  BlockBuffer <|-- RecBuffer\n  StaticBuffer<|..RecBuffer : uses\n  StaticBuffer<|..BlockBuffer : uses\n  class RecBuffer{\n    +RecBuffer(int blockNum) \ud83d\udd35\n    +getRecord(union Attribute *rec, int slotNum) int\ud83d\udd35\n    +getSlotMap(unsigned char *slotMap) int\ud83d\udd35\n    +setRecord(union Attribute *rec, int slotNum) int\ud83d\udfe2\n  }\n  class BlockBuffer{\n    #blockNum: int\n    +BlockBuffer(int blockNum) \ud83d\udd35\n    +getHeader(struct HeadInfo *head) int\ud83d\udd35\n    #loadBlockAndGetBufferPtr(unsigned char **buffPtr) int\ud83d\udfe2\n  }\n  class StaticBuffer{\n    -blocks[BUFFER_CAPACITY][BLOCK_SIZE]: unsigned char\n    -metainfo[BUFFER_CAPACITY]: struct BufferMetaInfo\n    +StaticBuffer() \ud83d\udfe0\n    +~StaticBuffer() \ud83d\udfe0\n    -getFreeBuffer(int blockNum)$ int\ud83d\udfe2\n    -getBufferNum(int blockNum)$ int\ud83d\udd35\n    +setDirtyBit(int blockNum)$ int\ud83d\udfe2\n  }"}),(0,r.kt)("br",null),(0,r.kt)("p",null,"As shown in the sequence diagram above, the Frontend User Interface will parse the ",(0,r.kt)("inlineCode",{parentName:"p"},"ALTER TABLE RENAME")," command and call the ",(0,r.kt)("inlineCode",{parentName:"p"},"Frontend::alter_table_rename()")," function in the Frontend Programming Interface. This call is then transferred along to the ",(0,r.kt)("a",{parentName:"p",href:"/docs/Design/Schema%20Layer"},"Schema Layer"),". Hence, the implementation of the ",(0,r.kt)("inlineCode",{parentName:"p"},"Frontend::alter_table_rename()")," function only involves a call to the ",(0,r.kt)("inlineCode",{parentName:"p"},"Schema::renameRel()")," function. Similarly, the ",(0,r.kt)("inlineCode",{parentName:"p"},"ALTER TABLE RENAME COLUMN")," command leads to the ",(0,r.kt)("inlineCode",{parentName:"p"},"Frontend::alter_table_rename_column()")," function which in turn transfers control to ",(0,r.kt)("inlineCode",{parentName:"p"},"Schema::renameAttr()"),"."),(0,r.kt)("details",null,(0,r.kt)("summary",null,"Frontend/Frontend.cpp"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"int Frontend::alter_table_rename(char relname_from[ATTR_SIZE], char relname_to[ATTR_SIZE]) {\n  return Schema::renameRel(relname_from, relname_to);\n}\n\nint Frontend::alter_table_rename_column(char relname[ATTR_SIZE], char attrname_from[ATTR_SIZE],\n                                        char attrname_to[ATTR_SIZE]) {\n  return Schema::renameAttr(relname, attrname_from, attrname_to);\n}\n"))),(0,r.kt)("p",null,"Now, let us implement the functions in the ",(0,r.kt)("a",{parentName:"p",href:"/docs/Design/Schema%20Layer"},"Schema Layer")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"Schema::renameRel()")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Schema::renameAttr()")," functions ensure that the relation is closed and the input is for a valid operation. Subsequently, they call the respective ",(0,r.kt)("a",{parentName:"p",href:"/docs/Design/Block%20Access%20Layer"},"Block Access Layer")," functions ",(0,r.kt)("inlineCode",{parentName:"p"},"BlockAccess::renameRelation()")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"BlockAccess::renameAttribute()"),"."),(0,r.kt)("details",null,(0,r.kt)("summary",null,"Schema/Schema.cpp"),(0,r.kt)("p",null,"Implement the following functions looking at their respective design docs"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/docs/Design/Schema%20Layer#schema--renamerel"},(0,r.kt)("inlineCode",{parentName:"a"},"Schema::renameRel()"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/docs/Design/Schema%20Layer#schema--renameattr"},(0,r.kt)("inlineCode",{parentName:"a"},"Schema::renameAttr()"))))),(0,r.kt)("p",null,"The ",(0,r.kt)("a",{parentName:"p",href:"/docs/Design/Block%20Access%20Layer"},"Block Access Layer")," functions will then call ",(0,r.kt)("inlineCode",{parentName:"p"},"linearSearch()")," to iterate through the relation and attribute catalog blocks and find the entries corresponding to the required relation. It then uses ",(0,r.kt)("inlineCode",{parentName:"p"},"RecBuffer::getRecord()")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"RecBuffer::setRecord()")," to fetch the existing record value, update the name and then write the updated record back into the disk block. (The implementation of the ",(0,r.kt)("inlineCode",{parentName:"p"},"RecBuffer::setRecord()")," function will be described later in this stage.)"),(0,r.kt)("details",null,(0,r.kt)("summary",null,"BlockAccess/BlockAccess.cpp"),(0,r.kt)("p",null,"Implement the following functions looking at their respective design docs"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/docs/Design/Block%20Access%20Layer#blockaccess--renamerelation"},(0,r.kt)("inlineCode",{parentName:"a"},"BlockAccess::renameRelation()"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/docs/Design/Block%20Access%20Layer#blockaccess--renameattribute"},(0,r.kt)("inlineCode",{parentName:"a"},"BlockAccess::renameAttribute()"))))),(0,r.kt)("p",null,"Now, the only functionality we have left to implement is in the ",(0,r.kt)("a",{parentName:"p",href:"/docs/Design/Buffer%20Layer"},"Buffer Layer"),". In the ",(0,r.kt)("a",{parentName:"p",href:"/docs/Design/Buffer%20Layer#class-staticbuffer"},"StaticBuffer class"),", we update the ",(0,r.kt)("inlineCode",{parentName:"p"},"StaticBuffer::getFreeBuffer()")," function to implement our block replacement algorithm if there are no free slots in the buffer. We also modify the constructor and destructor to work with the changes we discussed and implement ",(0,r.kt)("inlineCode",{parentName:"p"},"StaticBuffer::setDirtyBit()"),"."),(0,r.kt)("details",null,(0,r.kt)("summary",null,"Buffer/StaticBuffer.cpp"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"StaticBuffer::StaticBuffer() {\n\n  for (/*bufferIndex = 0 to BUFFER_CAPACITY-1*/) {\n    // set metainfo[bufferindex] with the following values\n    //   free = true\n    //   dirty = false\n    //   timestamp = -1\n    //   blockNum = -1\n  }\n}\n\n// write back all modified blocks on system exit\nStaticBuffer::~StaticBuffer() {\n  /*iterate through all the buffer blocks,\n    write back blocks with metainfo as free=false,dirty=true\n    using Disk::writeBlock()\n    */\n}\n")),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},(0,r.kt)("strong",{parentName:"p"},"TASK"),": Implement the following functions looking at their respective design docs"),(0,r.kt)("ul",{parentName:"blockquote"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/docs/Design/Buffer%20Layer#staticbuffer--getfreebuffer"},(0,r.kt)("inlineCode",{parentName:"a"},"StaticBuffer::getFreeBuffer()"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/docs/Design/Buffer%20Layer#staticbuffer--setdirtybit"},(0,r.kt)("inlineCode",{parentName:"a"},"StaticBuffer::setDirtyBit()")))))),(0,r.kt)("p",null,"In the ",(0,r.kt)("a",{parentName:"p",href:"/docs/Design/Buffer%20Layer#class-recbuffer"},"RecBuffer class"),", we modify the ",(0,r.kt)("inlineCode",{parentName:"p"},"BlockBuffer::loadBlockAndGetBufferPtr()")," function to increment the ",(0,r.kt)("inlineCode",{parentName:"p"},"timestamp")," field for the buffer blocks and call the ",(0,r.kt)("inlineCode",{parentName:"p"},"StaticBuffer::getFreeBuffer()")," function to allocate a free buffer if required. We also implement the ",(0,r.kt)("inlineCode",{parentName:"p"},"RecBuffer::setRecord()")," function which is used to update the value of a record at a particular slot in the disk block."),(0,r.kt)("details",null,(0,r.kt)("summary",null,"Buffer/BlockBuffer.cpp"),(0,r.kt)("p",null,"Implement the following functions looking at their respective design docs"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/docs/Design/Buffer%20Layer#blockbuffer--loadblockandgetbufferptr"},(0,r.kt)("inlineCode",{parentName:"a"},"BlockBuffer::loadBlockAndGetBufferPtr()"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/docs/Design/Buffer%20Layer#recbuffer--setrecord"},(0,r.kt)("inlineCode",{parentName:"a"},"RecBuffer::setRecord()"))))),(0,r.kt)("p",null,"And that's it! You should now be able to rename any relation (except ",(0,r.kt)("inlineCode",{parentName:"p"},"RELCAT")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"ATTRCAT")," of course) and any attribute of a relation. We have also implemented the basis of writing blocks back to the disk which we will expand upon in later stages."),(0,r.kt)("h2",{id:"exercises"},"Exercises"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Q1.")," In the ",(0,r.kt)("strong",{parentName:"p"},"XFS interface"),", ",(0,r.kt)("a",{parentName:"p",href:"/docs/User%20Interface%20Commands/ddl#create-table"},"create a relation")," ",(0,r.kt)("inlineCode",{parentName:"p"},"Books(name STR, author STR, price NUM, bookOwner STR)"),". Then, in your NITCbase, run the following commands."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"ALTER TABLE RENAME Books TO LibraryBooks;\nALTER TABLE RENAME LibraryBooks COLUMN bookOwner TO lender;\nOPEN TABLE LibraryBooks;\nSELECT * FROM LibraryBooks INTO null WHERE price>0;\nexit\n")),(0,r.kt)("p",null,"Ensure that you get the following output."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-plain"},"| name | author | price | lender |\nSelected successfully into null\n")),(0,r.kt)("p",null,"Now, let's confirm whether the changes have been written back to the disk. Open the ",(0,r.kt)("strong",{parentName:"p"},"XFS Interface")," and verify the output of the ",(0,r.kt)("a",{parentName:"p",href:"/docs/User%20Interface%20Commands/efs#show-schema"},"schema command"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"# schema LibraryBooks\nRelation: LibraryBooks\nAttribute        Type Index\n---------------- ---- -----\nname             STR  no\nauthor           STR  no\nprice            NUM  no\nlender           STR  no\n")))}f.isMDXComponent=!0}}]);