"use strict";(self.webpackChunknitcbase=self.webpackChunknitcbase||[]).push([[3427],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>m});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},l=Object.keys(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var c=a.createContext({}),s=function(e){var t=a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},d=function(e){var t=s(e.components);return a.createElement(c.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,l=e.originalType,c=e.parentName,d=i(e,["components","mdxType","originalType","parentName"]),u=s(n),m=r,p=u["".concat(c,".").concat(m)]||u[m]||h[m]||l;return n?a.createElement(p,o(o({ref:t},d),{},{components:n})):a.createElement(p,o({ref:t},d))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var l=n.length,o=new Array(l);o[0]=u;var i={};for(var c in t)hasOwnProperty.call(t,c)&&(i[c]=t[c]);i.originalType=e,i.mdxType="string"==typeof e?e:r,o[1]=i;for(var s=2;s<l;s++)o[s]=n[s];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},1150:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>l,metadata:()=>i,toc:()=>s});var a=n(7462),r=(n(7294),n(3905));const l={sidebar_position:5,title:"Block Access Layer"},o=void 0,i={unversionedId:"Design/Block Access Layer",id:"Design/Block Access Layer",title:"Block Access Layer",description:"https://nitcbase.github.io/archived-site/design/blockaccess.html",source:"@site/docs/Design/Block Access Layer.md",sourceDirName:"Design",slug:"/Design/Block Access Layer",permalink:"/docs/Design/Block Access Layer",draft:!1,tags:[],version:"current",sidebarPosition:5,frontMatter:{sidebar_position:5,title:"Block Access Layer"},sidebar:"Design",previous:{title:"Schema Layer",permalink:"/docs/Design/Schema Layer"},next:{title:"Cache Layer",permalink:"/docs/Design/Cache Layer"}},c={},s=[{value:"Layout",id:"layout",level:2},{value:"class BlockAccess",id:"class-blockaccess",level:2},{value:"BlockAccess :: linearSearch()",id:"blockaccess--linearsearch",level:3},{value:"Description",id:"description",level:4},{value:"Arguments",id:"arguments",level:4},{value:"Return Values",id:"return-values",level:4},{value:"Algorithm",id:"algorithm",level:4},{value:"BlockAccess :: search()",id:"blockaccess--search",level:3},{value:"Description",id:"description-1",level:4},{value:"Arguments",id:"arguments-1",level:4},{value:"Return Values",id:"return-values-1",level:4},{value:"Algorithm",id:"algorithm-1",level:4},{value:"BlockAccess :: insert()",id:"blockaccess--insert",level:3},{value:"Description",id:"description-2",level:4},{value:"Arguments",id:"arguments-2",level:4},{value:"Return Values",id:"return-values-2",level:4},{value:"Algorithm",id:"algorithm-2",level:4},{value:"BlockAccess :: renameRelation()",id:"blockaccess--renamerelation",level:3},{value:"Description",id:"description-3",level:4},{value:"Arguments",id:"arguments-3",level:4},{value:"Return Values",id:"return-values-3",level:4},{value:"Algorithm",id:"algorithm-3",level:4},{value:"BlockAccess :: renameAttribute()",id:"blockaccess--renameattribute",level:3},{value:"Description",id:"description-4",level:4},{value:"Arguments",id:"arguments-4",level:4},{value:"Return Values",id:"return-values-4",level:4},{value:"Algorithm",id:"algorithm-4",level:4},{value:"BlockAccess :: deleteRelation()",id:"blockaccess--deleterelation",level:3},{value:"Description",id:"description-5",level:4},{value:"Arguments",id:"arguments-5",level:4},{value:"Return Values",id:"return-values-5",level:4},{value:"Algorithm",id:"algorithm-5",level:4}],d={toc:s};function h(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://nitcbase.github.io/archived-site/design/blockaccess.html"},"https://nitcbase.github.io/archived-site/design/blockaccess.html")),(0,r.kt)("admonition",{title:"note",type:"info"},(0,r.kt)("p",{parentName:"admonition"},"The Block Access Layer code is to be written in ",(0,r.kt)("inlineCode",{parentName:"p"},"BlockAccess.cpp")," and it's header file ",(0,r.kt)("inlineCode",{parentName:"p"},"BlockAccess.h")),(0,r.kt)("p",{parentName:"admonition"},(0,r.kt)("a",{parentName:"p",href:"/stub/block_access_stub"},(0,r.kt)("strong",{parentName:"a"},"The stub code for these files can be found here.")))),(0,r.kt)("h2",{id:"layout"},"Layout"),(0,r.kt)("p",null,"In any database management system, in order to retrieve data from the database or to alter the schema of the relations in the database, the system has to work with the disk blocks. ",(0,r.kt)("em",{parentName:"p"},"Block Access layer provides an abstraction that hides the disk structures to the above layers (",(0,r.kt)("a",{parentName:"em",href:"/docs/Design/Algebra%20Layer"},"Algebra layer")," and ",(0,r.kt)("a",{parentName:"em",href:"/docs/Design/Schema%20Layer"},"Schema layer"),")"),"."),(0,r.kt)("p",null,"The ",(0,r.kt)("em",{parentName:"p"},"block access layer also provides an interface to the above layers in terms of records instead of disk blocks.")," Hence, the Block Access layer processes the requests for update/retrieval from the algebra and schema layers and works with disk blocks that are buffered by the ",(0,r.kt)("a",{parentName:"p",href:"/docs/Design/Buffer%20Layer"},(0,r.kt)("em",{parentName:"a"},"Buffer layer")),"."),(0,r.kt)("p",null,"NITCbase follows an Object-Oriented design for Block Access Layer. The class definition is as shown below."),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"class-blockaccess"},"class BlockAccess"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"class BlockAccess {\npublic:\n\n    static int search(int relId, Attribute *record, char attrName[ATTR_SIZE], Attribute attrVal, int op,\n        int flagValidAttrName);\n\n    static int insert(int relId, union Attribute *record);\n\n    static int renameRelation(char oldName[ATTR_SIZE], char newName[ATTR_SIZE]);\n\n    static int renameAttribute(char relName[ATTR_SIZE], char oldName[ATTR_SIZE], char newName[ATTR_SIZE]);\n\n    static int deleteRelation(char relName[ATTR_SIZE]);\n\n    static RecId linearSearch(int relId, char attrName[ATTR_SIZE], Attribute attrVal, int op);\n\n};\n")),(0,r.kt)("h3",{id:"blockaccess--linearsearch"},"BlockAccess :: linearSearch()"),(0,r.kt)("h4",{id:"description"},"Description"),(0,r.kt)("p",null,"This method searches the relation specified linearly to find the next record that satisfies the specified condition on attribute attrVal and returns the recId of the next record satisfying the condition."),(0,r.kt)("h4",{id:"arguments"},"Arguments"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Name"),(0,r.kt)("th",{parentName:"tr",align:null},"Type"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"relId"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"int")),(0,r.kt)("td",{parentName:"tr",align:null},"Relation Id of Relation to which search has to be made.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"attrName"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"char[ATTR_SIZE]")),(0,r.kt)("td",{parentName:"tr",align:null},"Attribute/column name to which condition need to be checked with.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"attrVal"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"union Attribute")),(0,r.kt)("td",{parentName:"tr",align:null},"value of attribute that has to be checked against the operater.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"op"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"int")),(0,r.kt)("td",{parentName:"tr",align:null},"The conditional operator (which can be one among ",(0,r.kt)("inlineCode",{parentName:"td"},"EQ, LE, LT, GE, GT, NE, RST, PRJCT")," corresponding to the following operators: ",(0,r.kt)("em",{parentName:"td"},"equal to, less than or equal to, less than, greater than or equal to, greater than, not equal to, reset, project"))))),(0,r.kt)("h4",{id:"return-values"},"Return Values"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Value"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"{block#, slot#}")),(0,r.kt)("td",{parentName:"tr",align:null},"returns the ",(0,r.kt)("em",{parentName:"td"},"block number and slot number")," of the record corresponding to the next hit. This corresponds to type ",(0,r.kt)("inlineCode",{parentName:"td"},"RecId"),".")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"{-1, -1}")),(0,r.kt)("td",{parentName:"tr",align:null},"If no valid next hit is found. This corresponds to type ",(0,r.kt)("inlineCode",{parentName:"td"},"RecId"),".")))),(0,r.kt)("h4",{id:"algorithm"},"Algorithm"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'RecId BlockAccess::linearSearch(int relId, char attrName[ATTR_SIZE], union Attribute attrVal, int op) {\n    // get the previous search index of the relation relId from the relation cache\n    // (use RelCacheTable::getSearchIndex() function)\n\n    // let block and slot denote the record id of the record being currently checked\n\n    // if the current search index record is invalid(i.e. both block and slot = -1)\n    if (prevRecId.block == -1 && prevRecId.slot == -1)\n    {\n        // (no hits from previous search; search should start from the first record itself)\n\n        // get the first record block of the relation from the relation cache\n        // (use RelCacheTable::getRelCatEntry() function of Cache Layer)\n\n        // block = first record block of the relation\n        // slot = 0\n    }\n    else\n    {\n        //  (there is a hit from previous search; search should start from the record next to the search index record)\n\n        // block = search index\'s block\n        // slot = search index\'s slot + 1\n    }\n\n    // The following code searches for the next record in the relation that satisfies the given condition\n    // Start from the record id (block, slot) and iterate over the remaining records of the relation\n    while (block != -1)\n    {\n\n        // create a RecBuffer object for block (use RecBuffer Constructor for existing block)\n\n        // get the record with id (block, slot) using RecBuffer::getRecord() function\n        // get header of the block using RecBuffer::getHeader() function\n        // get slot map of the block using RecBuffer::getSlotMap() function\n\n        // If slot >= the number of slots per block(i.e. no more slots in this block)\n        {\n            // update block = right block of block\n            // update slot = 0\n        }\n\n        // if slot is free skip the loop\n        // (i.e. check if slot\'th entry in slot map of block contains SLOT_UNOCCUPIED)\n        {\n            // and continue to the next record slot\n            // (i.e. increment slot and continue)\n        }\n\n        // let cond be a variable of int type\n\n        if ( op != PRJCT )\n        {\n            // compare record\'s attribute value to the the given attrVal as below:\n            /*\n                firstly get the attribute offset for the attrName attribute\n                from the attribute cache entry of the relation using AttrCacheTable::getAttrCatEntry\n            */\n            // use the attribute offset to get the value of the attribute from current record\n            // perform comparison using compare function and store the outcome of comparison in the variable flag\n\n            // initialize cond = UNSET\n\n\n            // Next task is to check whether this record satisfies the given condition.\n            // It is determined based on the output of previous comparison and the op value received.\n            // The following code sets the cond variable if the condition is satisfied.\n            switch (op) {\n\n                case NE:\n                    // if op is "not equal to"\n                    // if the record\'s attribute value is not equal to the given attrVal\n                    if (flag != 0) {\n                        // SET the cond variable (i.e. cond = SET)\n                    }\n                    break;\n\n                case LT:\n                    // if op is "less than"\n                    // if the record\'s attribute value is less than the given attrVal\n                    if (flag < 0) {\n                        // SET the cond variable (i.e. cond = SET)\n                    }\n                    break;\n\n                case LE:\n                    // if op is "less than or equal to"\n                    // if the record\'s attribute value is less than or equal to the given attrVal\n                    if (flag <= 0) {\n                        // SET the cond variable (i.e. cond = SET)\n                    }\n                    break;\n\n                case EQ:\n                    // op is "equal to"\n                    // if the record\'s attribute value is equal to the given attrVal\n                    if (flag == 0) {\n                        // SET the cond variable (i.e. cond = SET)\n                    }\n                    break;\n\n                case GT:\n                    // if op is "greater than"\n                    // if the record\'s attribute value is greater than the given attrVal\n                    if (flag > 0) {\n                        // SET the cond variable (i.e. cond = SET)\n                    }\n                    break;\n\n                case GE:\n                    // if op is "greater than or equal to"\n                    // if the record\'s attribute value is greater than or equal to the given attrVal\n                    if (flag >= 0) {\n                        // SET the cond variable (i.e. cond = SET)\n                    }\n                    break;\n            }\n        }\n\n        if (cond == SET || op == PRJCT) {\n            /*\n                set the search index in the relation cache as\n                the record id of the record that satisfies the given condition\n                (use RelCacheTable::setSearchIndex function)\n            */\n\n            return RecId{block, slot};\n        }\n\n    }\n\n    // no record in the relation with Id relid satisfies the given condition\n    return {-1, -1};\n}\n')),(0,r.kt)("h3",{id:"blockaccess--search"},"BlockAccess :: search()"),(0,r.kt)("h4",{id:"description-1"},"Description"),(0,r.kt)("p",null,"This method searches the relation specified to find the next record that satisfies the specified condition on attribute attrVal and updates the recId of next record satisfying the condition in cache.(uses the b+ tree if target attribute is indexed, otherwise, it does linear search)."),(0,r.kt)("h4",{id:"arguments-1"},"Arguments"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Name"),(0,r.kt)("th",{parentName:"tr",align:null},"Type"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"relId"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"int")),(0,r.kt)("td",{parentName:"tr",align:null},"Relation Id of Relation to which search has to be made.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"record"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"union Attribute*")),(0,r.kt)("td",{parentName:"tr",align:null},"pointer to record where next found record satisfying given condition is to be placed.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"attrName"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"char[ATTR_SIZE]")),(0,r.kt)("td",{parentName:"tr",align:null},"Attribute/column name to which condition need to be checked with.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"attrVal"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"union Attribute")),(0,r.kt)("td",{parentName:"tr",align:null},"value of attribute that has to be checked against the operater.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"op"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"int")),(0,r.kt)("td",{parentName:"tr",align:null},"Conditional Operator (can be one among ",(0,r.kt)("inlineCode",{parentName:"td"},"EQ")," , ",(0,r.kt)("inlineCode",{parentName:"td"},"LE")," , ",(0,r.kt)("inlineCode",{parentName:"td"},"LT")," , ",(0,r.kt)("inlineCode",{parentName:"td"},"GE")," , ",(0,r.kt)("inlineCode",{parentName:"td"},"GT")," , ",(0,r.kt)("inlineCode",{parentName:"td"},"NE")," , ",(0,r.kt)("inlineCode",{parentName:"td"},"RST")," , ",(0,r.kt)("inlineCode",{parentName:"td"},"PRJCT")," corresponding to equal, less or than equal, less than ,greater than or equal, greater than, not equal, reset and projet operators respectively).")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"flagValidAttrName"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"int")),(0,r.kt)("td",{parentName:"tr",align:null},"Specifies whether the attrName passed as argument is a valid one or not. For example, for resetting the search hit before doing a search using project operator, we will be required to pass dummy attrName (and a dummy attrVal) in which case this flag is set to ",(0,r.kt)("inlineCode",{parentName:"td"},"false"))))),(0,r.kt)("h4",{id:"return-values-1"},"Return Values"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Value"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/constants"},(0,r.kt)("inlineCode",{parentName:"a"},"SUCCESS"))),(0,r.kt)("td",{parentName:"tr",align:null},"On successful copy of record to record")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/constants"},(0,r.kt)("inlineCode",{parentName:"a"},"E_NOTFOUND"))),(0,r.kt)("td",{parentName:"tr",align:null},"If it fails to find a record satisfying the given condition")))),(0,r.kt)("h4",{id:"algorithm-1"},"Algorithm"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"int BlockAccess::search(int relId, Attribute *record, char attrName[ATTR_SIZE], Attribute attrVal, int op, int flagValidAttrName) {\n    // Declare a variable called recid to store the searched record\n    RecId recId;\n\n    // If op = PRJCT:\n        // search for the next record id (recid) corresponding for the relation\n        // by passing op = PRJCT and dummy attrName, attrVal.\n        recId = linearSearch(relId, attrName, attrVal, op);\n\n    // else {\n        // if (flagValidAttrName == false && op == RST):\n            // assign the previous record id (prevRecId) to {block_num=-1, slot_num=-1}\n\n            /* update the previous record id (prev_recid) in the relation cache entry\n             * corresponding to the relation with Id = relid by using method from the cache layer */\n\n\n            // return SUCCESS;\n        }\n\n        /* get the attribute catalog entry from the attribute cache corresponding\n        to the relation with Id=relid and with attribute_name=attrName  */\n\n        // get rootBlock from the attribute catalog entry (attrcat_entry)\n        // if Index does not exist for the attribute (check rootBlock == -1)\n        // if (attrCatEntry.rootBlock == -1) :\n            // if the op is reset\n            if (op == RST) {\n                // assign the previous record id (prevRecId) to {block_num=-1, slot_num=-1}\n\n                /* update the previous record id (prev_recid) in the relation cache entry\n                 * corresponding to the relation with Id = relid by using method from the cache layer */\n\n                // return SUCCESS;\n            }\n\n            // search for the record id (recid) corresponding to the attribute with attribute name attrName, with value attrval\n            // and satisfying the condition op using linearSearch()\n\n        // else:\n            // else Index exists for the attribute\n            // if (op == RST):\n                // assign the previous index id (prevIndexId variable) to {block_num=-1, index_num=-1}\n\n                /* update the previous index id (prev_recid) in the attribute cache corresponding\n                   to the relation with Id relid and attribute name with attrName\n                   using appropriate method of cache layer */\n\n\n                // return SUCCESS\n\n            // search for the record id (recid) correspoding to the attribute with attribute name attrName and with value attrval\n\n            // recid = bplus_search(relId, attrName, attval, op);\n    }\n\n    // if it fails to find a record satisfying the given condition (recId = {-1, -1}) return E_NOTFOUND;\n\n    /* Copy the record with record id (recId) to the record buffer (record)\n       For this Instantiate a RecBuffer class object by passing the recId and\n       call the appropriate method to fetch the record\n    */\n\n    // return SUCCESS\n}\n")),(0,r.kt)("h3",{id:"blockaccess--insert"},"BlockAccess :: insert()"),(0,r.kt)("h4",{id:"description-2"},"Description"),(0,r.kt)("p",null,"This method inserts the Record into Relation as specified in arguments."),(0,r.kt)("h4",{id:"arguments-2"},"Arguments"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Name"),(0,r.kt)("th",{parentName:"tr",align:null},"Type"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"relId"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"int")),(0,r.kt)("td",{parentName:"tr",align:null},"Relation Id of Relation to which record is to be inserted")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"record"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"union Attribute*")),(0,r.kt)("td",{parentName:"tr",align:null},"Pointer to Record(containing values for all the attributes), Record is an array of Attribute type")))),(0,r.kt)("h4",{id:"return-values-2"},"Return Values"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Value"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/constants"},(0,r.kt)("inlineCode",{parentName:"a"},"SUCCESS"))),(0,r.kt)("td",{parentName:"tr",align:null},"On successful insert of the given record")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/constants"},(0,r.kt)("inlineCode",{parentName:"a"},"E_INDEX_BLOCKS_RELEASED"))),(0,r.kt)("td",{parentName:"tr",align:null},"Record was inserted successfully, but the index existing on one or more attributes had to be deleted due to insufficient disk space")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/constants"},(0,r.kt)("inlineCode",{parentName:"a"},"E_DISKFULL"))),(0,r.kt)("td",{parentName:"tr",align:null},"If disk space is not sufficient for inserting the record / index")))),(0,r.kt)("h4",{id:"algorithm-2"},"Algorithm"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"int BlockAccess::insert(int relId, Attribute *record) {\n    // get the relation catalog entry from relation cache\n    // ( use RelCacheTable::getRelCatEntry() of Cache Layer)\n\n    // let blockNum denote the first record block of the relation (obtained from relation catalog entry)\n\n    // Let rec_id denote the record id of the slot where the new record will be inserted\n    RecId rec_id = {-1, -1};\n\n    // let numOfSlots denote the number of slots per record block (obtained from relation catalog entry)\n    // let numOfAttributes denote the number of attributes of the relation (obtained from relation catalog entry)\n\n    // let prevBlockNum denote the block number of the last element in the linked list = -1;\n\n    /*\n        Traversing the linked list of existing record blocks of the relation\n        until a free slot is found OR\n        until the end of the list is reached\n    */\n    while (blockNum != -1) {\n        // create a RecBuffer object for blockNum(use constructor for existing block)\n\n        // get header of block(blockNum) using RecBuffer::getHeader() function\n\n        // get slot map of block(blockNum) using RecBuffer::getSlotMap() function\n\n        // search for free slot in the block 'blockNum' and store it's record id in rec_id\n        // (Free slot can be found by iterating over the slot map of the block)\n        // slot map stores SLOT_UNOCCUPIED if slot is free and SLOT_OCCUPIED if slot is occupied)\n\n        // if a free slot is found, discontinue the traversal of the linked list of record blocks\n\n        // otherwise, continue to check the next block by updating the block numebers as follows:\n        // update prevBlockNum = blockNum\n        // update blockNum = header.rblock (next element in the linked list of record blocks)\n    }\n\n    //  if no free slot is found in existing record blocks\n    {\n        // if relation is RELCAT, do not allocate any more blocks (i.e. if relId = RELCAT_RELID)\n        //      return E_MAXRELATIONS;\n\n        // Otherwise,\n        // get a new record block by calling RecBuffer Constructor for new block\n        // get the block number of the newly allocated block\n        // (use BlockBuffer::getBlockNum() function)\n        // let ret be the return value of getBlockNum() function call\n        if (ret == E_DISKFULL) {\n            // disk is full\n            return E_DISKFULL;\n        }\n\n        // Assign rec_id.block = new block number(i.e. ret) and rec_id.slot = 0\n\n        /*\n            set the header of the new record block such that it links with existing record blocks of the relation\n            set the block's header as follows:\n            blockType: REC, pblock: -1\n            lblock\n                    = -1 (if linked list of existing record blocks was empty)\n                    = prevBlockNum (otherwise),\n            rblock: -1, numEntries: 0,\n            numSlots: numOfSlots, numAttrs: numOfAttributes\n            (use BlockBuffer::setHeader() function)\n        */\n\n        /*\n            set block's slot map with all slots marked as free\n            (i.e. store SLOT_UNOCCUPIED for all the entries)\n            (use RecBuffer::setSlotMap() function)\n        */\n\n        // if prevBlockNum != -1\n        {\n            // create a RecBuffer object for prevBlockNum(use constructor for existing block)\n            // get the header of the block prevBlockNum\n            // update the rblock field of the header to the new block number(i.e. rec_id.block)\n            // (use BlockBuffer::setHeader() function)\n        }\n        // else\n        {\n            // update first block field in the relation catalogue entry to the new block(i.e. rec_id.block)\n            // (use RelCacheTable::setRelCatEntry() function of Cache Layer)\n        }\n\n        // update last block field in the relation catalogue entry to the new block(i.e. rec_id.block)\n        // (use RelCacheTable::setRelCatEntry() function of Cache Layer)\n    }\n\n    // create a RecBuffer object for rec_id.block(use constructor for existing block)\n    // insert the record into rec_id'th slot by calling RecBuffer::setRecord() function)\n\n    // update the slot map of the block by marking entry of the slot to which record was inserted as occupied)\n    // (ie store SLOT_OCCUPIED in free_slot'th entry of slot map)\n    // (use RecBuffer::getSlotMap() and RecBuffer::setSlotMap() functions)\n\n    // increment the num_entries field in the header of the block (to which record was inserted)\n    // (use BlockBuffer::getHeader() and BlockBuffer::setHeader() functions)\n\n    // Increment the number of records field in the relation cache entry for the relation.\n    // (use RelCacheTable::setRelCatEntry function)\n\n    /*\n        B+ tree insertions\n     */\n    // Let flag = SUCCESS\n    flag = SUCCESS;\n    // Iterate over all the attributes of the relation\n    // Let attrOffset be iterator ranging from 0 to numOfAttributes-1\n    {\n        // get the attribute catalog entry for the attribute from the attribute cache\n        // (use AttrCacheTable::getAttrCatEntry() function with arguments relId and attrOffset)\n\n        // get the root block field from the attribute catalog entry\n\n        // if index exists for the attribute(i.e. rootBlock != -1)\n        {\n            // TODO: Update once BPlus Layer algorithms are completed\n            // BPlusTree bPlusTree = BPlusTree(relId, attrName);\n            // int retVal = bPlusTree.bPlusInsert(record[attrOffset], rec_id);\n            // if (retVal == E_DISKFULL) {\n            // delete the b+ tree for the attribute using ? function\n\n            // flag = E_INDEX_BLOCKS_RELEASED\n        }\n    }\n\n    //  return flag;\n}\n")),(0,r.kt)("h3",{id:"blockaccess--renamerelation"},"BlockAccess :: renameRelation()"),(0,r.kt)("h4",{id:"description-3"},"Description"),(0,r.kt)("p",null,"This method changes the relation name of specified relation to the new name specified in arguments."),(0,r.kt)("h4",{id:"arguments-3"},"Arguments"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Name"),(0,r.kt)("th",{parentName:"tr",align:null},"Type"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"oldName"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"char[ATTR_SIZE]")),(0,r.kt)("td",{parentName:"tr",align:null},"Old Name of Relation to which name has to be changed")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"newName"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"char[ATTR_SIZE]")),(0,r.kt)("td",{parentName:"tr",align:null},"New name for the Relation")))),(0,r.kt)("h4",{id:"return-values-3"},"Return Values"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Value"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/constants"},(0,r.kt)("inlineCode",{parentName:"a"},"SUCCESS"))),(0,r.kt)("td",{parentName:"tr",align:null},"On successful renaming of the relation")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/constants"},(0,r.kt)("inlineCode",{parentName:"a"},"E_RELNOTEXIST"))),(0,r.kt)("td",{parentName:"tr",align:null},"If the relation with name oldName does not exist")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/constants"},(0,r.kt)("inlineCode",{parentName:"a"},"E_RELEXIST"))),(0,r.kt)("td",{parentName:"tr",align:null},"If the relation with name newName already exists")))),(0,r.kt)("h4",{id:"algorithm-3"},"Algorithm"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'int BlockAccess::renameRelation(char oldName[ATTR_SIZE], char newName[ATTR_SIZE]){\n    Attribute newRelationName;\n    strcpy(newRelationName.sVal, newName);\n\n    // Reset the Search Index by using RelCacheTable and setting value to {-1, -1}\n    RecId searchIndex = {-1, -1};\n    RelCacheTable::setSearchIndex(RELCAT_RELID, &searchIndex);\n    // search for the relation with name newName in relation catalog using linearSearch()\n    relcat_recid = linearSearch(RELCAT_RELID, "RelName", newRelationName, EQ );\n    // note: newRelationName is of type Attribute (to be constructed from newName)\n\n    // If relation with name newName already exits\n    if(relcat_recid != {-1,-1}){\n        return E_RELEXIST;\n    }\n\n    Attribute oldRelationName;\n    strcpy(oldRelationName.sVal, oldName);\n\n    // Reset the Search Index by using RelCacheTable and setting value to {-1, -1}\n    searchIndex = {-1, -1};\n    RelCacheTable::setSearchIndex(RELCAT_RELID, &searchIndex);\n    // search for the relation with name oldName in relation catalog\n    relcat_recid = linearSearch( ---fill the arguments--- );\n\n    // If relation with name relName does not exits\n    if(relcat_recid == {-1,-1}) {\n        return E_RELNOTEXIST;\n    }\n\n    // get the relation catalog record from the relation catalog (recid of the relation catalog record = relcat_recid)\n    RecBuffer recBuffer = RecBuffer(relcat_recid.block);\n    recBuffer.getRecord(relcat_record, relcat_recid.slot);\n\n    // update the relation catalog record in the relation catalog with relation name newName\n    recBuffer.setRecord(record, relcat_recid.slot);\n\n    /*\n        update all the attribute catalog entries in the attribute catalog corresponding to the\n          relation with relation name oldName to the relation name newName\n    */\n    // NOTE: Reset the Search Index by using RelCacheTable and setting value to {-1, -1}\n    searchIndex = {-1, -1};\n    RelCacheTable::setSearchIndex(ATTRCAT_RELID, &searchIndex);\n\n\n    return SUCCESS;\n}\n')),(0,r.kt)("h3",{id:"blockaccess--renameattribute"},"BlockAccess :: renameAttribute()"),(0,r.kt)("h4",{id:"description-4"},"Description"),(0,r.kt)("p",null,"This method changes the name of an attribute/column present in a specified relation, to the new name specified in arguments."),(0,r.kt)("h4",{id:"arguments-4"},"Arguments"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Name"),(0,r.kt)("th",{parentName:"tr",align:null},"Type"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"relName"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"char[ATTR_SIZE]")),(0,r.kt)("td",{parentName:"tr",align:null},"Name of the Relation")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"oldName"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"char[ATTR_SIZE]")),(0,r.kt)("td",{parentName:"tr",align:null},"Old Name of attribute")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"newName"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"char[ATTR_SIZE]")),(0,r.kt)("td",{parentName:"tr",align:null},"New name for attribute")))),(0,r.kt)("h4",{id:"return-values-4"},"Return Values"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Value"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/constants"},(0,r.kt)("inlineCode",{parentName:"a"},"SUCCESS"))),(0,r.kt)("td",{parentName:"tr",align:null},"On successful renaming of the attribute")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/constants"},(0,r.kt)("inlineCode",{parentName:"a"},"E_RELNOTEXIST"))),(0,r.kt)("td",{parentName:"tr",align:null},"If the relation with name relName does not exist")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/constants"},(0,r.kt)("inlineCode",{parentName:"a"},"E_ATTRNOTEXIST"))),(0,r.kt)("td",{parentName:"tr",align:null},"If the attribute with name oldName does not exist")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/constants"},(0,r.kt)("inlineCode",{parentName:"a"},"E_ATTREXIST"))),(0,r.kt)("td",{parentName:"tr",align:null},"If the attribute with name newName already exists")))),(0,r.kt)("h4",{id:"algorithm-4"},"Algorithm"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'int BlockAccess::renameAttribute(char relName[ATTR_SIZE], char oldName[ATTR_SIZE], char newName[ATTR_SIZE]) {\n    // Search for the relation with name relName in relation catalog using Linear Search\n    Attribute attrValueRelName;\n    strcpy(attrValueRelName.sVal, relName);\n    RecId searchIndex = {-1, -1};\n    RelCacheTable::setSearchIndex(RELCAT_RELID, &searchIndex);\n    RecId relcatRecId = linearSearch(RELCAT_RELID, "RelName", attrValueRelName, EQ);\n\n    // If relation with name relName does not exits (relcatRecId == {-1,-1})\n    //    return E_RELNOTEXIST;\n\n    /***\n        Iterating over all Attribute Catalog Entry record corresponding to relation to find the required attribute\n    ***/\n    // Reset the Search Index by using RelCacheTable and setting value to {-1, -1}\n    searchIndex = {-1, -1};\n    RelCacheTable::setSearchIndex(ATTRCAT_RELID, &searchIndex);\n\n    // Define RecId attrId {-1, -1} - used to check if an attribute of oldName exists or not.\n     RecId attrId{-1, -1};\n    Attribute attrcatEntryRecord[ATTRCAT_NO_ATTRS];\n      while (true) {\n        RecId attrcatEntryRecId = linearSearch(ATTRCAT_RELID, "RelName", relationName, EQ);\n\n        if (attrcatEntryRecId.block == -1) {\n            break;\n        }\n\n        // Get the attribute catalog record from the attribute catalog\n        // Hint: instantiate RecBuffer Class with appropriate block number and use getRecord method to store the record into attrcatEntryRecord.\n\n        // if (strcmp(attrcatEntryRecord[1].sVal, oldName) == 0) attrId = attrcatEntryRecId;\n\n        // if (strcmp(attrcatEntryRecord[1].sVal, newName) == 0) return E_ATTREXIST;\n\n\n      }\n\n    // if (attrId.block == -1) return E_ATTRNOTEXIST;\n\n    // Update the entry corresponding to the attribute in the Attribute Catalog Relation.\n    /* Hint: Instantiate RecBuffer class by passing appropriate block number = attrId.block\n        Get the record corresponding to the entry by using getRecord method by passing attrId.slot\n        as argument.\n        Use setRecord method to set the record back after updating the entry appropriately.\n    */\n\n\n    // return SUCCESS\n}\n\n')),(0,r.kt)("h3",{id:"blockaccess--deleterelation"},"BlockAccess :: deleteRelation()"),(0,r.kt)("h4",{id:"description-5"},"Description"),(0,r.kt)("p",null,"This method deletes the Relation with the name specified in arguments."),(0,r.kt)("h4",{id:"arguments-5"},"Arguments"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Name"),(0,r.kt)("th",{parentName:"tr",align:null},"Type"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"relName"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"char[ATTR_SIZE]")),(0,r.kt)("td",{parentName:"tr",align:null},"Name of Relation to delete")))),(0,r.kt)("h4",{id:"return-values-5"},"Return Values"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Value"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/constants"},(0,r.kt)("inlineCode",{parentName:"a"},"SUCCESS"))),(0,r.kt)("td",{parentName:"tr",align:null},"On successful deletion of the given relation")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/constants"},(0,r.kt)("inlineCode",{parentName:"a"},"E_RELNOTEXIST"))),(0,r.kt)("td",{parentName:"tr",align:null},"If the relation does not exist")))),(0,r.kt)("h4",{id:"algorithm-5"},"Algorithm"),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"If at any point getHeader(), setHeader(), getRecord(), setRecord(), getSlotMap() or setSlotMap() methods of Block access layer are being called, make sure to get the return value and if it is not success, then to return the error code from the method.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"int BlockAccess::deleteRelation(char relName[ATTR_SIZE]) {\n    /* search for relation with name relName in relation catalog using Linear Search and store the relcatRecId */\n    // Hint: relid is RELCAT_RELID attribute name to search will be \"RelName\" op = EQ\n    // Also make an Attribute (attrValueRelName) with sval = relName and then pass that as the argument to linear search\n    // NOTE: Reset the Search Index by using RelCacheTable and setting value to {-1, -1} before callign the linearSearch()\n    RecId searchIndex = {-1, -1};\n    RelCacheTable::setSearchIndex(RELCAT_RELID, &searchIndex);\n\n    RecId relcatRecId = linearSearch(RELCAT_RELID, \"RelName\", attrvalRelName, EQ);\n\n    // If relation with relName does not exits (relcatRecId == {-1, -1}), return E_RELNOTEXIST\n\n    // Declare Attribute* relcatEntryRecord to store the relation catalog entry corresponding to the relcat entry.\n    Attribute *relcatEntryRecord;\n\n    /* Get the relation catalog entry record corresponding to relation with relName using the relcatRecId */\n    // Hint: instantiate RecBuffer class using relcatRecId.block and then use appropriate class method to get the record.\n\n    // get the first record block of the relation (firstBlock) using the relation catalog entry record\n    // get the number of attributes corresponding to the relation (numAttrs) using the relation catalog entry record\n\n    // Delete all the record blocks of the relation by getting the next record blocks (rblock) from header\n    // and by calling releaseBlock() method\n    /*\n        Hint: instantiate a BlockBuffer class object by giving appropriate arguments to constructor\n        (which is block number of the first block),\n        get the header of the block by calling appropriate method of the class to fetch 'next' record block number,\n        delete the existing block and repeat for the next block.\n        Also note that to check if we reached the end either use lastBlock number field for currBlock OR check if nextBlock number is -1\n     */\n    while (true) {\n        // Call releaseBlock()\n\n        // if currBlock == lastBlock || nextBlock == -1, break\n\n        // get the BlockBuffer instance for 'nextBlock'\n\n        // update current and next block numbers\n\n    }\n\n    /***\n        Deleting attribute catalog entries corresponding the relation and index blocks corresponding to the relation with relName on its attributes\n    ***/\n    /*\n       Declare attrcatRecId and attractEntryRecord variables to store\n       record id of the attrcat entry and to store the attrcat entry record respectively.\n       Also make an Attribute (attrValueRelName) with sval = relName and then pass that as the argument to linear search\n     */\n    RecId attrcatRecId;\n    Attribute *attrcatEntryRecord;\n    Attribute attrValueRelName;\n    strcpy(attrValueRelName.sVal, relName);\n\n    // Reset the Search Index by using RelCacheTable and setting value to {-1, -1}\n    searchIndex = {-1, -1};\n    RelCacheTable::setSearchIndex(ATTRCAT_RELID, &searchIndex);\n\n    int numberOfAttributesDeleted = 0;\n    // Iterate over all the attributes corresponding to the relation\n    while (true) {\n        // search for all the attributes corresponding to the relation with relName in attribute catalog\n        attrcatRecId = linearSearch(ATTRCAT_RELID, \"RelName\", attrValueRelName, EQ);\n        if (attrcatRecId.block == -1 && attrcatRecId.slot == -1) {\n            // No more attributes to iterate over.\n            break;\n        }\n\n        numberOfAttributesDeleted++;\n\n        /***\n            Deleting the attribute catalog entry corresponding to the attribute from attribute catalog\n        ***/\n\n        // Get the header by Instantiating a RecBuffer instance (attrcatRecBuffer) and calling appropriate methods\n        RecBuffer attrcatRecBuffer = RecBuffer(attrcatRecId.block);\n        HeadInfo attrcatRecBufferBlockHeader;\n        int ret = attrcatRecBuffer.getHeader(&attrcatRecBufferBlockHeader);\n\n        // get the rootBlock from attribute catalog (use attrcatRecBuffer object to call appropriate method\n        // to get record corresponding to the attribute catalog entry)\n        // This will be used later to delete any indexes if it exists\n        attrcatRecBuffer.getRecord(attrcatEntryRecord, attrcatRecId.slot);\n        int rootBlock = (int) attrcatEntryRecord[ATTRCAT_ROOT_BLOCK_INDEX].nVal;\n\n        // Update the Slotmap for the block by indicating the slot as free(use SLOT_UNOCCUPIED)\n        slotMap[attrcatRecId.slot] = SLOT_UNOCCUPIED;\n\n        // Adjust the number of entries in the block (decrease by 1) corresponding to the attribute catalog entry\n                // and set it back using setHeader()\n\n        // If number of entries become 0, releaseBlock is called after fixing the Linked List.\n        // Hint: Update to the linked list involves setting the left and right pointers of block\n        // adjacent to the released block appropriately.\n        if (attrcatRecBufferBlockHeader.numEntries == 0) {\n            /* Standard Linked List Delete for a Block */\n            // Get the header of the previous block (left block)\n            // Hint: instantiate a RecBuffer class corresponding to the lblock and call appropriate methods\n\n            // Set the previous header's rblock to the block's header's rblock\n\n            if (attrcatRecBufferBlockHeader.rblock != -1) {\n                // Get the header of the next block (right block)\n                // Hint: instantiate a RecBuffer class corresponding to the lblock and call appropriate methods\n\n                // Set the next block's header's lblock to the block's header's lblock\n\n            } else {\n                // the block being released is the \"Last Block\" of the relation.\n                // Update the Relation Catalog entry's LastBlock field for this relation with the block number of the previous block.\n            }\n\n            // call releaseBlock()\n\n        }\n\n        // if index exists for the attribute (rootBlock != -1), call bplus destroy\n        if (rootBlock != -1) {\n            // bplus_destroy(rootBlock); //delete the index blocks corresponding to the attribute\n        }\n    }\n\n    /*** Delete the relation catalog entry corresponding to the relation from relation catalog ***/\n    // Fetch the header of Relcat block\n\n    // Adjust the number of entries in the header of the block (decrease by 1) corresponding to the relation catalog entry\n        // and set it back\n\n    // Get the slotmap in relation catalog, update it by marking the slot as free(use SLOT_UNOCCUPIED) and set it back.\n\n    /*** Updating the Relation Cache Table ***/\n    /** Update relation catalog record entry (number of records in relation catalog is decreased by 1) **/\n    // Hint: Get the entry corresponding to relation catalog from the relation cache and update the number of records\n    // and set it back\n\n    /** Update attribute catalog entry (number of records in attribute catalog is decreased by numberOfAttributesDeleted) **/\n    i.e., #Records = #Records - numberOfAttributesDeleted\n\n    // Hint: Get the entry corresponding to attribute catalog from the relation cache and update the number of records\n    // and set it back\n\n    // return SUCCESS;\n}\n")))}h.isMDXComponent=!0}}]);