"use strict";(self.webpackChunknitcbase=self.webpackChunknitcbase||[]).push([[7396],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>m});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),d=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},p=function(e){var t=d(e.components);return a.createElement(s.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),u=d(n),m=r,k=u["".concat(s,".").concat(m)]||u[m]||c[m]||i;return n?a.createElement(k,o(o({ref:t},p),{},{components:n})):a.createElement(k,o({ref:t},p))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=u;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:r,o[1]=l;for(var d=2;d<i;d++)o[d]=n[d];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},2763:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>c,frontMatter:()=>i,metadata:()=>l,toc:()=>d});var a=n(7462),r=(n(7294),n(3905));const i={sidebar_position:0,title:"Introduction"},o="Buffer Layer",l={unversionedId:"Design/Buffer Layer/intro",id:"Design/Buffer Layer/intro",title:"Introduction",description:"The files corresponding to this layer can be found in the Buffer directory. The code is to be written in the files StaticBuffer.cpp and BlockBuffer.cpp. The declaration for the functions can be found in the respective header files StaticBuffer.h and BlockBuffer.h.",source:"@site/docs/Design/Buffer Layer/intro.md",sourceDirName:"Design/Buffer Layer",slug:"/Design/Buffer Layer/intro",permalink:"/docs/Design/Buffer Layer/intro",draft:!1,tags:[],version:"current",sidebarPosition:0,frontMatter:{sidebar_position:0,title:"Introduction"},sidebar:"Design",previous:{title:"class OpenRelTable",permalink:"/docs/Design/Cache Layer/OpenRelTable"},next:{title:"class StaticBuffer",permalink:"/docs/Design/Buffer Layer/StaticBuffer"}},s={},d=[{value:"Layout",id:"layout",level:2},{value:"Block Structures",id:"block-structures",level:2},{value:"HeadInfo",id:"headinfo",level:3},{value:"Attribute",id:"attribute",level:3},{value:"InternalEntry",id:"internalentry",level:3},{value:"Index",id:"index",level:3},{value:"Buffer Structure",id:"buffer-structure",level:2},{value:"Miscellaneous",id:"miscellaneous",level:2},{value:"RecId",id:"recid",level:3},{value:"IndexId",id:"indexid",level:3},{value:"compareAttrs()",id:"compareattrs",level:3},{value:"Description",id:"description",level:4},{value:"Arguments",id:"arguments",level:4},{value:"Return Values",id:"return-values",level:4}],p={toc:d};function c(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"buffer-layer"},"Buffer Layer"),(0,r.kt)("admonition",{title:"note",type:"info"},(0,r.kt)("p",{parentName:"admonition"},"The files corresponding to this layer can be found in the ",(0,r.kt)("inlineCode",{parentName:"p"},"Buffer")," directory. The code is to be written in the files ",(0,r.kt)("inlineCode",{parentName:"p"},"StaticBuffer.cpp")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"BlockBuffer.cpp"),". The declaration for the functions can be found in the respective header files ",(0,r.kt)("inlineCode",{parentName:"p"},"StaticBuffer.h")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"BlockBuffer.h"),"."),(0,r.kt)("p",{parentName:"admonition"},(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("a",{parentName:"strong",href:"/docs/Misc/stub/buffer"},"The stub code for these files can be found here.")))),(0,r.kt)("h2",{id:"layout"},"Layout"),(0,r.kt)("p",null,"Whenever NITCbase needs to work on a disk block, the block has to be first fetched from the ",(0,r.kt)("em",{parentName:"p"},"secondary memory storage")," (",(0,r.kt)("inlineCode",{parentName:"p"},"disk"),") to the ",(0,r.kt)("strong",{parentName:"p"},"primary memory"),". ",(0,r.kt)("em",{parentName:"p"},"A large pool of memory")," (called ",(0,r.kt)("em",{parentName:"p"},"buffer")," in the documentation) is pre-allocated and managed to ",(0,r.kt)("em",{parentName:"p"},"hold copies of disk blocks in the primary memory"),". When a request involving ",(0,r.kt)("em",{parentName:"p"},"access/update")," of a disk block comes from any of the higher layers, the corresponding disk block is loaded into the buffer. After performing updates, the block is committed back to the disk from the buffer."),(0,r.kt)("p",null,"NITCbase uses a dedicated ",(0,r.kt)("strong",{parentName:"p"},"Buffer Layer")," for the above functionality.\n",(0,r.kt)("em",{parentName:"p"},"All the requests involving disk blocks go through the Buffer Layer.")," The interface provided by the ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"Buffer Layer"))," gives a memory address space abstraction to the higher layers, hiding the complexities involved in the reads and writes to the actual physical disk blocks."),(0,r.kt)("p",null,"NITCbase has pre-allocated memory for holding ",(0,r.kt)("strong",{parentName:"p"},"32 disk blocks")," in its ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"buffer memory"))," at a given time. Buffer Layer is responsible for maintaining the buffer memory and making ",(0,r.kt)("em",{parentName:"p"},"replacements")," and ",(0,r.kt)("em",{parentName:"p"},"writebacks")," as required. The disk class functions are used by the Buffer Layer to load blocks from the disk to the buffer and also to write back blocks as and when necessary. A single object of the disk class needs to be declared at the start of the session. Its purpose is to run the constructor and the destructor of the class."),(0,r.kt)("admonition",{title:"Note",type:"tip"},(0,r.kt)("p",{parentName:"admonition"},"The ",(0,r.kt)("inlineCode",{parentName:"p"},"Disk")," class ",(0,r.kt)("em",{parentName:"p"},"constructor")," will create a new ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"Run Copy"))," of the actual disk and all disk accesses during runtime of NITCbase is done via this ",(0,r.kt)("em",{parentName:"p"},"Run Copy"),". At the close of the system, the ",(0,r.kt)("inlineCode",{parentName:"p"},"Disk")," class ",(0,r.kt)("em",{parentName:"p"},"destructor")," will write back the ",(0,r.kt)("em",{parentName:"p"},"Run Copy")," of disk to the actual disk.")),(0,r.kt)("p",null,"NITCbase follows an Object-Oriented design for Buffer Layer. The class diagram is as shown below."),(0,r.kt)("hr",null),(0,r.kt)("mermaid",{value:"classDiagram\n    direction TD\n    StaticBuffer <|.. BlockBuffer : friend\n    BlockBuffer <|-- IndBuffer\n    BlockBuffer <|-- RecBuffer\n    IndBuffer <|-- IndInternal\n    IndBuffer <|-- IndLeaf\n    class StaticBuffer{\n        -blocks[BUFFER_CAPACITY][BLOCK_SIZE]: unsigned char\n        -metainfo[BUFFER_CAPACITY]: struct BufferMetaInfo\n        -blockAllocMap[DISK_BLOCKS]: unsigned char\n        +StaticBuffer()\n        +~StaticBuffer()\n        -getFreeBuffer(int blockNum)$ int\n        -getBufferNum(int blockNum)$ int\n        +getStaticBlockType(int blockNum)$ int\n        +setDirtyBit(int blockNum)$ int\n    }\n    class BlockBuffer{\n        #blockNum: int\n        +BlockBuffer(char blockType)\n        +BlockBuffer(int blockNum)\n        +getBlockNum() int\n        +getHeader(struct HeadInfo *head) int\n        +setHeader(struct HeadInfo *head) int\n        +releaseBlock() void\n        #loadBlockAndGetBufferPtr(unsigned char **buffPtr) int\n        #getFreeBlock(int blockType) int\n        #setBlockType(int blockType) int\n    }\n    class IndBuffer{\n        +IndBuffer(char blockType)\n        +IndBuffer(int blockType)\n        +getEntry(void *ptr, int indexNum)* int\n        +setEntry(void *ptr, int indexNum)* int\n    }\n    class RecBuffer{\n        +RecBuffer()\n        +RecBuffer(int blockNum)\n        +getSlotMap(unsigned char *slotMap) int\n        +setSlotMap(unsigned char *slotMap) int\n        +getRecord(union Attribute *rec, int slotNum) int\n        +setRecord(union Attribute *rec, int slotNum) int\n    }\n    class IndInternal{\n        +IndInternal()\n        +IndInternal(int blockNum)\n        +getEntry(void *ptr, int indexNum) int\n        +setEntry(void *ptr, int indexNum) int\n    }\n    class IndLeaf{\n        +IndLeaf()\n        +IndLeaf(int blockNum)\n        +getEntry(void *ptr, int indexNum) int\n        +setEntry(void *ptr, int indexNum) int\n    }\n"}),(0,r.kt)("hr",null),(0,r.kt)("p",null,"Various structures used in the buffer layer are outlined in the below diagrams."),(0,r.kt)("mermaid",{value:"classDiagram\n    class BufferMetaInfo{\n        <<struct>>\n        +free: bool\n        +dirty: bool\n        +blockNum: int\n        +timestamp: int\n    }\n    class HeadInfo{\n        <<struct>>\n        +blockType: int32_t\n        +pBlock: int32_t\n        +lBlock: int32_t\n        +rBlock: int32_t\n        +numEntries: int32_t\n        +numAttrs: int32_t\n        +numSlots: int32_t\n        +reserved[4]: unsigned char\n    }\n    class Attribute{\n        <<union>>\n        +nVal: float\n        +sVal[ATTR_SIZE]: char\n    }\n    class InternalEntry{\n        <<struct>>\n        +lChild: int32_t\n        +attrVal: union Attribute\n        +rChild: int32_t\n    }\n    class Index{\n        <<struct>>\n        +attrVal: union Attribute\n        +block: int32_t\n        +slot: int32_t\n        +unused[8]: unsigned char\n    }\n"}),(0,r.kt)("hr",null),(0,r.kt)("p",null,"Certain other structure definitions and functions that help access record data and metadata from the disk block are also included in the Buffer Layer. These are discussed at the end of this page (see ",(0,r.kt)("a",{parentName:"p",href:"#miscellaneous"},"miscellaneous section"),")."),(0,r.kt)("h2",{id:"block-structures"},"Block Structures"),(0,r.kt)("p",null,"The Buffer Layer defines the following block data structures."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#headinfo"},"HeadInfo")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#attribute"},"Attribute")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#internalentry"},"InternalEntry")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#index"},"Index"))),(0,r.kt)("p",null,"Each structure is designed to store ",(0,r.kt)("strong",{parentName:"p"},"a subset of the data stored in a disk block"),". A disk block contains ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"2048 bytes"))," of data. Higher layer functions, however, instead of processing the whole block data together, typically request access to a particular set of related data in a disk block at a time. Whenever such a selective access request is made, the method in the Buffer Layer implementing the access functionality will pack the requested data into the corresponding block structure designed to store that particular type of data. Variables of these structures will be declared and used in the ",(0,r.kt)("a",{parentName:"p",href:"/docs/Design/Cache%20Layer/intro"},"Cache Layer"),", the ",(0,r.kt)("a",{parentName:"p",href:"/docs/Design/Block%20Access%20Layer"},"Block Access Layer"),", and the ",(0,r.kt)("a",{parentName:"p",href:"/docs/Design/B+%20Tree%20Layer"},"B+ Tree Layer"),"."),(0,r.kt)("h3",{id:"headinfo"},"HeadInfo"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"NITCbase maintains a ",(0,r.kt)("em",{parentName:"strong"},"32 byte")," ",(0,r.kt)("em",{parentName:"strong"},"fixed-size")," header for every disk block.")," This header stores ",(0,r.kt)("em",{parentName:"p"},"meta-information"),", like the type of the block, and a few block specific information, like ",(0,r.kt)("inlineCode",{parentName:"p"},"#Attrs")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"#Slots"),". Though the header has many fields, usage of the fields depends on the type of the block. The structure ",(0,r.kt)("inlineCode",{parentName:"p"},"HeadInfo")," is used to collect all the entries of the header, as shown below. The ",(0,r.kt)("inlineCode",{parentName:"p"},"setHeader()")," and the ",(0,r.kt)("inlineCode",{parentName:"p"},"getHeader()")," methods take a pointer to ",(0,r.kt)("inlineCode",{parentName:"p"},"struct HeadInfo")," as argument."),(0,r.kt)("admonition",{title:"Implementation Note",type:"caution"},(0,r.kt)("p",{parentName:"admonition"},(0,r.kt)("inlineCode",{parentName:"p"},"getHeader()")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"setHeader()")," methods expect the higher layers to allocate memory for the ",(0,r.kt)("inlineCode",{parentName:"p"},"struct HeadInfo")," before calling them.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"struct HeadInfo {\n    int32_t blockType;\n    int32_t pblock;\n    int32_t lblock;\n    int32_t rblock;\n    int32_t numEntries;\n    int32_t numAttrs;\n    int32_t numSlots;\n    unsigned char reserved[4];\n};\n")),(0,r.kt)("h3",{id:"attribute"},"Attribute"),(0,r.kt)("p",null,"According to the ",(0,r.kt)("a",{parentName:"p",href:"../../Design/Physical%20Layer#disk-model"},"Disk Model"),", a record block has slots for storing records, and each record contains a set of attributes. The ",(0,r.kt)("inlineCode",{parentName:"p"},"Attribute")," block data structure is used to hold an attribute in memory. Since an attribute can have either ",(0,r.kt)("inlineCode",{parentName:"p"},"NUMBER")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"STRING")," type, ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("inlineCode",{parentName:"strong"},"Attribute"))," is a ",(0,r.kt)("em",{parentName:"p"},"union")," containing the two types. The size of an Attribute variable is fixed at ",(0,r.kt)("strong",{parentName:"p"},"16 bytes"),". A ",(0,r.kt)("inlineCode",{parentName:"p"},"**record**")," will be an array of Attribute whose size is equal to the number of attributes in the relation."),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("p",{parentName:"admonition"},"Attribute is the fundamental unit of data in a record. Hence, the ",(0,r.kt)("inlineCode",{parentName:"p"},"Attribute")," data structure is used in several functions of NITCbase.")),(0,r.kt)("p",null,"The definition for ",(0,r.kt)("inlineCode",{parentName:"p"},"union Attribute")," is given below:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"union Attribute {\n    double nVal;\n    char sVal[ATTR_SIZE];\n};\n")),(0,r.kt)("h3",{id:"internalentry"},"InternalEntry"),(0,r.kt)("p",null,"Each ",(0,r.kt)("strong",{parentName:"p"},"Internal Index")," block of a ",(0,r.kt)("em",{parentName:"p"},"B+ Tree")," consists of many ",(0,r.kt)("em",{parentName:"p"},"attribute values")," and the ",(0,r.kt)("em",{parentName:"p"},"child pointers"),". This data is arranged in the block in such a way that an attribute value is stored ",(0,r.kt)("strong",{parentName:"p"},"between")," its left child and right child pointers."),(0,r.kt)("admonition",{title:"Note",type:"info"},(0,r.kt)("p",{parentName:"admonition"},"The ",(0,r.kt)("inlineCode",{parentName:"p"},"right child pointer")," of one attribute value will be the ",(0,r.kt)("strong",{parentName:"p"},"same")," as the ",(0,r.kt)("inlineCode",{parentName:"p"},"left child pointer")," of the next attribute value. Hence to avoid redundancy, only one copy is stored, ",(0,r.kt)("em",{parentName:"p"},"making the data overlapped."))),(0,r.kt)("p",null,"The combination of ",(0,r.kt)("inlineCode",{parentName:"p"},"left child"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"attribute value"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"right child")," makes up the ",(0,r.kt)("inlineCode",{parentName:"p"},"InternalEntry")," structure, as shown below. An Internal Index block is a combination of ",(0,r.kt)("inlineCode",{parentName:"p"},"100 such overlapped entries"),". The ",(0,r.kt)("inlineCode",{parentName:"p"},"getEntry()")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"setEntry()")," methods of the class ",(0,r.kt)("inlineCode",{parentName:"p"},"IndInternal")," take a pointer to struct ",(0,r.kt)("inlineCode",{parentName:"p"},"InternalEntry")," as an argument."),(0,r.kt)("admonition",{title:"Implementation Note",type:"caution"},(0,r.kt)("p",{parentName:"admonition"},"The ",(0,r.kt)("inlineCode",{parentName:"p"},"getEntry()")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"setEntry()")," methods are declared in the ",(0,r.kt)("inlineCode",{parentName:"p"},"class IndBuffer")," but are overridden in the ",(0,r.kt)("inlineCode",{parentName:"p"},"class IndInternal"),". ",(0,r.kt)("inlineCode",{parentName:"p"},"getEntry()")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"setEntry()")," methods expect the higher layers to allocate memory for struct InternalEntry before calling them.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"struct InternalEntry {\n    int32_t lChild;\n    union Attribute attrVal;\n    int32_t rChild;\n};\n/* #include <cstdint> must be done */\n")),(0,r.kt)("h3",{id:"index"},"Index"),(0,r.kt)("p",null,"An ",(0,r.kt)("em",{parentName:"p"},"index")," of a relation should store a reference to its record along with the corresponding attribute value. NITCbase uses ",(0,r.kt)("inlineCode",{parentName:"p"},"**RecId**"),", which is a ",(0,r.kt)("inlineCode",{parentName:"p"},"(block#, slot#)")," pair, for referencing any record. In NITCbase, an ",(0,r.kt)("inlineCode",{parentName:"p"},"Index")," structure is a combination of ",(0,r.kt)("inlineCode",{parentName:"p"},"attribute value"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"block#"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"slot#"),", followed by some unused space left for future use, as shown below."),(0,r.kt)("p",null,"Each ",(0,r.kt)("inlineCode",{parentName:"p"},"Leaf Index block")," is a combination of ",(0,r.kt)("strong",{parentName:"p"},"63 such Index entries"),". The ",(0,r.kt)("inlineCode",{parentName:"p"},"getEntry()")," and the ",(0,r.kt)("inlineCode",{parentName:"p"},"setEntry()")," methods of the ",(0,r.kt)("inlineCode",{parentName:"p"},"class IndLeaf")," take a pointer to ",(0,r.kt)("inlineCode",{parentName:"p"},"struct Index")," as an argument."),(0,r.kt)("admonition",{title:"Implementation Note",type:"caution"},(0,r.kt)("p",{parentName:"admonition"},"The ",(0,r.kt)("inlineCode",{parentName:"p"},"getEntry()")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"setEntry()")," methods are declared in the ",(0,r.kt)("inlineCode",{parentName:"p"},"class IndBuffer")," but are overridden in the ",(0,r.kt)("inlineCode",{parentName:"p"},"class LeafBuffer"),". ",(0,r.kt)("inlineCode",{parentName:"p"},"getEntry()")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"setEntry()")," methods expect the higher layers to allocate memory for ",(0,r.kt)("inlineCode",{parentName:"p"},"struct Index")," before calling them.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"struct Index {\n    union Attribute attrVal;\n    int32_t block;\n    int32_t slot;\n    unsigned char unused[8];\n};\n/* #include <cstdint> must be done */\n")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"buffer-structure"},"Buffer Structure"),(0,r.kt)("p",null,"The Buffer Layer also defines a ",(0,r.kt)("em",{parentName:"p"},"buffer")," structure. ",(0,r.kt)("inlineCode",{parentName:"p"},"StaticBuffer class")," maintains meta-information for each block loaded to a buffer."),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"BufferMetaInfo")," structure is used for storing this meta-information. This structure contains ",(0,r.kt)("strong",{parentName:"p"},"four fields"),": a ",(0,r.kt)("inlineCode",{parentName:"p"},"free flag")," which indicates whether the buffer is occupied, a ",(0,r.kt)("inlineCode",{parentName:"p"},"dirty flag")," which indicates whether the block has been modified, a ",(0,r.kt)("inlineCode",{parentName:"p"},"blockNum")," field which is the block number of the block that is stored in the given buffer and a ",(0,r.kt)("inlineCode",{parentName:"p"},"timeStamp")," field which indicates the last time the buffer had been accessed."),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"Block Replacement")," is done using a simple ",(0,r.kt)("strong",{parentName:"p"},"Least Recently Used (LRU)")," algorithm, which has been implemented in the ",(0,r.kt)("inlineCode",{parentName:"p"},"getFreeBuffer()")," method. The ",(0,r.kt)("inlineCode",{parentName:"p"},"timeStamp")," field has to be updated each time the buffer is accessed, as is done in the ",(0,r.kt)("inlineCode",{parentName:"p"},"getBufferPtr()")," method."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"struct BufferMetaInfo {\n    bool free;\n    bool dirty;\n    int blockNum;\n    int timeStamp;\n};\n")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"miscellaneous"},"Miscellaneous"),(0,r.kt)("p",null,"Given below are the definitions of RecId and IndexId structures. Variables of these structures will be of use in several layers of NITCbase, such as ",(0,r.kt)("a",{parentName:"p",href:"/docs/Design/Cache%20Layer/intro"},"Cache layer"),", ",(0,r.kt)("a",{parentName:"p",href:"/docs/Design/Block%20Access%20Layer"},"Block access layer")," and ",(0,r.kt)("a",{parentName:"p",href:"/docs/Design/B+%20Tree%20Layer"},"B+ tree")," layer, to name a few."),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"The code for RecId struct and IndexId struct can be found in the ",(0,r.kt)("inlineCode",{parentName:"p"},"id.h")," file defined inside ",(0,r.kt)("inlineCode",{parentName:"p"},"define/")," directory.")),(0,r.kt)("h3",{id:"recid"},"RecId"),(0,r.kt)("p",null,"Relations in NITCbase are made up of records. Every record of any relation can be referenced using an id called ",(0,r.kt)("inlineCode",{parentName:"p"},"RecId"),". ",(0,r.kt)("inlineCode",{parentName:"p"},"RecId")," is a combination of the block number of the corresponding record block and the slot number of the slot occupied by the record in the block. It is used to locate where the record is stored in the disk."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"struct RecId {\n    int block;\n    int slot;\n};\n")),(0,r.kt)("h3",{id:"indexid"},"IndexId"),(0,r.kt)("p",null,"The Leaf Index blocks of a B+ Tree are made of ",(0,r.kt)("a",{parentName:"p",href:"#index"},"Index")," entries. Every ",(0,r.kt)("em",{parentName:"p"},"Index")," entry of any ",(0,r.kt)("em",{parentName:"p"},"Leaf Index")," block can be referenced using an id called ",(0,r.kt)("inlineCode",{parentName:"p"},"IndexId"),". It is a combination of block number of the corresponding leaf index block and index number, which is the offset of the index in that block. It is used to locate where the index is stored in the disk."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"struct IndexId {\n    int block;\n    int index;\n};\n")),(0,r.kt)("h3",{id:"compareattrs"},"compareAttrs()"),(0,r.kt)("h4",{id:"description"},"Description"),(0,r.kt)("p",null,"This function compares two ",(0,r.kt)("a",{parentName:"p",href:"#attribute"},(0,r.kt)("inlineCode",{parentName:"a"},"union Attribute"))," values on the basis of the input attribute type."),(0,r.kt)("h4",{id:"arguments"},"Arguments"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Name")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Type")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Description")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"attr1"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"#attribute"},(0,r.kt)("inlineCode",{parentName:"a"},"union Attribute"))),(0,r.kt)("td",{parentName:"tr",align:null},"First attribute value to be compared.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"attr2"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"#attribute"},(0,r.kt)("inlineCode",{parentName:"a"},"union Attribute"))),(0,r.kt)("td",{parentName:"tr",align:null},"Second attribute value to be compared.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"attrType"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"int")),(0,r.kt)("td",{parentName:"tr",align:null},"Type of the attribute ",(0,r.kt)("a",{parentName:"td",href:"/docs/constants"},(0,r.kt)("inlineCode",{parentName:"a"},"NUMBER"),"/",(0,r.kt)("inlineCode",{parentName:"a"},"STRING")),".")))),(0,r.kt)("h4",{id:"return-values"},"Return Values"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Value")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Description")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Negative integer"),(0,r.kt)("td",{parentName:"tr",align:null},"Value in ",(0,r.kt)("inlineCode",{parentName:"td"},"attr1")," is ",(0,r.kt)("strong",{parentName:"td"},"less")," than the value in ",(0,r.kt)("inlineCode",{parentName:"td"},"attr2"),".")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Zero"),(0,r.kt)("td",{parentName:"tr",align:null},"Value in ",(0,r.kt)("inlineCode",{parentName:"td"},"attr1")," is ",(0,r.kt)("strong",{parentName:"td"},"equal")," to the value in ",(0,r.kt)("inlineCode",{parentName:"td"},"attr2"),".")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Positive integer"),(0,r.kt)("td",{parentName:"tr",align:null},"Value in ",(0,r.kt)("inlineCode",{parentName:"td"},"attr1")," is ",(0,r.kt)("strong",{parentName:"td"},"greater")," than the value in ",(0,r.kt)("inlineCode",{parentName:"td"},"attr2"),".")))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"int compare(union Attribute attr1, union Attribute attr2, int attrType) {\n\n    /*  if attrType == STRING\n            return strcmp(attr1.sval, attr2.sval); */\n\n    /* else\n          return attr1.nval - attr2.nval */\n\n}\n")),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("ul",{parentName:"admonition"},(0,r.kt)("li",{parentName:"ul"},"Both the attributes given as input must be of the same type as the input type."),(0,r.kt)("li",{parentName:"ul"},"For string type, the comparision is performed with respect to ",(0,r.kt)("em",{parentName:"li"},"lexicographic order"),"."))))}c.isMDXComponent=!0}}]);