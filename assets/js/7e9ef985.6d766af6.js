"use strict";(self.webpackChunknitcbase=self.webpackChunknitcbase||[]).push([[7452],{3905:(e,t,a)=>{a.d(t,{Zo:()=>p,kt:()=>u});var n=a(7294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function o(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function l(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?o(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},o=Object.keys(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var i=n.createContext({}),m=function(e){var t=n.useContext(i),a=t;return e&&(a="function"==typeof e?e(t):l(l({},t),e)),a},p=function(e){var t=m(e.components);return n.createElement(i.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},d=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,o=e.originalType,i=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),d=m(a),u=r,h=d["".concat(i,".").concat(u)]||d[u]||c[u]||o;return a?n.createElement(h,l(l({ref:t},p),{},{components:a})):n.createElement(h,l({ref:t},p))}));function u(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=a.length,l=new Array(o);l[0]=d;var s={};for(var i in t)hasOwnProperty.call(t,i)&&(s[i]=t[i]);s.originalType=e,s.mdxType="string"==typeof e?e:r,l[1]=s;for(var m=2;m<o;m++)l[m]=a[m];return n.createElement.apply(null,l)}return n.createElement.apply(null,a)}d.displayName="MDXCreateElement"},4968:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>i,contentTitle:()=>l,default:()=>c,frontMatter:()=>o,metadata:()=>s,toc:()=>m});var n=a(7462),r=(a(7294),a(3905));const o={title:"Stage 2: Record Blocks and Catalogs"},l="Stage 2: Record Blocks and Catalogs (6 hours)",s={unversionedId:"Roadmap/Stage02",id:"Roadmap/Stage02",title:"Stage 2: Record Blocks and Catalogs",description:"- Understand the storage model for records in NITCbase",source:"@site/docs/Roadmap/Stage02.md",sourceDirName:"Roadmap",slug:"/Roadmap/Stage02",permalink:"/docs/Roadmap/Stage02",draft:!1,tags:[],version:"current",frontMatter:{title:"Stage 2: Record Blocks and Catalogs"},sidebar:"Roadmap",previous:{title:"Stage 1 : Understanding the Disk Interface",permalink:"/docs/Roadmap/Stage01"},next:{title:"Stage 3 : The Disk Buffer and Catalog Caches",permalink:"/docs/Roadmap/Stage03"}},i={},m=[{value:"Introduction",id:"introduction",level:2},{value:"Creating Relations",id:"creating-relations",level:2},{value:"Displaying the Relations",id:"displaying-the-relations",level:2},{value:"Exercises",id:"exercises",level:2}],p={toc:m};function c(e){let{components:t,...a}=e;return(0,r.kt)("wrapper",(0,n.Z)({},p,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"stage-2-record-blocks-and-catalogs-6-hours"},"Stage 2: Record Blocks and Catalogs (6 hours)"),(0,r.kt)("admonition",{title:"Learning Objectives",type:"note"},(0,r.kt)("ul",{parentName:"admonition"},(0,r.kt)("li",{parentName:"ul"},"Understand the storage model for ",(0,r.kt)("strong",{parentName:"li"},"records")," in NITCbase"),(0,r.kt)("li",{parentName:"ul"},"Understand the structure of the ",(0,r.kt)("strong",{parentName:"li"},"relation catalog")," and ",(0,r.kt)("strong",{parentName:"li"},"attribute catalog")),(0,r.kt)("li",{parentName:"ul"},"Learn to ",(0,r.kt)("strong",{parentName:"li"},"create relations")," using the XFS interface"),(0,r.kt)("li",{parentName:"ul"},"Implement a program to ",(0,r.kt)("strong",{parentName:"li"},"display the names and attributes of all the relations")," in the database by reading the catalogs"))),(0,r.kt)("h2",{id:"introduction"},"Introduction"),(0,r.kt)("p",null,"The main purpose of a relational database is to store and retrieve records. When we initially start adding entries to a database, we can obtain a random free disk block and start dumping the values into it one after another and we can traverse it just as easily. But, we are soon going to run out of space on the disk block. What will we do then? We'll get another random disk block and continue our process. But there's now a complication. How will we traverse between these two disk blocks while reading these entries. Clearly, we'll need to store the preceding and following disk block as some metadata in each block. You might've realized that this is in fact just a linked list and you're right. Records in NITCbase are stored in a linked list of disk blocks."),(0,r.kt)("p",null,"Now, what exactly is a ",(0,r.kt)("strong",{parentName:"p"},"record"),"? It is just an array of ",(0,r.kt)("strong",{parentName:"p"},"attribute values"),". Each relation can have a different number of attributes and the total number of records per disk block of a relation varies based on that. Each record block is divided into ",(0,r.kt)("strong",{parentName:"p"},"slots")," of variable record size and each slot stores a single record."),(0,r.kt)("p",null,"So, now we have a lot of relations each having their own records stored on the disk across multiple blocks. How do we identify and organise these blocks? The ",(0,r.kt)("strong",{parentName:"p"},"relation catalog")," solves this problem in NITCbase. It stores the relation name, the number of attributes and other information related to the record blocks for all the relations in the database."),(0,r.kt)("p",null,"We now have a provision to keep track of the list of relations that we have stored in the database. But we don't have any information regarding the attributes of each relation. In a production database, an attribute can be one of a myriad of possible types, but here in NITCbase, we'll restrict that to two possible ",(0,r.kt)("strong",{parentName:"p"},"types"),": ",(0,r.kt)("inlineCode",{parentName:"p"},"NUM")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"STR"),". Numbers and strings, as the name would suggest. Both of these types are fixed at a size ",(0,r.kt)("strong",{parentName:"p"},"16 bytes")," for the sake of simplicity. The ",(0,r.kt)("strong",{parentName:"p"},"attribute catalog")," stores these details of all the attributes of every relation in the database. It also stores details about indices created on attributes. We'll get into the details of indexing later."),(0,r.kt)("p",null,"The relation catalog and attribute catalog together allows us to get all the relations and their respective schemas from our disk. If you didn't realise it yet, the relation and attribute catalog themselves are just relations on our disk! And as such, the blocks storing all the data we mentioned are just record blocks. ",(0,r.kt)("em",{parentName:"p"},"The first entry of the relation catalog is that of the relation catalog itself. The second entry is for the attribute catalog. And the first entries in the attribute catalog are the attributes of the relation catalog and the attributes of itself.")," Recall the ",(0,r.kt)("a",{parentName:"p",href:"/docs/Design/Physical%20Layer#disk-model"},"Disk Model")," where you read that the first few blocks are reserved for these data structures."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Read the documentation for ",(0,r.kt)("a",{parentName:"strong",href:"/docs/Design/Physical%20Layer#record-block-structure"},"record blocks")," and ",(0,r.kt)("a",{parentName:"strong",href:"/docs/Design/Physical%20Layer#catalog-structures"},"catalog structures")," before proceeding further.")),(0,r.kt)("details",null,(0,r.kt)("summary",null,"Q. Consider the following catalog entries and record for a relation.",(0,r.kt)("table",null,(0,r.kt)("thead",null,(0,r.kt)("tr",null,(0,r.kt)("th",{colspan:"6"},"Relation Catalog Entry"))),(0,r.kt)("tbody",null,(0,r.kt)("tr",null,(0,r.kt)("th",null,"RelName")," ",(0,r.kt)("th",null,"#Attrs")," ",(0,r.kt)("th",null,"#Records")," ",(0,r.kt)("th",null,"FirstBlock")," ",(0,r.kt)("th",null,"LastBlock")," ",(0,r.kt)("th",null,"#Slots")),(0,r.kt)("tr",null,(0,r.kt)("td",null,"Students")," ",(0,r.kt)("td",null,"?")," ",(0,r.kt)("td",null,"?")," ",(0,r.kt)("td",null,"34")," ",(0,r.kt)("td",null,"35")," ",(0,r.kt)("td",null,"?")))),(0,r.kt)("table",null,(0,r.kt)("thead",null,(0,r.kt)("tr",null,(0,r.kt)("th",{colspan:"6"},"Attribute Catalog Entry"))),(0,r.kt)("tbody",null,(0,r.kt)("tr",null,(0,r.kt)("th",null,"RelName")," ",(0,r.kt)("th",null,"AttrName")," ",(0,r.kt)("th",null,"AttrType")," ",(0,r.kt)("th",null,"PrimaryFlag")," ",(0,r.kt)("th",null,"RootBlock")," ",(0,r.kt)("th",null,"Offset")),(0,r.kt)("tr",null,(0,r.kt)("td",null,"Students")," ",(0,r.kt)("td",null,"Name")," ",(0,r.kt)("td",null,"?")," ",(0,r.kt)("td",null,"-")," ",(0,r.kt)("td",null,"-1")," ",(0,r.kt)("td",null,"?")),(0,r.kt)("tr",null,(0,r.kt)("td",null,"Students")," ",(0,r.kt)("td",null,"RollNo")," ",(0,r.kt)("td",null,"?")," ",(0,r.kt)("td",null,"-")," ",(0,r.kt)("td",null,"-1")," ",(0,r.kt)("td",null,"?")),(0,r.kt)("tr",null,(0,r.kt)("td",null,"Students")," ",(0,r.kt)("td",null,"Marks")," ",(0,r.kt)("td",null,"?")," ",(0,r.kt)("td",null,"-")," ",(0,r.kt)("td",null,"-1")," ",(0,r.kt)("td",null,"?")))),(0,r.kt)("table",null,(0,r.kt)("thead",null,(0,r.kt)("tr",null,(0,r.kt)("th",{colspan:"6"},"section from the record block"))),(0,r.kt)("tbody",null,(0,r.kt)("tr",null,(0,r.kt)("td",null,"...")," ",(0,r.kt)("td",null,"B190539CS")," ",(0,r.kt)("td",null,"Jacques")," ",(0,r.kt)("td",null,"91.08")," ",(0,r.kt)("td",null,"...")))),(0,r.kt)("p",null,"Assume that the relation has only two record blocks and both are fully filled. Find all the missing values (marked with ",(0,r.kt)("inlineCode",{parentName:"p"},"?"),")."),(0,r.kt)("p",null,"(click to view answer)")),(0,r.kt)("p",null,"Since we have three entries in the attribute catalog, we can conclude that ",(0,r.kt)("inlineCode",{parentName:"p"},"#Attrs")," = 3."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"#Slots")," = ",(0,r.kt)("span",{parentName:"p",className:"math math-inline"},(0,r.kt)("span",{parentName:"span",className:"katex"},(0,r.kt)("span",{parentName:"span",className:"katex-mathml"},(0,r.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,r.kt)("semantics",{parentName:"math"},(0,r.kt)("mrow",{parentName:"semantics"},(0,r.kt)("mrow",{parentName:"mrow"},(0,r.kt)("mo",{parentName:"mrow",fence:"true"},"\u230a"),(0,r.kt)("mfrac",{parentName:"mrow"},(0,r.kt)("mn",{parentName:"mfrac"},"2016"),(0,r.kt)("mrow",{parentName:"mfrac"},(0,r.kt)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,r.kt)("mn",{parentName:"mrow"},"16"),(0,r.kt)("mo",{parentName:"mrow"},"\u2217"),(0,r.kt)("mn",{parentName:"mrow"},"3"),(0,r.kt)("mo",{parentName:"mrow",stretchy:"false"},")"),(0,r.kt)("mo",{parentName:"mrow"},"+"),(0,r.kt)("mn",{parentName:"mrow"},"1"))),(0,r.kt)("mo",{parentName:"mrow",fence:"true"},"\u230b")),(0,r.kt)("mo",{parentName:"mrow"},"="),(0,r.kt)("mn",{parentName:"mrow"},"41")),(0,r.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"\\left \\lfloor \\frac{2016}{(16*3)+1} \\right \\rfloor = 41")))),(0,r.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"1.8em",verticalAlign:"-0.65em"}}),(0,r.kt)("span",{parentName:"span",className:"minner"},(0,r.kt)("span",{parentName:"span",className:"mopen delimcenter",style:{top:"0em"}},(0,r.kt)("span",{parentName:"span",className:"delimsizing size2"},"\u230a")),(0,r.kt)("span",{parentName:"span",className:"mord"},(0,r.kt)("span",{parentName:"span",className:"mopen nulldelimiter"}),(0,r.kt)("span",{parentName:"span",className:"mfrac"},(0,r.kt)("span",{parentName:"span",className:"vlist-t vlist-t2"},(0,r.kt)("span",{parentName:"span",className:"vlist-r"},(0,r.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.8451em"}},(0,r.kt)("span",{parentName:"span",style:{top:"-2.655em"}},(0,r.kt)("span",{parentName:"span",className:"pstrut",style:{height:"3em"}}),(0,r.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,r.kt)("span",{parentName:"span",className:"mord mtight"},(0,r.kt)("span",{parentName:"span",className:"mopen mtight"},"("),(0,r.kt)("span",{parentName:"span",className:"mord mtight"},"16"),(0,r.kt)("span",{parentName:"span",className:"mbin mtight"},"\u2217"),(0,r.kt)("span",{parentName:"span",className:"mord mtight"},"3"),(0,r.kt)("span",{parentName:"span",className:"mclose mtight"},")"),(0,r.kt)("span",{parentName:"span",className:"mbin mtight"},"+"),(0,r.kt)("span",{parentName:"span",className:"mord mtight"},"1")))),(0,r.kt)("span",{parentName:"span",style:{top:"-3.23em"}},(0,r.kt)("span",{parentName:"span",className:"pstrut",style:{height:"3em"}}),(0,r.kt)("span",{parentName:"span",className:"frac-line",style:{borderBottomWidth:"0.04em"}})),(0,r.kt)("span",{parentName:"span",style:{top:"-3.394em"}},(0,r.kt)("span",{parentName:"span",className:"pstrut",style:{height:"3em"}}),(0,r.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,r.kt)("span",{parentName:"span",className:"mord mtight"},(0,r.kt)("span",{parentName:"span",className:"mord mtight"},"2016"))))),(0,r.kt)("span",{parentName:"span",className:"vlist-s"},"\u200b")),(0,r.kt)("span",{parentName:"span",className:"vlist-r"},(0,r.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.52em"}},(0,r.kt)("span",{parentName:"span"}))))),(0,r.kt)("span",{parentName:"span",className:"mclose nulldelimiter"})),(0,r.kt)("span",{parentName:"span",className:"mclose delimcenter",style:{top:"0em"}},(0,r.kt)("span",{parentName:"span",className:"delimsizing size2"},"\u230b"))),(0,r.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2778em"}}),(0,r.kt)("span",{parentName:"span",className:"mrel"},"="),(0,r.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2778em"}})),(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"0.6444em"}}),(0,r.kt)("span",{parentName:"span",className:"mord"},"41")))))),(0,r.kt)("p",null,"Given that there are two fully filled records, ",(0,r.kt)("inlineCode",{parentName:"p"},"#Records")," = 82."),(0,r.kt)("p",null,"From looking at the record block, we can infer the attribute catalog entries as so."),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"AttrName"),(0,r.kt)("th",{parentName:"tr",align:null},"AttrType"),(0,r.kt)("th",{parentName:"tr",align:null},"Offset"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Name"),(0,r.kt)("td",{parentName:"tr",align:null},"STR"),(0,r.kt)("td",{parentName:"tr",align:null},"1")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"RollNo"),(0,r.kt)("td",{parentName:"tr",align:null},"STR"),(0,r.kt)("td",{parentName:"tr",align:null},"0")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Marks"),(0,r.kt)("td",{parentName:"tr",align:null},"NUM"),(0,r.kt)("td",{parentName:"tr",align:null},"2"))))),(0,r.kt)("h2",{id:"creating-relations"},"Creating Relations"),(0,r.kt)("p",null,"One of the critical features of a database is creating tables (relations). In NITCbase, we can use the ",(0,r.kt)("inlineCode",{parentName:"p"},"CREATE TABLE")," command to create a table. ",(0,r.kt)("strong",{parentName:"p"},"Read ",(0,r.kt)("a",{parentName:"strong",href:"/docs/User%20Interface%20Commands/ddl#create-table"},"the documentation")," for the command before proceeding further.")),(0,r.kt)("p",null,"At this stage, we will not be implementing this functionality and will instead be using the XFS Interface to do this operation. Recall that the XFS interface already implements all the functionality of NITCbase."),(0,r.kt)("p",null,"Switch to the ",(0,r.kt)("inlineCode",{parentName:"p"},"XFS_Interface")," folder and run ",(0,r.kt)("inlineCode",{parentName:"p"},"./xfs-interface")," to access the prompt. Once in the prompt, we'll create a relation as follows"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-plain"},"$ ./xfs-interface\n//highlight-start\n# CREATE TABLE Students(RollNumber STR, Name STR, Marks NUM, Class STR)\nRelation Students created successfully\n# exit\n//highlight-end\n")),(0,r.kt)("p",null,"We can verify the schema of the relation by running the ",(0,r.kt)("a",{parentName:"p",href:"/docs/User%20Interface%20Commands/efs#show-schema"},(0,r.kt)("inlineCode",{parentName:"a"},"schema")," command")," in the XFS Interface"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-plain"},"# schema Students\nRelation: Students\nAttribute        Type Index\n---------------- ---- -----\nRollNumber       STR  no\nName             STR  no\nMarks            NUM  no\nClass            STR  no\n")),(0,r.kt)("h2",{id:"displaying-the-relations"},"Displaying the Relations"),(0,r.kt)("p",null,"We have some relations in our DBMS now. Let's try to implement a way to see all the relations we created. To see the details of a relation, we just need to read the records stored in the relation and attribute catalogs. How do we do that?"),(0,r.kt)("admonition",{title:"A DIGRESSION",type:"info"},(0,r.kt)("sub",null,(0,r.kt)("p",{parentName:"admonition"},(0,r.kt)("strong",{parentName:"p"},"WARNING"),": This section is a quick detour to give you an overall picture of the experiment before we start with building it.\nThis section links to various pages of the documentation. You do not need to follow any of these at this stage and they are only provided for your information. Do not spend more than 15 minutes here.")),(0,r.kt)("p",{parentName:"admonition"},"A proper DBMS consists will implement a large number of operations. Here, we are starting with the implementation of one of the most rudimentary features of a relational database; printing the details of the relations. Before we get into that, let us take a quick look at the architecture of our database."),(0,r.kt)("p",{parentName:"admonition"},"NITCbase follows a 7-layer object oriented architecture. In the course of this project, you will be implementing all these layers. They are described below."),(0,r.kt)("ol",{parentName:"admonition"},(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("a",{parentName:"li",href:"/docs/Design/Algebra%20Layer"},(0,r.kt)("strong",{parentName:"a"},"Algebra Layer")),": Handles the high level relational algebraic operations of our database"),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("a",{parentName:"li",href:"/docs/Design/Schema%20Layer"},(0,r.kt)("strong",{parentName:"a"},"Schema Layer")),": Handles the schema operations such as creation, deletion"),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("a",{parentName:"li",href:"/docs/Design/Block%20Access%20Layer"},(0,r.kt)("strong",{parentName:"a"},"Block Access Layer")),": Handles high-level operations on the disk such as search and insert"),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("a",{parentName:"li",href:"/docs/Design/B+%20Tree%20Layer"},(0,r.kt)("strong",{parentName:"a"},"B+ Tree Layer")),": Handles all index related operations."),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("a",{parentName:"li",href:"/docs/Design/Cache%20Layer"},(0,r.kt)("strong",{parentName:"a"},"Cache Layer")),": Handles caching of the relation and attribute catalog"),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("a",{parentName:"li",href:"/docs/Design/Buffer%20Layer"},(0,r.kt)("strong",{parentName:"a"},"Buffer Layer")),": Handles buffered operations on all disk blocks"),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("a",{parentName:"li",href:"/docs/Design/Physical%20Layer"},(0,r.kt)("strong",{parentName:"a"},"Physical Layer")),": Provides the low-level operations on the disk blocks.")),(0,r.kt)("p",{parentName:"admonition"},"We also have a ",(0,r.kt)("a",{parentName:"p",href:"/docs/Design/Frontend"},(0,r.kt)("strong",{parentName:"a"},"frontend interface"))," which is responsible for interacting with the user, receiving the commands, and translating them to the appropriate function in the Schema/Algebra layer. Most of this layer has already been implemented and provided to you. You will only need to make minor additions to this layer."),(0,r.kt)("p",{parentName:"admonition"},(0,r.kt)("strong",{parentName:"p"},"Read the ",(0,r.kt)("a",{parentName:"strong",href:"/"},"home page")," and ",(0,r.kt)("a",{parentName:"strong",href:"/docs/Design/Architecture"},"architecture page")," if you have not done so already."))),(0,r.kt)("p",null,"Let's come back to the task of displaying the relations on the database."),(0,r.kt)("p",null,"Since we want to handle the display of any number of relations, we need to be able to fetch the total number of relations on the disk. Where do we find this information? Recall that the header of each record block stores the number of entries in that block. Checking the header of the relation catalog block should give us this number. Once we have this value (let it be ",(0,r.kt)("inlineCode",{parentName:"p"},"N"),"), we can get the names of the relations by reading the records at the first ",(0,r.kt)("inlineCode",{parentName:"p"},"N")," slots of the relation catalog block. We will be implementing a rudimentary version of the ",(0,r.kt)("inlineCode",{parentName:"p"},"getHeader()")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"getRecord()")," function of the ",(0,r.kt)("a",{parentName:"p",href:"/docs/Design/Buffer%20Layer"},"Buffer Layer")," to do these operations."),(0,r.kt)("p",null,"A simplified class diagram with the functions we need to implement is shown below. The classes will eventually implement a lot of functionality of the ",(0,r.kt)("a",{parentName:"p",href:"/docs/Design/Buffer%20Layer"},"Buffer Layer"),". In this section, we will only implement a subset of the methods of ",(0,r.kt)("a",{parentName:"p",href:"/docs/Design/Buffer%20Layer#class-blockbuffer"},"BlockBuffer")," and ",(0,r.kt)("a",{parentName:"p",href:"/docs/Design/Buffer%20Layer#class-recbuffer"},"RecBuffer")," classes."),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},(0,r.kt)("strong",{parentName:"p"},"NOTE"),": The functions are denoted with circles as follows.",(0,r.kt)("br",null),"\n\ud83d\udd35 -> methods that are already in their final state",(0,r.kt)("br",null),"\n\ud83d\udfe2 -> methods that will attain their final state in this stage",(0,r.kt)("br",null),"\n\ud83d\udfe0 -> methods that we will modify in this stage, but will require more work")),(0,r.kt)("br",null),(0,r.kt)("mermaid",{value:"classDiagram\n  direction TD\n  BlockBuffer <|-- RecBuffer\n  BlockBuffer : -int blockNum\n  BlockBuffer : +BlockBuffer(int blockNum) \ud83d\udfe2\n  BlockBuffer : +getHeader(struct HeadInfo *head) int\ud83d\udfe0\n  class RecBuffer{\n    +RecBuffer(int blockNum) \ud83d\udfe2\n    +getRecord(union Attribute *rec, int slotNum) int\ud83d\udfe0\n  }"}),(0,r.kt)("br",null),(0,r.kt)("p",null,"We have two classes, ",(0,r.kt)("inlineCode",{parentName:"p"},"BlockBuffer")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"RecBuffer"),". An object of either of those classes allows us to work with a particular disk block (stored in the ",(0,r.kt)("inlineCode",{parentName:"p"},"blockNum")," member field). The ",(0,r.kt)("inlineCode",{parentName:"p"},"BlockBuffer")," class implements the common operations available to all disk blocks. The ",(0,r.kt)("inlineCode",{parentName:"p"},"RecBuffer")," class extends ",(0,r.kt)("inlineCode",{parentName:"p"},"BlockBuffer")," to add functionality specific to a record block. We will implement the ",(0,r.kt)("inlineCode",{parentName:"p"},"BlockBuffer::getHeader()")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"RecBuffer::getRecord()")," functions using the disk read and write operations that we covered in the previous stage. ",(0,r.kt)("strong",{parentName:"p"},"Note that these functions will assume that memory for its arguments has been already allocated by the calling function.")),(0,r.kt)("p",null,"We will also be making use of two data structures for representing the data. ",(0,r.kt)("strong",{parentName:"p"},"Read the documentation for ",(0,r.kt)("a",{parentName:"strong",href:"/docs/Design/Buffer%20Layer#headinfo"},"struct HeadInfo")," and ",(0,r.kt)("a",{parentName:"strong",href:"/docs/Design/Buffer%20Layer#attribute"},"union Attribute")," before proceeding further.")),(0,r.kt)("admonition",{title:"NOTE",type:"info"},(0,r.kt)("p",{parentName:"admonition"},"All commonly used values have already been defined as ",(0,r.kt)("a",{parentName:"p",href:"/constants"},"constants")," and can be used throughout your implementation.")),(0,r.kt)("br",null),(0,r.kt)("p",null,"Let us edit our ",(0,r.kt)("inlineCode",{parentName:"p"},"main.cpp")," to see a top-down view on how to use these functions for our goal of printing all the relations on our DBMS."),(0,r.kt)("details",null,(0,r.kt)("summary",null,"main.cpp"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'int main(int argc, char *argv[]) {\n  Disk disk_run;\n\n  // create objects for the relation catalog and attribute catalog\n  RecBuffer relCatBuffer(RELCAT_BLOCK);\n  RecBuffer attrCatBuffer(ATTRCAT_BLOCK);\n\n  HeadInfo relCatHeader;\n  HeadInfo attrCatHeader;\n\n  // load the headers of both the blocks into relCatHeader and attrCatHeader.\n  // (we will implement these functions later)\n  relCatBuffer.getHeader(&relCatHeader);\n  attrCatBuffer.getHeader(&attrCatHeader);\n\n  for (/* i = 0 to total relation count */) {\n\n    Attribute relCatRecord[RELCAT_NO_ATTRS]; // will store the record from the relation catalog\n\n    relCatBuffer.getRecord(relCatRecord, i);\n\n    printf("Relation: %s\\n", relCatRecord[RELCAT_REL_NAME_INDEX].sVal);\n\n    for (/* j = 0 to number of entries in the attribute catalog */) {\n\n      // declare attrCatRecord and load the attribute catalog entry into it\n\n      if (/* attribute catalog entry corresponds to the current relation */) {\n        const char *attrType = attrCatRecord[ATTRCAT_ATTR_TYPE_INDEX].nVal == NUMBER ? "NUM" : "STR";\n        printf("  %s: %s\\n", /* get the attribute name */, attrType);\n      }\n    }\n    printf("\\n");\n  }\n\n  return 0;\n}\n'))),(0,r.kt)("p",null,"Now, let us implement the functions that we invoked from the ",(0,r.kt)("inlineCode",{parentName:"p"},"main()")," function. Open the ",(0,r.kt)("inlineCode",{parentName:"p"},"BlockAccess.cpp")," file in the ",(0,r.kt)("inlineCode",{parentName:"p"},"Buffer")," folder and complete the following."),(0,r.kt)("details",null,(0,r.kt)("summary",null,"Buffer/BlockBuffer.cpp"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"\nBlockBuffer::BlockBuffer(int blockNum) {\n  // initialise this.blockNum with the argument\n}\n\n// calls the parent class constructor\nRecBuffer::RecBuffer(int blockNum) : BlockBuffer::BlockBuffer(blockNum) {}\n\n// load the block header into the argument pointer\nint BlockBuffer::getHeader(struct HeadInfo *head) {\n  unsigned char buffer[BLOCK_SIZE];\n\n  // read the block at this.blockNum into the buffer\n\n  // populate the numEntries, numAttrs and numSlots fields in *head\n  memcpy(&head->numSlots, buffer + 24, 4);\n  memcpy(&head->numEntries, /* fill this */, 4);\n  memcpy(&head->numAttrs, /* fill this */, 4);\n  memcpy(&head->rblock, /* fill this */, 4);\n  memcpy(&head->lblock, /* fill this */, 4);\n\n  return SUCCESS;\n}\n\n// load the record at slotNum into the argument pointer\nint RecBuffer::getRecord(union Attribute *rec, int slotNum) {\n  struct HeadInfo head;\n\n  // get the header using this.getHeader() function\n\n  int attrCount = head.numAttrs;\n  int slotCount = head.numSlots;\n\n  // read the block at this.blockNum into a buffer\n\n  /* record at slotNum will be at offset HEADER_SIZE + slotMapSize + (recordSize * slotNum)\n     - each record will have size attrCount * ATTR_SIZE\n     - slotMap will be of size slotCount\n  */\n  int recordSize = attrCount * ATTR_SIZE;\n  unsigned char *slotPointer = /* calculate buffer + offset */;\n\n  // load the record into the rec data structure\n  memcpy(rec, slotPointer, recordSize);\n\n  return SUCCESS;\n}\n"))),(0,r.kt)("p",null,"On compiling (run ",(0,r.kt)("inlineCode",{parentName:"p"},"make"),") and executing this program, you should see the following output."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-plain"},"Relation: RELATIONCAT\n  RelName: STR\n  #Attributes: NUM\n  #Records: NUM\n  FirstBlock: NUM\n  LastBlock: NUM\n  #Slots: NUM\n\nRelation: ATTRIBUTECAT\n  RelName: STR\n  AttributeName: STR\n  AttributeType: NUM\n  PrimaryFlag: NUM\n  RootBlock: NUM\n  Offset: NUM\n\nRelation: Students\n  RollNumber: STR\n  Name: STR\n  Marks: NUM\n  Class: STR\n")),(0,r.kt)("p",null,"Try creating more relations using the XFS interface and you'll see the schema of all those relations when you run NITCbase."),(0,r.kt)("admonition",{type:"caution"},(0,r.kt)("p",{parentName:"admonition"},"The attribute catalog can span across multiple disk blocks. We are only reading from one block of the attribute catalog. If the total number of attributes exceeds 19 (Why?), another block will be allocated for the attribute catalog. Your code will have to be modified to read the other blocks if needed.")),(0,r.kt)("h2",{id:"exercises"},"Exercises"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Q1"),". Modify this program to read across multiple blocks of the attribute catalog. Insert the relations ",(0,r.kt)("em",{parentName:"p"},"Events(",(0,r.kt)("inlineCode",{parentName:"em"},"id"),": ",(0,r.kt)("inlineCode",{parentName:"em"},"NUM"),", ",(0,r.kt)("inlineCode",{parentName:"em"},"title"),": ",(0,r.kt)("inlineCode",{parentName:"em"},"STR"),", ",(0,r.kt)("inlineCode",{parentName:"em"},"location"),": ",(0,r.kt)("inlineCode",{parentName:"em"},"STR"),"), Locations(",(0,r.kt)("inlineCode",{parentName:"em"},"name"),": ",(0,r.kt)("inlineCode",{parentName:"em"},"STR"),", ",(0,r.kt)("inlineCode",{parentName:"em"},"capacity"),": ",(0,r.kt)("inlineCode",{parentName:"em"},"NUM"),")")," and ",(0,r.kt)("em",{parentName:"p"},"Participants(",(0,r.kt)("inlineCode",{parentName:"em"},"regNo"),": ",(0,r.kt)("inlineCode",{parentName:"em"},"NUM"),", ",(0,r.kt)("inlineCode",{parentName:"em"},"event"),": ",(0,r.kt)("inlineCode",{parentName:"em"},"STR"),")")," into the database using the XFS interface. Print the details using NITCbase. (Hint: the ",(0,r.kt)("inlineCode",{parentName:"p"},"rblock")," field in the header of the attribute catalog block gives the next block.)"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Q2"),". Modify the ",(0,r.kt)("inlineCode",{parentName:"p"},"main")," function to update the schema of the Student relation. Change the name of the ",(0,r.kt)("inlineCode",{parentName:"p"},"Class")," attribute to ",(0,r.kt)("inlineCode",{parentName:"p"},"Batch")," and confirm that the change has been made by printing the relation again."))}c.isMDXComponent=!0}}]);