"use strict";(self.webpackChunknitcbase=self.webpackChunknitcbase||[]).push([[5677],{3905:(e,t,a)=>{a.d(t,{Zo:()=>h,kt:()=>m});var n=a(7294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function l(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var s=n.createContext({}),c=function(e){var t=n.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):l(l({},t),e)),a},h=function(e){var t=c(e.components);return n.createElement(s.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},p=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,i=e.originalType,s=e.parentName,h=o(e,["components","mdxType","originalType","parentName"]),p=c(a),m=r,u=p["".concat(s,".").concat(m)]||p[m]||d[m]||i;return a?n.createElement(u,l(l({ref:t},h),{},{components:a})):n.createElement(u,l({ref:t},h))}));function m(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=a.length,l=new Array(i);l[0]=p;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o.mdxType="string"==typeof e?e:r,l[1]=o;for(var c=2;c<i;c++)l[c]=a[c];return n.createElement.apply(null,l)}return n.createElement.apply(null,a)}p.displayName="MDXCreateElement"},6707:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>s,contentTitle:()=>l,default:()=>d,frontMatter:()=>i,metadata:()=>o,toc:()=>c});var n=a(7462),r=(a(7294),a(3905));const i={sidebar_position:1,title:"Introduction"},l="Cache Layer",o={unversionedId:"Design/Cache Layer/intro",id:"Design/Cache Layer/intro",title:"Introduction",description:"The files corresponding to this layer can be found in the Cache directory. The code is to be written in the files RelCacheTable.cpp, AttrCacheTable.cpp and OpenRelTable.cpp. The declaration for the functions can be found in the respective header files RelCacheTable.h, AttrCacheTable.h and OpenRelTable.h.",source:"@site/docs/Design/Cache Layer/intro.md",sourceDirName:"Design/Cache Layer",slug:"/Design/Cache Layer/intro",permalink:"/docs/Design/Cache Layer/intro",draft:!1,tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1,title:"Introduction"},sidebar:"Design",previous:{title:"B+ Tree Layer",permalink:"/docs/Design/B+ Tree Layer"},next:{title:"class RelCacheTable",permalink:"/docs/Design/Cache Layer/RelCacheTable"}},s={},c=[{value:"Layout",id:"layout",level:2},{value:"relId",id:"relid",level:2},{value:"Relation Cache Table Structures",id:"relation-cache-table-structures",level:2},{value:"RelCatEntry",id:"relcatentry",level:3},{value:"RelCacheEntry",id:"relcacheentry",level:3},{value:"Attribute Cache Table Structures",id:"attribute-cache-table-structures",level:2},{value:"AttrCatEntry",id:"attrcatentry",level:3},{value:"AttrCacheEntry",id:"attrcacheentry",level:3},{value:"Open Relation Table Structure",id:"open-relation-table-structure",level:2},{value:"OpenRelTableMetaInfo",id:"openreltablemetainfo",level:3}],h={toc:c};function d(e){let{components:t,...i}=e;return(0,r.kt)("wrapper",(0,n.Z)({},h,i,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"cache-layer"},"Cache Layer"),(0,r.kt)("admonition",{title:"note",type:"info"},(0,r.kt)("p",{parentName:"admonition"},"The files corresponding to this layer can be found in the ",(0,r.kt)("inlineCode",{parentName:"p"},"Cache")," directory. The code is to be written in the files ",(0,r.kt)("inlineCode",{parentName:"p"},"RelCacheTable.cpp"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"AttrCacheTable.cpp")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"OpenRelTable.cpp"),". The declaration for the functions can be found in the respective header files ",(0,r.kt)("inlineCode",{parentName:"p"},"RelCacheTable.h"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"AttrCacheTable.h")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"OpenRelTable.h"),"."),(0,r.kt)("p",{parentName:"admonition"},(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("a",{parentName:"strong",href:"/docs/Misc/stub/cache"},"The stub code for these files can be found here")))),(0,r.kt)("h2",{id:"layout"},"Layout"),(0,r.kt)("p",null,"Almost all operations on a relation require access to its corresponding ",(0,r.kt)("strong",{parentName:"p"},"Relation Catalog")," and ",(0,r.kt)("strong",{parentName:"p"},"Attribute Catalog")," entries. NITCbase stores these catalogs as relations in the disk. To prevent multiple reads and write backs of the catalog blocks, the ",(0,r.kt)("em",{parentName:"p"},"Cache Layer")," ",(0,r.kt)("strong",{parentName:"p"},"caches")," the catalog blocks along with some extra metadata associated with the relation that allows faster and easier processing of operations such as search. The Cache Layer, thus, provides an interface for catalog access to the higher layers by hiding the storage and maintenance details of the catalogs. Cache Layer can cache a maximum of ",(0,r.kt)("a",{parentName:"p",href:"/docs/constants"},"MAX_OPEN")," number of relations at any given time."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"NITCbase requires that the relation be first loaded to cache memory before any operation is performed on it.")),(0,r.kt)("p",null,"Three tables are used by NITCbase for caching Catalogs - the ",(0,r.kt)("strong",{parentName:"p"},"Relation Cache Table")," for ",(0,r.kt)("em",{parentName:"p"},"Relation Catalog")," entries, the ",(0,r.kt)("strong",{parentName:"p"},"Attribute Cache Table")," for ",(0,r.kt)("em",{parentName:"p"},"Attribute Catalog")," entries and the ",(0,r.kt)("strong",{parentName:"p"},"Open Relation Table")," to keep track of the entries stored in the other two catalogs."),(0,r.kt)("p",null,"NITCbase follows an Object-Oriented design for Cache Layer. The class diagram is as shown below."),(0,r.kt)("mermaid",{value:"classDiagram\n    direction TD\n    RelCacheTable <|.. OpenRelTable : friend\n    AttrCacheTable <|.. OpenRelTable : friend\n\n    class RelCacheTable{\n        -relCache[MAX_OPEN] : RelCacheEntry*\n        -recordToRelCatEntry(union Attribute record[RELCAT_NO_ATTRS], RelCatEntry *relCatEntry)$ void\n        -relCatEntryToRecord(RelCatEntry *relCatEntry, union Attribute record[RELCAT_NO_ATTRS])$ void\n        +getRelCatEntry(int relId, RelCatEntry *relCatBuf)$ int\n        +setRelCatEntry(int relId, RelCatEntry *relCatBuf)$ int\n        +getSearchIndex(int relId, RecId *searchIndex)$ int\n        +setSearchIndex(int relId, RecId *searchIndex)$ int\n        +resetSearchIndex(int relId)$ int\n\n    }\n    class AttrCacheTable{\n        -attrCache[MAX_OPEN] : AttrCacheEntry*\n        -recordToAttrCatEntry(union Attribute record[ATTRCAT_NO_ATTRS], AttrCatEntry *attrCatEntry)$ void\n        -attrCatEntryToRecord(AttrCatEntry *attrCatEntry, union Attribute record[ATTRCAT_NO_ATTRS])$ void\n        +getAttrCatEntry(int relId, char attrName[ATTR_SIZE], AttrCatEntry *attrCatBuf)$ int\n        +getAttrCatEntry(int relId, int attrOffset, AttrCatEntry *attrCatBuf)$ int\n        +setAttrCatEntry(int relId, char attrName[ATTR_SIZE], AttrCatEntry *attrCatBuf)$ int\n        +setAttrCatEntry(int relId, int attrOffset, AttrCatEntry *attrCatBuf)$ int\n        +getSearchIndex(int relId, char attrName[ATTR_SIZE], IndexId *searchIndex)$ int\n        +getSearchIndex(int relId, int attrOffset, IndexId *searchIndex)$ int\n        +setSearchIndex(int relId, char attrName[ATTR_SIZE], IndexId *searchIndex)$ int\n        +setSearchIndex(int relId, int attrOffset, IndexId *searchIndex)$ int\n        +resetSearchIndex(int relId, char attrName[ATTR_SIZE])$ int\n        +resetSearchIndex(int relId, int attrOffset)$ int\n\n    }\n    class OpenRelTable{\n        -tableMetaInfo[MAX_OPEN] : OpenRelTableMetaInfo\n        -getFreeOpenRelTableEntry()$: int\n        +OpenRelTable()\n        +~OpenRelTable()\n        +getRelId(char relName[ATTR_SIZE])$ int\n        +openRel(char relName[ATTR_SIZE])$ int\n        +closeRel(int relId)$ int\n    }\n"}),(0,r.kt)("hr",null),(0,r.kt)("p",null,"Various structures used in the cache layer are outlined in the below diagrams."),(0,r.kt)("mermaid",{value:"classDiagram\n    class RelCacheEntry{\n        <<struct>>\n        +relCatEntry: RelCatEntry\n        +dirty: bool\n        +recId: RecId\n        +searchIndex: RecId\n    }\n    class AttrCacheEntry{\n        <<struct>>\n        +attrCatEntry: AttrCatEntry\n        +dirty: bool\n        +recId: RecId\n        +searchIndex: IndexId\n        +next: AttrCacheEntry*\n    }\n    class RelCatEntry{\n        <<struct>>\n        +relName[ATTR_SIZE]: char\n        +numAttrs: int\n        +numRecs: int\n        +firstBlk: int\n        +lastBlk: int\n        +numSlotsPerBlk: int\n    }\n    class AttrCatEntry{\n        <<struct>>\n        +relName[ATTR_SIZE]: char\n        +attrName[ATTR_SIZE]: char\n        +attrType: int\n        +primaryFlag: bool\n        +rootBlock: int\n        +offset: int\n    }\n    class OpenRelTableMetaInfo{\n        <<struct>>\n        +free: bool\n        +relName[ATTR_SIZE]: char\n    }\n"}),(0,r.kt)("h2",{id:"relid"},"relId"),(0,r.kt)("p",null,"Any relation that is stored in the cache memory will have an entry in each of the three tables- ",(0,r.kt)("strong",{parentName:"p"},"Relation Cache Table"),", ",(0,r.kt)("strong",{parentName:"p"},"Attribute Cache Table"),", and ",(0,r.kt)("strong",{parentName:"p"},"Open Relation Table"),". An ",(0,r.kt)("em",{parentName:"p"},"open relation")," is a relation that has been loaded to the cache memory while a ",(0,r.kt)("em",{parentName:"p"},"closed relation")," is one that is not loaded to the cache memory (hence it is only present in the disk). NITCbase is designed in such a way that the entries in all the three tables will be stored at the ",(0,r.kt)("strong",{parentName:"p"},"same index"),"."),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"This common index is called the ",(0,r.kt)("strong",{parentName:"em"},(0,r.kt)("inlineCode",{parentName:"strong"},"relId"))," of the relation and all further operations on the relation require this ",(0,r.kt)("inlineCode",{parentName:"em"},"relId"),".")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"relation-cache-table-structures"},"Relation Cache Table Structures"),(0,r.kt)("p",null,"The Relation Catalog block in the disk ",(0,r.kt)("strong",{parentName:"p"},"stores metadata corresponding to all the relations in the database"),". In addition to this, the ",(0,r.kt)("em",{parentName:"p"},"Relation Catalog")," entry of every open relation is loaded to the Relation Cache for easy access and for better performance. The Relation Cache is implemented in ",(0,r.kt)("a",{parentName:"p",href:"#class-relcachetable"},"class RelCacheTable"),". ",(0,r.kt)("em",{parentName:"p"},"Each entry in the Relation Cache stores all the attribute values of the relation's entry from the Relation Catalog along with some additional meta-data.")),(0,r.kt)("p",null,"NITCbase caches ",(0,r.kt)("em",{parentName:"p"},"Relation Catalog")," using two structures: ",(0,r.kt)("inlineCode",{parentName:"p"},"RelCatEntry")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"RelCacheEntry"),"."),(0,r.kt)("h3",{id:"relcatentry"},"RelCatEntry"),(0,r.kt)("p",null,"The structure ",(0,r.kt)("inlineCode",{parentName:"p"},"RelCatEntry")," stores all the attribute values in the relation's record entry from the ",(0,r.kt)("em",{parentName:"p"},"Relation Catalog")," block in its data fields."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"typedef struct RelCatEntry {\n\n    unsigned char relName[ATTR_SIZE];\n    int numAttrs;\n    int numRecs;\n    int firstBlk;\n    int lastBlk;\n    int numSlotsPerBlk;\n\n} RelCatEntry;\n")),(0,r.kt)("h3",{id:"relcacheentry"},"RelCacheEntry"),(0,r.kt)("p",null,"The structure ",(0,r.kt)("inlineCode",{parentName:"p"},"RelCacheEntry")," stores the ",(0,r.kt)("em",{parentName:"p"},"Relation Catalog")," entry of the relation along with some additonal information needed during runtime."),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"RelCacheEntry")," data field details are as follows:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"relCatEntry"),": Stores the relation's cached ",(0,r.kt)("em",{parentName:"li"},"Relation Catalog")," entry."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"dirty"),": Indicates whether the ",(0,r.kt)("em",{parentName:"li"},"Relation Catalog")," entry has been modified. The ",(0,r.kt)("em",{parentName:"li"},"Relation Catalog")," entries with the dirty bit set are written back to disk when an open relation is closed."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"recId"),": Stores the ",(0,r.kt)("em",{parentName:"li"},"record id")," ",(0,r.kt)("inlineCode",{parentName:"li"},"{blockNum, slotNum}")," of the relation's entry in the ",(0,r.kt)("em",{parentName:"li"},"Relation Catalog")," block on the disk. This is useful during the write back of the catalog entry to disk if it had been modified."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"searchIndex"),": Stores the ",(0,r.kt)("em",{parentName:"li"},"record id")," ",(0,r.kt)("inlineCode",{parentName:"li"},"{blockNum, slotNum}")," of the record block corresponding to the last (previous) search hit in the relation. Linear search algorithm of the Block Access Layer starts searching for the next hit from the previous hit location. The entries are initialized to ",(0,r.kt)("inlineCode",{parentName:"li"},"{-1, -1}")," each time the relation is loaded to the cache memory. When every record of the relation has been searched, the linear search algorithm resets the ",(0,r.kt)("inlineCode",{parentName:"li"},"searchIndex")," value to ",(0,r.kt)("inlineCode",{parentName:"li"},"{-1, -1}"),".")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"typedef struct RelCacheEntry {\n    RelCatEntry relCatEntry;\n    bool dirty;\n    RecId recId;\n    RecId searchIndex;\n\n} RelCacheEntry;\n")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"attribute-cache-table-structures"},"Attribute Cache Table Structures"),(0,r.kt)("p",null,"The ",(0,r.kt)("em",{parentName:"p"},"Attribute Catalog")," blocks, analogous to the ",(0,r.kt)("em",{parentName:"p"},"Relation Catalog")," block, stores the ",(0,r.kt)("strong",{parentName:"p"},"meta information of the attributes of all the relations in the database"),". In addition to this, the ",(0,r.kt)("em",{parentName:"p"},"Attribute Catalog")," entries of every open relation is also loaded to the cache memory. This is implemented using ",(0,r.kt)("em",{parentName:"p"},"Attribute Cache")," Table. ",(0,r.kt)("em",{parentName:"p"},"Each entry in the Attribute Cache Table stores the entries corresponding to each attribute of the relation in the form a ",(0,r.kt)("strong",{parentName:"em"},"linked list")," along with some additional meta-data.")),(0,r.kt)("p",null,"NITCbase caches ",(0,r.kt)("em",{parentName:"p"},"Attribute Catalog")," using two structures: ",(0,r.kt)("inlineCode",{parentName:"p"},"AttrCatEntry")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"AttrCacheEntry"),"."),(0,r.kt)("h3",{id:"attrcatentry"},"AttrCatEntry"),(0,r.kt)("p",null,"The structure ",(0,r.kt)("inlineCode",{parentName:"p"},"AttrCatEntry")," stores in its data fields all the attribute values in the record entry corresponding to one of the relation's attribute from an ",(0,r.kt)("em",{parentName:"p"},"Attribute Catalog")," block."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"typedef struct AttrCatEntry {\n    unsigned char relName[ATTR_SIZE];\n    unsigned char attrName[ATTR_SIZE];\n    int attrType;\n    bool primaryFlag;\n    int rootBlock;\n    int offset;\n\n} AttrCatEntry;\n")),(0,r.kt)("h3",{id:"attrcacheentry"},"AttrCacheEntry"),(0,r.kt)("p",null,"The structure ",(0,r.kt)("inlineCode",{parentName:"p"},"AttrCacheEntry")," stores the ",(0,r.kt)("em",{parentName:"p"},"Attribute Catalog")," entry of an attribute of the relation along with some additonal information used during runtime. Since a relation can have variable number of attributes, a linked list of ",(0,r.kt)("inlineCode",{parentName:"p"},"struct AttributeCacheEntry")," elements is maintained to cache all the ",(0,r.kt)("em",{parentName:"p"},"Attribute Catalog")," entries together."),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"AttrCacheEntry")," data field details are as follows:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"attrCatEntry"),": Stores the cached ",(0,r.kt)("em",{parentName:"li"},"Attribute Catalog")," entry corresponding to an attribute of the relation."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"dirty"),": Indicates whether the ",(0,r.kt)("em",{parentName:"li"},"Attribute Catalog")," entry has been modified. The ",(0,r.kt)("em",{parentName:"li"},"Attribute Catalog")," entries with the set dirty bit are written back to disk when an open relation is closed in the cache memory."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"recId"),": Stores the ",(0,r.kt)("em",{parentName:"li"},"record id")," ",(0,r.kt)("inlineCode",{parentName:"li"},"{blockNum, slotNum}")," of the record entry corresponding to the relation's attribute in the ",(0,r.kt)("em",{parentName:"li"},"Attribute Catalog")," block on the disk. This is useful during the write back of the catalog entry to disk if it had been modified."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"searchIndex"),": Stores the index id ",(0,r.kt)("inlineCode",{parentName:"li"},"{blockNum, indexNum}")," of the leaf index block corresponding to the last (previous) search hit for the attribute. This entry is used only if there is a B+ Tree created on the attribute. B+ Tree search algorithm of the B+ Tree Layer starts searching from the previous hit location for the next hit. The entries are initialized to ",(0,r.kt)("inlineCode",{parentName:"li"},"{-1, -1}")," each time the relation is opened in the cache memory. When every Index Leaf Block entry of the B+ Tree has been searched, B+ Tree search resets the searchIndex value to ",(0,r.kt)("inlineCode",{parentName:"li"},"{-1, -1}"),"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"next"),": Gives the pointer to the next ",(0,r.kt)("inlineCode",{parentName:"li"},"AttrCacheEntry")," element in the linked list.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"typedef struct AttrCacheEntry {\n    AttrCatEntry attrCatEntry;\n    bool dirty;\n    RecId recId;\n    IndexId searchIndex;\n    struct AttrCacheEntry *next;\n\n} AttrCacheEntry;\n")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"open-relation-table-structure"},"Open Relation Table Structure"),(0,r.kt)("p",null,"A relation must have an entry in the ",(0,r.kt)("em",{parentName:"p"},"Open Relation Table")," for its ",(0,r.kt)("em",{parentName:"p"},"Relation Catalog")," and ",(0,r.kt)("em",{parentName:"p"},"Attribute Catalog")," entries to be cached in the ",(0,r.kt)("em",{parentName:"p"},"Relation Cache Table")," and ",(0,r.kt)("em",{parentName:"p"},"Attribute Cache Table"),", respectively."),(0,r.kt)("h3",{id:"openreltablemetainfo"},"OpenRelTableMetaInfo"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"struct OpenRelTableMetaInfo")," stores whether the given entry in the ",(0,r.kt)("inlineCode",{parentName:"p"},"OpenRelTable"),", the ",(0,r.kt)("em",{parentName:"p"},"Relation Cache Table"),", and ",(0,r.kt)("em",{parentName:"p"},"Attribute Cache Table")," are occupied, and also stores the name of the relation if occupied."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"typedef struct OpenRelTableMetaInfo {\n    bool free;\n    unsigned char relName[ATTR_SIZE];\n\n} OpenRelTableMetaInfo;\n")),(0,r.kt)("hr",null),(0,r.kt)("p",null,"The following diagram summarizes the design of this module.\n",(0,r.kt)("img",{alt:"CacheTables",src:a(258).Z,width:"1462",height:"791"})),(0,r.kt)("hr",null))}d.isMDXComponent=!0},258:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/cache_tables-994f3c9d545bf5a5c14f59b90425b13d.png"}}]);