"use strict";(self.webpackChunknitcbase=self.webpackChunknitcbase||[]).push([[2853],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>u});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},l=Object.keys(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),h=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},d=function(e){var t=h(e.components);return a.createElement(s.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,l=e.originalType,s=e.parentName,d=o(e,["components","mdxType","originalType","parentName"]),c=h(n),u=r,m=c["".concat(s,".").concat(u)]||c[u]||p[u]||l;return n?a.createElement(m,i(i({ref:t},d),{},{components:n})):a.createElement(m,i({ref:t},d))}));function u(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var l=n.length,i=new Array(l);i[0]=c;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o.mdxType="string"==typeof e?e:r,i[1]=o;for(var h=2;h<l;h++)i[h]=n[h];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},6179:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>p,frontMatter:()=>l,metadata:()=>o,toc:()=>h});var a=n(7462),r=(n(7294),n(3905));const l={title:"class OpenRelTable",sidebar_position:4},i=void 0,o={unversionedId:"Design/Cache Layer/OpenRelTable",id:"Design/Cache Layer/OpenRelTable",title:"class OpenRelTable",description:"NITCbase requires that a relation be cached for the duration it is accessed to improve the processing time. The Open Relation Table is a data structure used as an interface for operations that accesses both Relation Cache and Attribute Cache together. The OpenRelTable class is used for this purpose. As per the NITCbase design, the ith entry of the OpenRelTable corresponds to the ith entry of the RelCacheTable and AttrCacheTable and is used to store the data of a single relation whose relation id is i. The public getRelId() method of the OpenRelTable returns the relation id of the input relation name.",source:"@site/docs/Design/Cache Layer/OpenRelTable.md",sourceDirName:"Design/Cache Layer",slug:"/Design/Cache Layer/OpenRelTable",permalink:"/docs/Design/Cache Layer/OpenRelTable",draft:!1,tags:[],version:"current",sidebarPosition:4,frontMatter:{title:"class OpenRelTable",sidebar_position:4},sidebar:"Design",previous:{title:"class AttrCacheTable",permalink:"/docs/Design/Cache Layer/AttrCacheTable"},next:{title:"Introduction",permalink:"/docs/Design/Buffer Layer/intro"}},s={},h=[{value:"OpenRelTable :: OpenRelTable (Constructor)",id:"openreltable--openreltable-constructor",level:3},{value:"Description",id:"description",level:4},{value:"Arguments",id:"arguments",level:4},{value:"Return Values",id:"return-values",level:4},{value:"Algorithm",id:"algorithm",level:4},{value:"OpenRelTable :: ~OpenRelTable (Destructor)",id:"openreltable--openreltable-destructor",level:3},{value:"Description",id:"description-1",level:4},{value:"Arguments",id:"arguments-1",level:4},{value:"Return Values",id:"return-values-1",level:4},{value:"Algorithm",id:"algorithm-1",level:4},{value:"OpenRelTable :: getRelId",id:"openreltable--getrelid",level:3},{value:"Description",id:"description-2",level:4},{value:"Arguments",id:"arguments-2",level:4},{value:"Return Values",id:"return-values-2",level:4},{value:"Algorithm",id:"algorithm-2",level:4},{value:"OpenRelTable :: openRel",id:"openreltable--openrel",level:3},{value:"Description",id:"description-3",level:4},{value:"Arguments",id:"arguments-3",level:4},{value:"Return Values",id:"return-values-3",level:4},{value:"Algorithm",id:"algorithm-3",level:4},{value:"OpenRelTable :: closeRel",id:"openreltable--closerel",level:3},{value:"Description",id:"description-4",level:4},{value:"Arguments",id:"arguments-4",level:4},{value:"Return Values",id:"return-values-4",level:4},{value:"Algorithm",id:"algorithm-4",level:4},{value:"OpenRelTable :: getFreeOpenRelTableEntry",id:"openreltable--getfreeopenreltableentry",level:3},{value:"Description",id:"description-5",level:4},{value:"Arguments",id:"arguments-5",level:4},{value:"Return Values",id:"return-values-5",level:4},{value:"Algorithm",id:"algorithm-5",level:4}],d={toc:h};function p(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"NITCbase requires that a relation be ",(0,r.kt)("strong",{parentName:"p"},"cached")," for the duration it is accessed to improve the processing time. The ",(0,r.kt)("em",{parentName:"p"},"Open Relation Table")," is a data structure used as an interface for operations that accesses both ",(0,r.kt)("em",{parentName:"p"},"Relation Cache")," and ",(0,r.kt)("em",{parentName:"p"},"Attribute Cache")," together. The ",(0,r.kt)("inlineCode",{parentName:"p"},"OpenRelTable")," class is used for this purpose. As per the NITCbase design, the ith entry of the OpenRelTable corresponds to the i",(0,r.kt)("sup",null,"th")," entry of the ",(0,r.kt)("inlineCode",{parentName:"p"},"RelCacheTable")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"AttrCacheTable")," and is used to store the data of a single relation whose ",(0,r.kt)("em",{parentName:"p"},"relation id")," is ",(0,r.kt)("inlineCode",{parentName:"p"},"i"),". The ",(0,r.kt)("inlineCode",{parentName:"p"},"public getRelId()")," method of the ",(0,r.kt)("inlineCode",{parentName:"p"},"OpenRelTable")," returns the ",(0,r.kt)("em",{parentName:"p"},"relation id")," of the input relation name."),(0,r.kt)("p",null,"The ",(0,r.kt)("em",{parentName:"p"},"class OpenRelTable")," contains as its ",(0,r.kt)("inlineCode",{parentName:"p"},"private")," member field - ",(0,r.kt)("inlineCode",{parentName:"p"},"tableMetaInfo"),", an array of ",(0,r.kt)("inlineCode",{parentName:"p"},"struct OpenRelTableMetaInfo")," that stores the meta information of the entries of the table. The ",(0,r.kt)("inlineCode",{parentName:"p"},"OpenRelTable")," allows ",(0,r.kt)("inlineCode",{parentName:"p"},"MAX_OPEN")," number of entries in the cache at any given time. The first two entries of the Open Relation Table corresponding to ",(0,r.kt)("inlineCode",{parentName:"p"},"RELCAT_RELID")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"ATTRCAT_RELID")," are reserved for storing the entries of ",(0,r.kt)("em",{parentName:"p"},"Relation Catalog")," relation and ",(0,r.kt)("em",{parentName:"p"},"Attribute Catalog")," relation, respectively. ",(0,r.kt)("strong",{parentName:"p"},"These relations remain in cache memory throughout the session and can be closed only during shutdown.")," The ",(0,r.kt)("em",{parentName:"p"},(0,r.kt)("inlineCode",{parentName:"em"},"OpenRelTable")," constructor")," initializes the ",(0,r.kt)("inlineCode",{parentName:"p"},"tableMetaInfo")," field and populates the ",(0,r.kt)("em",{parentName:"p"},"Relation Cache")," Table and ",(0,r.kt)("em",{parentName:"p"},"Attribute Cache")," Table with entries of both ",(0,r.kt)("em",{parentName:"p"},"Relation Catalog")," relation and ",(0,r.kt)("em",{parentName:"p"},"Attribute Catalog")," relation. The ",(0,r.kt)("em",{parentName:"p"},(0,r.kt)("inlineCode",{parentName:"em"},"OpenRelTable")," destructor")," closes any open relation remaining, including the ",(0,r.kt)("em",{parentName:"p"},"Relation Catalog")," and ",(0,r.kt)("em",{parentName:"p"},"Attribute Catalog")," relations, when the system is shut down. The ",(0,r.kt)("inlineCode",{parentName:"p"},"public openRel()")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"public closeRel()")," functions are used to open and close an entry in the ",(0,r.kt)("em",{parentName:"p"},"Open Relation")," Table respectively. ",(0,r.kt)("inlineCode",{parentName:"p"},"OpenRelTable")," class is a ",(0,r.kt)("em",{parentName:"p"},"friend class")," to both ",(0,r.kt)("inlineCode",{parentName:"p"},"RelCacheTable")," class, and ",(0,r.kt)("inlineCode",{parentName:"p"},"AtrrCacheTable")," class. ",(0,r.kt)("em",{parentName:"p"},"This allows it to access the private fields and methods of the two classes.")),(0,r.kt)("admonition",{title:"C++ Static Classes",type:"info"},(0,r.kt)("p",{parentName:"admonition"},(0,r.kt)("inlineCode",{parentName:"p"},"OpenRelTable")," is a ",(0,r.kt)("em",{parentName:"p"},"static class"),", i.e., all member fields and methods are declared ",(0,r.kt)("inlineCode",{parentName:"p"},"static"),". Memory is allocated statically for all member fields of the class. This class uses ",(0,r.kt)("em",{parentName:"p"},"static methods")," to access the ",(0,r.kt)("em",{parentName:"p"},"static member fields"),".",(0,r.kt)("em",{parentName:"p"},"Static methods")," are accessed using the semantics ",(0,r.kt)("inlineCode",{parentName:"p"},"class_name :: function_name()"),". Only a ",(0,r.kt)("strong",{parentName:"p"},"single static object")," of the class needs to be created when NITCbase is running, whose sole purpose is to run the constructor and the destructor.")),(0,r.kt)("p",null,"The class definition of OpenRelTable is as given below:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"class OpenRelTable {\n\npublic:\n\n  //methods\n  OpenRelTable();\n  ~OpenRelTable();\n  static int getRelId(unsigned char relName[ATTR_SIZE]);\n  static int openRel(unsigned char relName[ATTR_SIZE]);\n  static int closeRel(int relId);\n\nprivate:\n  //field\n  static OpenRelTableMetaInfo tableMetaInfo[MAX_OPEN];\n\n  //method\n  static int getFreeOpenRelTableEntry();\n\n};\n")),(0,r.kt)("p",null,"The following are the specifications for the methods in ",(0,r.kt)("inlineCode",{parentName:"p"},"class OpenRelTable"),"."),(0,r.kt)("h3",{id:"openreltable--openreltable-constructor"},"OpenRelTable :: OpenRelTable (Constructor)"),(0,r.kt)("h4",{id:"description"},"Description"),(0,r.kt)("p",null,"Initializes the meta information of each entry of the ",(0,r.kt)("em",{parentName:"p"},"Open Relation")," Table to initial empty conditions. It also loads the entries of the ",(0,r.kt)("em",{parentName:"p"},"Relation Catalog")," relation and ",(0,r.kt)("em",{parentName:"p"},"Attribute Catalog")," relation to the ",(0,r.kt)("em",{parentName:"p"},"Relation Cache")," Table and ",(0,r.kt)("em",{parentName:"p"},"Attribute Cache")," Table. The first two entries corresponding to ",(0,r.kt)("inlineCode",{parentName:"p"},"RELCAT_RELID")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"ATTRCAT_RELID")," in the all the three tables are reserved for ",(0,r.kt)("em",{parentName:"p"},"Relation Catalog")," relation and ",(0,r.kt)("em",{parentName:"p"},"Attribute Catalog")," relation, respectively."),(0,r.kt)("admonition",{title:"Implementation Note",type:"caution"},(0,r.kt)("ul",{parentName:"admonition"},(0,r.kt)("li",{parentName:"ul"},"The object of the ",(0,r.kt)("inlineCode",{parentName:"li"},"OpenRelTable")," class must be declared ",(0,r.kt)("strong",{parentName:"li"},"after")," the objects of the Physical Layer and the Buffer Layer to ensure that the main memory is properly set up before the constructor initializes cache memory."),(0,r.kt)("li",{parentName:"ul"},"This function should be called at the ",(0,r.kt)("strong",{parentName:"li"},"beginning")," of the session."),(0,r.kt)("li",{parentName:"ul"},"All the relation and attribute cache entries need to be dynamically allocated using ",(0,r.kt)("inlineCode",{parentName:"li"},"malloc")))),(0,r.kt)("h4",{id:"arguments"},"Arguments"),(0,r.kt)("p",null,"Nil"),(0,r.kt)("h4",{id:"return-values"},"Return Values"),(0,r.kt)("p",null,"Nil"),(0,r.kt)("h4",{id:"algorithm"},"Algorithm"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"OpenRelTable::OpenRelTable() {\n\n    /* initialize tableMetaInfo of all the entries of the Open Relation Table with\n    free as true and relName as an empty string. also set all entries in\n    AttrCacheTable::attrCache to nullptr */\n\n    /************ Setting up the Relation Cache ************/\n\n    /**** setting up Relation Catalog relation in the Relation Cache ****/\n\n    /* read the record entry at index 0 from block 4, the block corresponding to\n     Relation Catalog in the disk, and create a Relation Cache entry on it\n     using RecBuffer::getRecord() and RelCacheTable::recordToRelCatEntry().\n     update the recId field of this Relation Cache entry to {4,0}.\n     use it to set the 0th index entry of the RelCacheTable. */\n    // NOTE: use malloc to create the RelCacheEntry\n\n    /**** setting up Attribute Catalog relation in the Relation Cache ****/\n\n    /* read the record entry at index 1 from block 4, the block corresponding to\n     Relation Catalog in the disk, and create a Relation Cache entry on it\n     using RecBuffer::getRecord() and RelCacheTable::recordToRelCatEntry().\n     update the recId field of this Relation Cache entry to {4,1}.\n     use it to set the 1st index entry of the RelCacheTable.*/\n\n\n    /************ Setting up the Attribute cache ************/\n\n    /**** setting up Relation Catalog relation in the Attribute Cache ****/\n\n    // listHead will hold the head of the linked list of Attribute Cache entries.\n    AttrCacheEntry* listHead;\n\n    for i from 0 to 5:\n    {\n      /* read the ith record entry from block 5, the block corresponding to\n      Attribute Catalog in the disk, and create an Attribute Cache entry on it\n      using RecBuffer::getRecord() and AttrCacheTable::recordToAttrCatEntry().\n      update the recId field of this Attribute Cache entry to {5,i}.\n      add the Attribute Cache entry to the linked list of listHead .*/\n      // NOTE: use malloc to create the AttrCacheTable entries\n    }\n\n    // set the 0th entry of the AttrCacheTable to listHead.\n\n\n    /**** setting up Attribute Catalog relation in the Attribute Cache ****/\n\n    for i from 6 to 11:\n    {\n      /* read the ith record entry from block 5, the block corresponding to\n      Attribute Catalog in the disk, and create an Attribute Cache entry on it\n      using RecBuffer::getRecord() and AttrCacheTable::recordToAttrCatEntry().\n      update the recId field of this Attribute Cache entry to {5,i}.\n      add the Attribute Cache entry to the linked list of listHead .*/\n    }\n\n    // set the 1st entry of the AttrCacheTable to listHead.\n\n\n    /************ Setting up the Open Relation table ************/\n\n    /**** setting up Relation Catalog relation in the Open Relation Table ****/\n\n    //update the 0th entry of the tableMetaInfo with free as false and relName\n    // as 'RELATIONCAT'.\n\n    /**** setting up Attribute Catalog relation in the Open Relation Table ****/\n\n    //update the 1st entry of the tableMetaInfo with free as false and relName\n    // as 'ATTRIBUTECAT'.\n\n}\n")),(0,r.kt)("h3",{id:"openreltable--openreltable-destructor"},"OpenRelTable :: ~OpenRelTable (Destructor)"),(0,r.kt)("h4",{id:"description-1"},"Description"),(0,r.kt)("p",null,"Closes the still open relations in the ",(0,r.kt)("em",{parentName:"p"},"Open Relation")," Table at the end of the current session."),(0,r.kt)("admonition",{title:"Implementation Note",type:"caution"},(0,r.kt)("p",{parentName:"admonition"},"The object of the ",(0,r.kt)("inlineCode",{parentName:"p"},"OpenRelTable")," class must be declared ",(0,r.kt)("strong",{parentName:"p"},"after")," the objects of the Physical Layer and the Buffer Layer to ensure that the destructor writes the cache contents to the main memory before the main memory is commited back to the disk.")),(0,r.kt)("h4",{id:"arguments-1"},"Arguments"),(0,r.kt)("p",null,"Nil"),(0,r.kt)("h4",{id:"return-values-1"},"Return Values"),(0,r.kt)("p",null,"Nil"),(0,r.kt)("h4",{id:"algorithm-1"},"Algorithm"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"OpenRelTable::~OpenRelTable() {\n\n    for i from 2 to MAX_OPEN-1:\n    {\n        if ith relation is still open:\n        {\n            // close the relation using openRelTable::closeRel().\n        }\n    }\n\n    /**** Closing the catalog relations in the relation cache ****/\n\n    //releasing the relation cache entry of the attribute catalog\n\n    if (/* the RelCatEntry of the ATTRCAT_RELIDth Relation\n           Cache entry has been modified */) {\n\n        /* Get the Relation Catalog entry from RelCacheTable::relCache\n        Then convert it to a record using RelCacheTable::relCatEntryToRecord(). */\n\n        // declaring an object of RecBuffer class to write back to the buffer\n        RecBuffer relCatBlock(recId.block);\n\n        // Write back to the buffer using relCatBlock.setRecord() with recId.slot\n    }\n    // free the memory dynamically allocated to this RelCacheEntry\n\n\n    //releasing the relation cache entry of the relation catalog\n\n    if(/* Relation Catalog entry of the RELCAT_RELIDth RelCacheEntry has been modified */) {\n\n        /* Get the Relation Catalog entry from RelCacheTable::relCache\n        Then convert it to a record using RelCacheTable::relCatEntryToRecord(). */\n\n        // declaring an object of RecBuffer class to write back to the buffer\n        RecBuffer relCatBlock(recId.block);\n\n        // Write back to the buffer using relCatBlock.setRecord() with recId.slot\n    }\n    // free the memory dynamically allocated for this RelCacheEntry\n\n}\n")),(0,r.kt)("details",null,(0,r.kt)("summary",null,"Currently, the attribute cache entries of the relation catalog and attribute catalog cannot have runtime modifications. This is because the attribute cache is only updated when an index is created for a relation and `rootBlock` is set. This operation is not permitted for the catalogs. If in a future design update, the attribute cache entries of the catalogs are modified, the following code can be included in the destructor to handle write-back for the same."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"    /************ Closing the catalog relations in the attribute cache ************/\n\n    /****** releasing the entry corresponding to Attribute Catalog relation from Attribute Cache Table ******/\n\n    // for all the entries in the linked list of the ATTRCAT_RELIDth Attribute Cache entry.\n    {\n        if (/* the entry has been modified */)\n        {\n            /* Get the Attribute Catalog entry from Cache using AttrCacheTable::attrCatEntryToRecord().\n            Write back that entry by instantiating RecBuffer class. Use recId member\n            field and recBuffer.setRecord() */\n        }\n\n        // free the memory dynamically alloted to this entry in Attribute Cache linked list.\n    }\n\n    /****** releasing the entry corresponding to Relation Catalog relation from Attribute Cache Table ******/\n\n    // for all the entries in the linked list of the RELCAT_RELIDth Attribute Cache entry.\n    {\n        if (/* the entry has been modified */) {\n\n            /* Get the Attribute Catalog entry from Cache using AttrCacheTable::attrCatEntryToRecord().\n            Write back that entry by instantiating RecBuffer class. Use recId\n            member field and recBuffer.setRecord() */\n        }\n\n        // free the memory dynamically alloted to this entry in Attribute Cache linked list.\n    }\n"))),(0,r.kt)("h3",{id:"openreltable--getrelid"},"OpenRelTable :: getRelId"),(0,r.kt)("h4",{id:"description-2"},"Description"),(0,r.kt)("p",null,"Returns the ",(0,r.kt)("em",{parentName:"p"},"relation id"),", that is, the ",(0,r.kt)("em",{parentName:"p"},"index"),", of the entry corresponding to the input relation in the ",(0,r.kt)("em",{parentName:"p"},"Open Relation")," Table."),(0,r.kt)("h4",{id:"arguments-2"},"Arguments"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Name"),(0,r.kt)("th",{parentName:"tr",align:null},"Type"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"relName"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"unsigned char [ATTR_SIZE]")),(0,r.kt)("td",{parentName:"tr",align:null},"Name of the relation whose relation id in the Open Relation Table is required")))),(0,r.kt)("h4",{id:"return-values-2"},"Return Values"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Value"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"),(0,r.kt)("th",{parentName:"tr",align:null},"cache entries"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"relId")),(0,r.kt)("td",{parentName:"tr",align:null},"The relation id of the relation in the Open Relation Table"),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/constants"},(0,r.kt)("inlineCode",{parentName:"a"},"E_RELNOTOPEN"))),(0,r.kt)("td",{parentName:"tr",align:null},"The relation corresponding to relationName do not have an open entry in the Open Relation Table. Use OpenRelTable::openRel() to load the relation to cache memory."),(0,r.kt)("td",{parentName:"tr",align:null})))),(0,r.kt)("h4",{id:"algorithm-2"},"Algorithm"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"int OpenRelTable::getRelId(unsigned char relName[ATTR_SIZE]) {\n\n  /* traverse through the tableMetaInfo array,\n    find the entry in the Open Relation Table corresponding to relName.*/\n\n  // if found return the relation id, else indicate that the relation do not\n  // have an entry in the Open Relation Table.\n}\n")),(0,r.kt)("h3",{id:"openreltable--openrel"},"OpenRelTable :: openRel"),(0,r.kt)("h4",{id:"description-3"},"Description"),(0,r.kt)("p",null,"Creates an entry for the input relation in the ",(0,r.kt)("em",{parentName:"p"},"Open Relation")," Table and returns the corresponding ",(0,r.kt)("em",{parentName:"p"},"relation id"),"."),(0,r.kt)("h4",{id:"arguments-3"},"Arguments"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Name"),(0,r.kt)("th",{parentName:"tr",align:null},"Type"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"relName"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"unsigned char [ATTR_SIZE]")),(0,r.kt)("td",{parentName:"tr",align:null},"Name of the relation whose entry is to be created in the Open Relation Table")))),(0,r.kt)("h4",{id:"return-values-3"},"Return Values"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Value"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"relId")),(0,r.kt)("td",{parentName:"tr",align:null},"Relation id of the relation in the Open Relation Table. This is a value between 0 and ",(0,r.kt)("a",{parentName:"td",href:"/constants"},"MAX_OPEN"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/constants"},(0,r.kt)("inlineCode",{parentName:"a"},"E_RELNOTEXIST"))),(0,r.kt)("td",{parentName:"tr",align:null},"No relation with name, relName, exists in the disk")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/constants"},(0,r.kt)("inlineCode",{parentName:"a"},"E_CACHEFULL"))),(0,r.kt)("td",{parentName:"tr",align:null},"No free entries left in the Open Relation Table")))),(0,r.kt)("h4",{id:"algorithm-3"},"Algorithm"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"int OpenRelTable::openRel(unsigned char relName[ATTR_SIZE]) {\n\n  if(/* the relation `relName` already has an entry in the Open Relation Table */){\n    // (checked using OpenRelTable::getRelId())\n\n    // return that relation id;\n  }\n\n  /* find a free slot in the Open Relation Table\n     using OpenRelTable::getFreeOpenRelTableEntry(). */\n\n  if (/* free slot not available */){\n    return E_CACHEFULL;\n  }\n\n  // let relId be used to store the free slot.\n  int relId;\n\n  /****** Setting up Relation Cache entry for the relation ******/\n\n  /* search for the entry with relation name, relName, in the Relation Catalog using\n      BlockAccess::linearSearch().\n      Care should be taken to reset the searchIndex of the relation RELCAT_RELID\n      before calling linearSearch().*/\n\n  // relcatRecId stores the rec-id of the relation `relName` in the Relation Catalog.\n  RecId relcatRecId;\n\n  if (/* relcatRecId == {-1, -1} */) {\n    // (the relation is not found in the Relation Catalog.)\n    return E_RELNOTEXIST;\n  }\n\n  /* read the record entry corresponding to relcatRecId and create a relCacheEntry\n      on it using RecBuffer::getRecord() and RelCacheTable::recordToRelCatEntry().\n      update the recId field of this Relation Cache entry to relcatRecId.\n      use the Relation Cache entry to set the relId-th entry of the RelCacheTable.\n    NOTE: make sure to allocate memory for the RelCacheEntry using malloc()\n  */\n\n  /****** Setting up Attribute Cache entry for the relation ******/\n\n  // let listHead be used to hold the head of the linked list of attrCache entries.\n  AttrCacheEntry* listHead;\n\n  /*iterate over all the entries in the Attribute Catalog corresponding to each\n  attribute of the relation relName by multiple calls of BlockAccess::linearSearch()\n  care should be taken to reset the searchIndex of the relation, ATTRCAT_RELID,\n  corresponding to Attribute Catalog before the first call to linearSearch().*/\n  {\n      /* let attrcatRecId store a valid record id an entry of the relation, relName,\n      in the Attribute Catalog.*/\n      RecId attrcatRecId;\n\n      /* read the record entry corresponding to attrcatRecId and create an\n      Attribute Cache entry on it using RecBuffer::getRecord() and\n      AttrCacheTable::recordToAttrCatEntry().\n      update the recId field of this Attribute Cache entry to attrcatRecId.\n      add the Attribute Cache entry to the linked list of listHead .*/\n      // NOTE: make sure to allocate memory for the AttrCacheEntry using malloc()\n  }\n\n  // set the relIdth entry of the AttrCacheTable to listHead.\n\n  /****** Setting up metadata in the Open Relation Table for the relation******/\n\n  // update the relIdth entry of the tableMetaInfo with free as false and\n  // relName as the input.\n\n  return relId;\n}\n")),(0,r.kt)("h3",{id:"openreltable--closerel"},"OpenRelTable :: closeRel"),(0,r.kt)("h4",{id:"description-4"},"Description"),(0,r.kt)("p",null,"Closes the entry of the input relation in the ",(0,r.kt)("em",{parentName:"p"},"Open Relation")," Table. ",(0,r.kt)("strong",{parentName:"p"},"This function cannot close the ",(0,r.kt)("em",{parentName:"strong"},"Relation Catalog")," relation and ",(0,r.kt)("em",{parentName:"strong"},"Attribute Catalog")," relation"),"."),(0,r.kt)("admonition",{title:"Note",type:"caution"},(0,r.kt)("p",{parentName:"admonition"},"This function cannot close the entries corresponding to ",(0,r.kt)("inlineCode",{parentName:"p"},"RELCAT_RELID")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"ATTRCAT_RELID"),". These relations remain in the cache memory throughout the session and can only be closed at shutdown by the ",(0,r.kt)("inlineCode",{parentName:"p"},"OpenRelTable")," destructor.")),(0,r.kt)("h4",{id:"arguments-4"},"Arguments"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Name"),(0,r.kt)("th",{parentName:"tr",align:null},"Type"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"relId"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"int")),(0,r.kt)("td",{parentName:"tr",align:null},"Relation id of a relation in the Open Relation Table.")))),(0,r.kt)("h4",{id:"return-values-4"},"Return Values"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Value"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/constants"},(0,r.kt)("inlineCode",{parentName:"a"},"SUCCESS"))),(0,r.kt)("td",{parentName:"tr",align:null},"Successfully closed the entry of the relation in the Open Relation Table")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/constants"},(0,r.kt)("inlineCode",{parentName:"a"},"E_NOTPERMITTED"))),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("em",{parentName:"td"},"Relation Catalog")," and ",(0,r.kt)("em",{parentName:"td"},"Attribute Catalog")," relations cannot be closed during the session")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/constants"},(0,r.kt)("inlineCode",{parentName:"a"},"E_OUTOFBOUND"))),(0,r.kt)("td",{parentName:"tr",align:null},"Input relId is outside the valid set of possible relation ids")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/constants"},(0,r.kt)("inlineCode",{parentName:"a"},"E_RELNOTOPEN"))),(0,r.kt)("td",{parentName:"tr",align:null},"Entry corresponding to input relId is free in the Open Relation Table. Use OpenRelTable::openRel() to load the relation to cache memory")))),(0,r.kt)("h4",{id:"algorithm-4"},"Algorithm"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"int OpenRelTable::closeRel(int relId) {\n\n    if relId is either RELCAT_RELID or ATTRCAT_RELID:\n    {\n        return E_NOTPERMITTED;\n    }\n\n    if relId is outside the range [0, MAX_OPEN-1]:\n    {\n        return E_OUTOFBOUND;\n    }\n\n    if entry corresponding to the relId in the Open Relation Table is free:\n    {\n        return E_RELNOTOPEN;\n    }\n\n    /****** Releasing the Relation Cache entry of the relation ******/\n\n    if (/* RelCatEntry of the relIdth Relation Cache entry has been modified */)\n    {\n        /* Get the Relation Catalog entry from RelCacheTable::relCache\n        Then convert it to a record using RelCacheTable::relCatEntryToRecord(). */\n\n        // declaring an object of RecBuffer class to write back to the buffer\n        RecBuffer relCatBlock(recId.block);\n\n        // Write back to the buffer using relCatBlock.setRecord() with recId.slot\n    }\n\n    // free the memory dynamically alloted to this Relation Cache entry\n    // and assign nullptr to that entry\n\n    /****** Releasing the Attribute Cache entry of the relation ******/\n\n    // for all the entries in the linked list of the relIdth Attribute Cache entry.\n    {\n        if the entry has been modified:\n        {\n            /* Get the Attribute Catalog entry from attrCache\n             Then convert it to a record using AttrCacheTable::attrCatEntryToRecord().\n             Write back that entry by instantiating RecBuffer class. Use recId\n             member field and recBuffer.setRecord() */\n        }\n\n        // free the memory dynamically alloted to this entry in Attribute\n        // Cache linked list and assign nullptr to that entry\n    }\n\n    /****** Updating metadata in the Open Relation Table of the relation  ******/\n\n    //free the relIdth entry of the tableMetaInfo.\n\n    return SUCCESS;\n}\n")),(0,r.kt)("h3",{id:"openreltable--getfreeopenreltableentry"},"OpenRelTable :: getFreeOpenRelTableEntry"),(0,r.kt)("h4",{id:"description-5"},"Description"),(0,r.kt)("p",null,"Returns ",(0,r.kt)("em",{parentName:"p"},"index")," of an ",(0,r.kt)("strong",{parentName:"p"},"unoccupied entry")," in the ",(0,r.kt)("em",{parentName:"p"},"Open Relation")," Table."),(0,r.kt)("h4",{id:"arguments-5"},"Arguments"),(0,r.kt)("p",null,"Nil"),(0,r.kt)("h4",{id:"return-values-5"},"Return Values"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Value"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"relId"),(0,r.kt)("td",{parentName:"tr",align:null},"Index of a free entry in the Open Relation Table")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/constants"},(0,r.kt)("inlineCode",{parentName:"a"},"E_CACHEFULL"))),(0,r.kt)("td",{parentName:"tr",align:null},"No free entries left in the Open Relation Table")))),(0,r.kt)("h4",{id:"algorithm-5"},"Algorithm"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"int OpenRelTable::getFreeOpenRelTableEntry() {\n\n  /* traverse through the tableMetaInfo array,\n    find a free entry in the Open Relation Table.*/\n\n  // if found return the relation id, else return E_CACHEFULL.\n}\n")))}p.isMDXComponent=!0}}]);