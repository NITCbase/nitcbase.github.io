"use strict";(self.webpackChunknitcbase=self.webpackChunknitcbase||[]).push([[1530],{3905:(e,n,t)=>{t.d(n,{Zo:()=>p,kt:()=>m});var a=t(7294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function l(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function i(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var c=a.createContext({}),s=function(e){var n=a.useContext(c),t=n;return e&&(t="function"==typeof e?e(n):l(l({},n),e)),t},p=function(e){var n=s(e.components);return a.createElement(c.Provider,{value:n},e.children)},d={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},h=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,o=e.originalType,c=e.parentName,p=i(e,["components","mdxType","originalType","parentName"]),h=s(t),m=r,u=h["".concat(c,".").concat(m)]||h[m]||d[m]||o;return t?a.createElement(u,l(l({ref:n},p),{},{components:t})):a.createElement(u,l({ref:n},p))}));function m(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var o=t.length,l=new Array(o);l[0]=h;var i={};for(var c in n)hasOwnProperty.call(n,c)&&(i[c]=n[c]);i.originalType=e,i.mdxType="string"==typeof e?e:r,l[1]=i;for(var s=2;s<o;s++)l[s]=t[s];return a.createElement.apply(null,l)}return a.createElement.apply(null,t)}h.displayName="MDXCreateElement"},6685:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>d,frontMatter:()=>o,metadata:()=>i,toc:()=>s});var a=t(7462),r=(t(7294),t(3905));const o={title:"Stage 5 : Working With More Relations"},l="Stage 5 : Working With More Relations (10 hours)",i={unversionedId:"Roadmap/Stage05",id:"Roadmap/Stage05",title:"Stage 5 : Working With More Relations",description:"- Learn",source:"@site/docs/Roadmap/Stage05.md",sourceDirName:"Roadmap",slug:"/Roadmap/Stage05",permalink:"/docs/Roadmap/Stage05",draft:!1,tags:[],version:"current",frontMatter:{title:"Stage 5 : Working With More Relations"},sidebar:"Roadmap",previous:{title:"Stage 4 : Looking at the Records",permalink:"/docs/Roadmap/Stage04"}},c={},s=[{value:"Introduction",id:"introduction",level:2},{value:"Open and Closed Relations",id:"open-and-closed-relations",level:3},{value:"Implementation",id:"implementation",level:2},{value:"Exercises",id:"exercises",level:2}],p={toc:s};function d(e){let{components:n,...t}=e;return(0,r.kt)("wrapper",(0,a.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"stage-5--working-with-more-relations-10-hours"},"Stage 5 : Working With More Relations (10 hours)"),(0,r.kt)("admonition",{title:"Learning Objectives",type:"note"},(0,r.kt)("ul",{parentName:"admonition"},(0,r.kt)("li",{parentName:"ul"},"Learn"))),(0,r.kt)("h2",{id:"introduction"},"Introduction"),(0,r.kt)("p",null,"Your implementation must now be able to read the rows and columns of the relations ",(0,r.kt)("inlineCode",{parentName:"p"},"RELCAT")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"ATTRIBUTECAT")," and filter the records based on a certain condition. In this stage, we'll extend all the functionality we have so far to work with any relation on the DBMS."),(0,r.kt)("h3",{id:"open-and-closed-relations"},"Open and Closed Relations"),(0,r.kt)("p",null,"A relation that has it's relation and attribute catalog entries stored in the respective caches is called an ",(0,r.kt)("strong",{parentName:"p"},"open relation"),". NITCbase supports opening 12 relations at once (10 in practice. Why?). If we want to open any more relations, we will have to ",(0,r.kt)("strong",{parentName:"p"},"close")," some relation. ",(0,r.kt)("strong",{parentName:"p"},"NITCbase requires that a relation be opened before any operations can be performed on it"),"."),(0,r.kt)("p",null,"We discussed the ",(0,r.kt)("a",{parentName:"p",href:"/docs/Design/Cache%20Layer#class-relcachetable"},"RelCacheTable")," and ",(0,r.kt)("a",{parentName:"p",href:"/docs/Design/Cache%20Layer#class-attrcachetable"},"AttrCacheTable")," classes in the preceeding stage. Here, we introduce the class ",(0,r.kt)("a",{parentName:"p",href:"/docs/Design/Cache%20Layer#class-openreltable"},"OpenRelTable")," class. This class manages the open and closing of relations and handles the caching operations. It has a member ",(0,r.kt)("inlineCode",{parentName:"p"},"tableMetaInfo")," which is a ",(0,r.kt)("a",{parentName:"p",href:"/constants"},"MAX_OPEN")," sized array of type ",(0,r.kt)("a",{parentName:"p",href:"/docs/Design/Cache%20Layer#openreltablemetainfo"},"struct OpenRelTableMetaInfo"),". ",(0,r.kt)("inlineCode",{parentName:"p"},"tableMetaInfo")," is used to store which entries of the caches are free and the relation to which an occupied entry belongs."),(0,r.kt)("p",null,"For any index ",(0,r.kt)("inlineCode",{parentName:"p"},"i")," that is occupied in the caches, the entries at index ",(0,r.kt)("inlineCode",{parentName:"p"},"i")," in ",(0,r.kt)("inlineCode",{parentName:"p"},"relCache"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"attrCache")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"tableMetaInfo")," will correspond to the same relation. Recall that this index ",(0,r.kt)("inlineCode",{parentName:"p"},"i")," is called the relation's rel-id. These three tables comprise the core functionality of the ",(0,r.kt)("a",{parentName:"p",href:"/docs/Design/Cache%20Layer"},"Cache Layer")," of NITCbase. A table can be opened and closed by the user with the ",(0,r.kt)("a",{parentName:"p",href:"/docs/User%20Interface%20Commands/ddl#open-table"},"OPEN TABLE")," and ",(0,r.kt)("a",{parentName:"p",href:"/docs/User%20Interface%20Commands/ddl#close-table"},"CLOSE TABLE")," commands respectively both handled by the ",(0,r.kt)("a",{parentName:"p",href:"/docs/Design/Schema%20Layer"},"Schema Layer"),"."),(0,r.kt)("h2",{id:"implementation"},"Implementation"),(0,r.kt)("p",null,"Opening a relation requires us to search for the corresponding records in the catalogs. To search through the records of a relation, we require that the relation be open. You must see now why the relation catalog and attribute catalog are always kept open."),(0,r.kt)("p",null,"A sequence diagrams documenting the flow of data between the layers is shown below."),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},(0,r.kt)("strong",{parentName:"p"},"NOTE"),": The functions are denoted with circles as follows.",(0,r.kt)("br",null),"\n\ud83d\udd35 -> methods that are already in their final state",(0,r.kt)("br",null),"\n\ud83d\udfe2 -> methods that will attain their final state in this stage",(0,r.kt)("br",null),"\n\ud83d\udfe0 -> methods that we will modify in this stage, and in subsequent stages ",(0,r.kt)("br",null))),(0,r.kt)("br",null),(0,r.kt)("mermaid",{value:" %%{init: { 'sequence': {'mirrorActors':false} } }%%\nsequenceDiagram\n    actor User\n    participant Frontend User Interface\n    participant Frontend Programming Interface\n    participant Schema Layer\n    participant Cache Layer\n    participant Block Access Layer\n    participant Buffer Layer\n    User->>Frontend User Interface: OPEN TABLE\n    activate Frontend User Interface\n    Frontend User Interface->>Frontend Programming Interface:open_table()\ud83d\udfe2\n    activate Frontend Programming Interface\n    Frontend Programming Interface->>Schema Layer:openRel()\ud83d\udfe2\n    activate Schema Layer\n    Schema Layer->>Cache Layer:openRel()\ud83d\udfe2\n    activate Cache Layer\n    loop until all catalog entries are read\n      Cache Layer->>Block Access Layer:linearSearch()\ud83d\udd35\n      activate Block Access Layer\n      Block Access Layer--\x3e>Cache Layer: recId\n      deactivate Block Access Layer\n      Cache Layer->>Buffer Layer:getHeader()\ud83d\udd35, getRecord()\ud83d\udd35, getSlotmap()\ud83d\udd35\n      activate Buffer Layer\n      Buffer Layer--\x3e>Cache Layer: record block info\n      deactivate Buffer Layer\n    end\n    Cache Layer--\x3e>User:operation status\n    deactivate Cache Layer\n    deactivate Schema Layer\n    deactivate Frontend Programming Interface\n    deactivate Frontend User Interface\n"}),(0,r.kt)("br",null),(0,r.kt)("p",null,"A class diagram showing the methods relevant to this functionality in the Cache Layer is shown below."),(0,r.kt)("mermaid",{value:"classDiagram\ndirection RL\n  RelCacheTable <|.. OpenRelTable : friend\n  AttrCacheTable <|.. OpenRelTable : friend\n  class RelCacheTable{\n    -relCache[MAX_OPEN] : RelCacheEntry*\n  }\n  class AttrCacheTable{\n    -attrCache[MAX_OPEN] : AttrCacheEntry*\n  }\n  class OpenRelTable{\n    -tableMetaInfo[MAX_OPEN] : OpenRelTableMetaInfo\n    +OpenRelTable(): \ud83d\udfe2\n    +~OpenRelTable(): \ud83d\udfe0\n    -getFreeOpenRelTableEntry()$ int\ud83d\udfe2\n    +getRelId(char relName[ATTR_SIZE])$ int\ud83d\udfe2\n    +openRel(char relName[ATTR_SIZE])$ int\ud83d\udfe2\n    +closeRel(int relId)$ int\ud83d\udfe0\n  }\n"}),(0,r.kt)("br",null),(0,r.kt)("p",null,"As shown in the sequence diagram above, the Frontend User Interface will parse the ",(0,r.kt)("inlineCode",{parentName:"p"},"OPEN TABLE")," command and call the ",(0,r.kt)("inlineCode",{parentName:"p"},"Frontend::open_table()")," function in the Frontend Programming Interface. This call is then transferred along to the ",(0,r.kt)("a",{parentName:"p",href:"/docs/Design/Schema%20Layer"},"Schema Layer"),". Hence, the implementation of the ",(0,r.kt)("inlineCode",{parentName:"p"},"Frontend::open_table()")," function only involves a call to the ",(0,r.kt)("inlineCode",{parentName:"p"},"Schema::openRel()")," function. Similarly, the ",(0,r.kt)("inlineCode",{parentName:"p"},"CLOSE TABLE")," command leads to the ",(0,r.kt)("inlineCode",{parentName:"p"},"Frontend::close_table()")," function which in turn transfers control to ",(0,r.kt)("inlineCode",{parentName:"p"},"Schema::closeRel()"),"."),(0,r.kt)("details",null,(0,r.kt)("summary",null,"Frontend/Frontend.cpp"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"int Frontend::open_table(char relname[ATTR_SIZE]) {\n  return Schema::openRel(relname);\n}\n\nint Frontend::close_table(char relname[ATTR_SIZE]) {\n  return Schema::closeRel(relname);\n}\n"))),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"Schema::openRel()")," function transfers control along to the ",(0,r.kt)("a",{parentName:"p",href:"/docs/Design/Cache%20Layer"},"Cache Layer")," and calls ",(0,r.kt)("inlineCode",{parentName:"p"},"OpenRelTable::openRel()"),". ",(0,r.kt)("inlineCode",{parentName:"p"},"Schema::closeRel()")," ensures that the relation and attribute catalog aren't being closed and closes a relation if it is open by calling ",(0,r.kt)("inlineCode",{parentName:"p"},"OpenRelTable::closeRel()"),"."),(0,r.kt)("details",null,(0,r.kt)("summary",null,"Schema/Schema.cpp"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"int Schema::openRel(char relName[ATTR_SIZE]) {\n  return OpenRelTable::openRel(relName);\n}\n\nint Schema::closeRel(char relName[ATTR_SIZE]) {\n  if (/* relation is relation catalog or attribute catalog */) {\n    return E_NOTPERMITTED;\n  }\n\n  // this function returns the rel-id of a relation if it is open or\n  // E_RELNOTOPEN if it is not. we will implement this later.\n  int relId = OpenRelTable::getRelId(relName);\n\n  if (/* relation is not open */) {\n    return E_RELNOTOPEN;\n  }\n\n  return OpenRelTable::closeRel(relId);\n}\n\n"))),(0,r.kt)("p",null,"(pending)"),(0,r.kt)("h2",{id:"exercises"},"Exercises"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Q1.")," Open the relation ",(0,r.kt)("inlineCode",{parentName:"p"},"Students")," and do a select query on the relation with the following commands."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"OPEN TABLE Students;\nSELECT * FROM Students INTO null WHERE Batch=J;\nCLOSE TABLE Students;\n")))}d.isMDXComponent=!0}}]);