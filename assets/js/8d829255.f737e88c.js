"use strict";(self.webpackChunknitcbase=self.webpackChunknitcbase||[]).push([[7091],{3905:(e,t,n)=>{n.d(t,{Zo:()=>h,kt:()=>k});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},l=Object.keys(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),d=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},h=function(e){var t=d(e.components);return a.createElement(s.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,l=e.originalType,s=e.parentName,h=o(e,["components","mdxType","originalType","parentName"]),c=d(n),k=r,p=c["".concat(s,".").concat(k)]||c[k]||u[k]||l;return n?a.createElement(p,i(i({ref:t},h),{},{components:n})):a.createElement(p,i({ref:t},h))}));function k(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var l=n.length,i=new Array(l);i[0]=c;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o.mdxType="string"==typeof e?e:r,i[1]=o;for(var d=2;d<l;d++)i[d]=n[d];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},5832:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>u,frontMatter:()=>l,metadata:()=>o,toc:()=>d});var a=n(7462),r=(n(7294),n(3905));const l={sidebar_position:7,title:"B+ Tree Layer"},i=void 0,o={unversionedId:"Design/B+ Tree Layer",id:"Design/B+ Tree Layer",title:"B+ Tree Layer",description:"https://nitcbase.github.io/archived-site/design/b+tree.html",source:"@site/docs/Design/B+ Tree Layer.md",sourceDirName:"Design",slug:"/Design/B+ Tree Layer",permalink:"/docs/Design/B+ Tree Layer",draft:!1,tags:[],version:"current",sidebarPosition:7,frontMatter:{sidebar_position:7,title:"B+ Tree Layer"},sidebar:"Design",previous:{title:"Cache Layer",permalink:"/docs/Design/Cache Layer"},next:{title:"Buffer Layer",permalink:"/docs/Design/Buffer Layer"}},s={},d=[{value:"Layout",id:"layout",level:2},{value:"class BPlusTree",id:"class-bplustree",level:2},{value:"bPlusCreate",id:"bpluscreate",level:2},{value:"Description",id:"description",level:4},{value:"Arguments",id:"arguments",level:4},{value:"Return values",id:"return-values",level:4},{value:"Algorithm",id:"algorithm",level:4},{value:"bPlusInsert",id:"bplusinsert",level:2},{value:"Description",id:"description-1",level:4},{value:"Arguments",id:"arguments-1",level:4},{value:"Return values",id:"return-values-1",level:4},{value:"Algorithm",id:"algorithm-1",level:4},{value:"bPlusSearch",id:"bplussearch",level:2},{value:"Description",id:"description-2",level:4},{value:"Arguments",id:"arguments-2",level:4},{value:"Return values",id:"return-values-2",level:4},{value:"Algorithm",id:"algorithm-2",level:4},{value:"bPlusDestroy",id:"bplusdestroy",level:2},{value:"Description",id:"description-3",level:4},{value:"Arguments",id:"arguments-3",level:4},{value:"Return values",id:"return-values-3",level:4},{value:"Algorithm",id:"algorithm-3",level:4}],h={toc:d};function u(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},h,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://nitcbase.github.io/archived-site/design/b+tree.html"},"https://nitcbase.github.io/archived-site/design/b+tree.html")),(0,r.kt)("admonition",{title:"PREREQUISITE READING",type:"caution"},(0,r.kt)("ul",{parentName:"admonition"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/docs/Misc/B+%20Trees"},"B+ Trees")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/docs/Misc/Indexing"},"Indexing in NITCbase")))),(0,r.kt)("admonition",{title:"note",type:"info"},(0,r.kt)("p",{parentName:"admonition"},"The B+ Tree Layer code is to be written in ",(0,r.kt)("inlineCode",{parentName:"p"},"BPlusTree.cpp")," and it's header file ",(0,r.kt)("inlineCode",{parentName:"p"},"BPlusTree.h")),(0,r.kt)("p",{parentName:"admonition"},(0,r.kt)("a",{parentName:"p",href:"/stub/bplus_stub"},(0,r.kt)("strong",{parentName:"a"},"The stub code for these files can be found here.")))),(0,r.kt)("h2",{id:"layout"},"Layout"),(0,r.kt)("p",null,"Indexing is used to quickly locate and access the data in a database. It reduces the number of disk accesses needed when a search query is processed. NITCbase uses B+ Trees for the purpose of indexing an attribute in a relation. The B+ Tree Layer provides specifications for the creation/ usage of B+ Trees."),(0,r.kt)("p",null,"For each internal entry in the B+ tree, the attribute values in the left child are smaller or equal to, and the attribute values in the right child are larger than the attribute value of its parent. This property allows systematic traversal of the B+ Tree. ",(0,r.kt)("br",null),"\nThe leaf entries are ordered in ascending order of attribute values. The Leaf Index blocks are also connected as a linked list. This allows easy access to an entry in the next Leaf Index block rather than traversing the entire B+ Tree from the root to reach that entry."),(0,r.kt)("p",null,"NITCbase follows Object Oriented design for implementing B+ Tree. The class diagram is as shown below."),(0,r.kt)("h2",{id:"class-bplustree"},"class BPlusTree"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"class BPlusTree {\npublic:\n    static int bPlusCreate(int relId, char attrName[ATTR_SIZE]);\n    static int bPlusInsert(int relId, char attrName[ATTR_SIZE], union Attribute attrVal, RecId recordId);\n    static RecId bPlusSearch(int relId, char attrName[ATTR_SIZE], union Attribute attrVal, int op);\n    static int bPlusDestroy(int rootBlockNum);\n};\n\n")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"bpluscreate"},"bPlusCreate"),(0,r.kt)("h4",{id:"description"},"Description"),(0,r.kt)("p",null,"This method creates a B+ Tree (Indexing) for the input attribute of the specified relation. It inserts the attribute value corresponding to attrName of all entries in the relation into the B+Tree using ",(0,r.kt)("a",{parentName:"p",href:"#bplusinsert"},"bPlusInsert()"),".",(0,r.kt)("br",null),"\nIf in between the insertion, the disk runs out of space, then the B+ Tree will not be created."),(0,r.kt)("h4",{id:"arguments"},"Arguments"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Attribute")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Type")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Description")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"relId"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"int")),(0,r.kt)("td",{parentName:"tr",align:null},"Relation Id of the relation whose attribute a B+ tree is to be created for.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"attrName"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"char[ATTR_SIZE]")),(0,r.kt)("td",{parentName:"tr",align:null},"Attribute/column name for which B+ tree (index) is to be created.")))),(0,r.kt)("h4",{id:"return-values"},"Return values"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Value")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Description")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/constants"},(0,r.kt)("inlineCode",{parentName:"a"},"SUCCESS"))),(0,r.kt)("td",{parentName:"tr",align:null},"On successful creation of a B+ tree for the attribute")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/constants"},(0,r.kt)("inlineCode",{parentName:"a"},"E_OUTOFBOUND"))),(0,r.kt)("td",{parentName:"tr",align:null},"Input relId is outside the valid set of possible relation ids")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/constants"},(0,r.kt)("inlineCode",{parentName:"a"},"E_RELNOTOPEN"))),(0,r.kt)("td",{parentName:"tr",align:null},"If the relation is not open")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/constants"},(0,r.kt)("inlineCode",{parentName:"a"},"E_ATTRNOTEXIST"))),(0,r.kt)("td",{parentName:"tr",align:null},"If attribute with name attrName does not exist")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/constants"},(0,r.kt)("inlineCode",{parentName:"a"},"E_DISKFULL"))),(0,r.kt)("td",{parentName:"tr",align:null},"If disk space is not sufficient for creating the index")))),(0,r.kt)("h4",{id:"algorithm"},"Algorithm"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"int BPlusTree::bPlusCreate(int relId, char attrName[ATTR_SIZE]) {\n    // let attrCatEntry be used to store the attribute cache entry for attrName.\n    AttrCatEntry attrCatEntry;\n\n    // get the attribute catalog entry of target attribute using AttrCacheTable::getAttrCatEntry() method.\n    int retVal = AttrCacheTable::getAttrCatEntry(relId, attrName, &attrCatEntry);\n\n    if (retVal != SUCCESS) {\n        return retVal;\n    }\n\n    // let rootBlockNum be used to store the root block number of the B+ Tree, obtained from attrCatEntry.\n    int rootBlockNum;\n\n    if (rootBlockNum != -1) {\n        // (index already exists for the attribute.)\n        return SUCCESS;\n    }\n\n    /******Creating a new B+ Tree ******/\n\n    // get a free leaf block.\n    IndLeaf rootBlockBuf;\n\n    // let rootBlock be the blockNumber of the new leaf block, obtained using IndLeaf::getBlockNum()\n    int rootBlock = rootBlockBuf.getBlockNum();\n\n    if (rootBlock == E_DISKFULL) {\n        return E_DISKFULL;\n    }\n\n    // update the rootBlock field of the attribute cache using AttrCacheTable::setAttrCatEntry().\n\n    RelCatEntry relCatEntry;\n\n    // load the relation catalog entry into relCatEntry using RelCacheTable::getRelCatEntry().\n\n    // set block as the first record block of the relation. obtained from relCatEntry\n    int block;\n\n    /******Traverse all the blocks in the relation and insert them one by one into the B+ Tree******/\n    while (block != -1) {\n        // load the block of the relation into blockBuf using RecBuffer::RecBuffer().\n        RecBuffer blockBuf(block);\n\n        unsigned char slotMap[relCatEntry.numSlotsPerBlk];\n\n        // load the slot map into slotMap using RecBuffer::getSlotMap().\n\n        for(/*slot = 0 to relCatEntry.numSlotsPerBlk - 1*/) {\n            if (slotMap[slot] == SLOT_OCCUPIED) {\n                union Attribute record[relCatEntry.numAttrs];\n                // load the record corresponding to the slot into record using RecBuffer::getRecord().\n\n                // let recordId hold the record id {block, slot}.\n                RecId recId{block, slot};\n\n                // insert the attribute value of the record corresponding to attrName using bPlusInsert.\n                // bPlusInsert will destroy the bplus tree if insert fails\n                retVal = bPlusInsert(relId, attrName, record[attrCatEntry.offset], recId);\n\n                if (retVal == E_DISKFULL) {\n                    // (unable to get enough blocks to build the B+ Tree.)\n                    return E_DISKFULL;\n                }\n            }\n        }\n\n        HeadInfo blockHead;\n\n        // load the header of blockBuf into blockHead using BlockBuffer::getHeader().\n\n        // update the block to the next block in the linked list.\n    }\n\n    return SUCCESS;\n}\n")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"bplusinsert"},"bPlusInsert"),(0,r.kt)("h4",{id:"description-1"},"Description"),(0,r.kt)("p",null,"Inserts an Index entry corresponding to the input attribute value and record id into the B+ tree."),(0,r.kt)("admonition",{title:"NOTE",type:"info"},(0,r.kt)("p",{parentName:"admonition"},"During insertion of an entry to a valid B+ Tree, the disk may run out of memory. In such a case, the existing B+ Tree will be destroyed and the attribute catalog entry for the attribute will have rootBlock set to -1. Any operation on the B+ Tree must ensure that the object instance has a valid rootBlock.")),(0,r.kt)("h4",{id:"arguments-1"},"Arguments"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Attribute")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Type")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Description")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"relId"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"int")),(0,r.kt)("td",{parentName:"tr",align:null},"Relation Id of the relation containing the attribute.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"attrName"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"char[ATTR_SIZE]")),(0,r.kt)("td",{parentName:"tr",align:null},"Attribute/column name to whose B+ tree (index) an entry is to be added")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"attrVal"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"union Attribute")),(0,r.kt)("td",{parentName:"tr",align:null},"Attribute value corresponding to attrName in the target record.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"recId"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"struct RecId")),(0,r.kt)("td",{parentName:"tr",align:null},"The record id of the target record whose Index entry is to be inserted into B+ Tree.")))),(0,r.kt)("h4",{id:"return-values-1"},"Return values"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Value")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Description")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/constants"},(0,r.kt)("inlineCode",{parentName:"a"},"SUCCESS"))),(0,r.kt)("td",{parentName:"tr",align:null},"On successful insertion into the B+ tree of the attribute")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/constants"},(0,r.kt)("inlineCode",{parentName:"a"},"E_RELNOTOPEN"))),(0,r.kt)("td",{parentName:"tr",align:null},"If the relation is not open")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/constants"},(0,r.kt)("inlineCode",{parentName:"a"},"E_OUTOFBOUND"))),(0,r.kt)("td",{parentName:"tr",align:null},"Input relId is outside the valid set of possible relation ids")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/constants"},(0,r.kt)("inlineCode",{parentName:"a"},"E_ATTRNOTEXIST"))),(0,r.kt)("td",{parentName:"tr",align:null},"If attribute with name attrName does not exist")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/constants"},(0,r.kt)("inlineCode",{parentName:"a"},"E_NOINDEX"))),(0,r.kt)("td",{parentName:"tr",align:null},"Attribute ",(0,r.kt)("inlineCode",{parentName:"td"},"attrName")," does not have an index")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/constants"},(0,r.kt)("inlineCode",{parentName:"a"},"E_DISKFULL"))),(0,r.kt)("td",{parentName:"tr",align:null},"If disk space is not sufficient for insertion into the B+ tree")))),(0,r.kt)("h4",{id:"algorithm-1"},"Algorithm"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"int BPlusTree::bPlusInsert(int relId, char attrName[ATTR_SIZE], Attribute attrVal, RecId recId) {\n    AttrCatEntry attrCatEntry;\n    // store the attribute catalog cache entry of attrName in attrCatEntry using AttrCacheTable::getAttrCatEntry().\n    int retVal = AttrCacheTable::getAttrCatEntry();\n\n    if (retVal != SUCCESS) {\n        return retVal;\n    }\n\n    int blockNum;\n    // store the rootBlock of B+ Tree in blockNum (from attrCatEntry).\n\n    if (/*index does not exist for attribute (rootBlock is -1)*/) {\n        return E_NOINDEX;\n    }\n\n    /******Traverse the B+ Tree to reach the appropriate leaf where insertion can be done******/\n\n    while (/*block is not of the type IND_LEAF ( use StaticBuffer::getStaticBlockType() )*/) {\n        // load the block using IndInternal::IndInternal().\n        IndInternal indBlock(blockNum);\n\n        HeadInfo blockHeader;\n        // store the header of the block in blockHeader using BlockBuffer::getHeader()\n\n        /*iterate through all the entries, to find the first entry whose\n         attribute value >= value to be inserted.\n         NOTE: the helper function compareAttrs() can be used to compare two Attribute values.*/\n\n        if (/*no such entry is found*/) {\n            // update blockNum with rChild of nEntries-1'th (i.e. last) entry of the block.\n\n        } else {\n            // update blockNum with lChild of the entry of block.\n        }\n    }\n\n    // NOTE: now blockNum is the leaf index block to which insertion of val is to be done.\n\n    /******Insertion of entry in the appropriate leaf block******/\n\n    // load the block using IndLeaf::IndLeaf().\n    IndLeaf* leafBuf = new IndLeaf(blockNum);\n\n    HeadInfo blockHeader;\n    // store the header of the leaf index block in blockHeader using BlockBuffer::getHeader()\n\n    // will store the Index entry to be inserted into B+ Tree.\n    Index indexToIns;\n    // update indexToIns with recId and attrVal\n\n    // will store the existing indices + the new index to insert\n    Index indices[blockHeader.numEntries + 1];\n\n    /*iterate through all the entries in the block and copy them to the array indices.\n        Also insert indexval at appropriate position in the indices array.*/\n\n    if (blockHeader.numEntries != MAX_KEYS_LEAF) {\n        // (leaf block has not reached max limit.)\n        // increment blockHeader.numEntries and set this as header of block using BlockBuffer::setHeader().\n\n        // iterate through all the entries of indices array and populate the entries of block with them using IndLeaf::setEntry().\n\n        delete leafBuf;\n        return SUCCESS;\n    }\n\n    // (leaf block is full- need a new leaf to make the entry; split the entries between the two blocks.)\n\n    // obtain new leaf index block to be used as the right block in the splitting IndLeaf::IndLeaf().\n    IndBuffer* newRightBlk = new IndLeaf();\n\n    // assign the existing block as the left block in the splitting.\n    IndBuffer* leftBlk = leafBuf;\n\n    /*store the block numbers of both blocks in variables newRightBlkNum and leftBlkNum\n        using  BlockBuffer::getBlockNum().*/\n    int newRightBlkNum;\n    int leftBlkNum;\n\n    if (newRightBlkNum == E_DISKFULL) {\n        //(failed to obtain a new leaf index block because the disk is full)\n\n        // destroy the existing B+ tree by passing the rootBlock to bPlusDestroy().\n\n        // update the rootBlock of attribute catalog cache entry to -1 using AttrCacheTable::setAttrCatEntry().\n\n        delete newRightBlk;\n        delete leftBlk;\n        return E_DISKFULL;\n    }\n\n    // let leftBlkHeader be the header of the left block(which is presently stored in blockHeader)\n    HeadInfo leftBlkHeader = blockHeader;\n\n    // let newRightBlkHeader be the header of the new right block.\n    HeadInfo newRightBlkHeader;\n\n    // load the header of newRightBlk in newRightBlkHeader using BlockBuffer::getHeader().\n\n    /*update number of entries in newRightBlkHeader as MAX_KEYS_LEAF/2,\n        pblock as the pblock of leftBlk, lblock as leftBlkNum and its\n        rblock as the rblock of leftBlk\n        and set the header of newRightBlk using BlockBuffer::setHeader()*/\n\n    /*update number of entries in leftBlkHeader as MAX_KEYS_LEAF/2,\n        rblock as newRightBlkNum and set the header using BlockBuffer::setHeader().*/\n\n    /*set the first 32 entries of leftBlk = the first 32 entries of indices array\n        and set the first 32 entries of newRightBlk = the next 32 entries of indices array\n        using IndLeaf::setEntry().*/\n\n    delete leftBlk;\n    delete newRightBlk;\n\n    /******Traverse the internal index blocks of the B+ Tree bottom up making insertions wherever required******/\n\n    // store pblock of leftBlk/newRightBlk in parBlkNum.\n    int parBlkNum;\n\n    /*store the attribute value of indices[MIDDLE_INDEX_LEAF] in newAttrval;\n        this is attribute value which needs to be inserted in the parent block.*/\n    Attribute newAttrVal;\n\n    while (/* not at the root block ( parBlkNum != -1 ) */) {\n        // load the block corresponding to parBlkNum to parBlk using IndInternal::IndInternal().\n        IndInternal* parBlk = new IndInternal(parBlkNum);\n        HeadInfo parHeader;\n\n        // load parHeader with header of parBlk using BlockBuffer::getHeader().\n\n        // let internalEntries be an array of struct InternalEntries of size parHeader.numEntries+1.\n        InternalEntry internalEntries[parHeader.numEntries + 1];\n\n        /*iterate through all the entries of parBlk and copy them to the array internalEntries.\n         Also insert an InternalEntry entry with attrVal as newAttrVal,\n         lChild as leftBlkNum, and rChild as newRightBlkNum at an appropriate\n         position in the internalEntries array. */\n\n        if (parHeader.numEntries != MAX_KEYS_INTERNAL) {\n            // (parBlk has not reached max limit)\n\n            // increment parheader.numEntries and update it as header of parBlk using BlockBuffer::setHeader().\n\n            /* iterate through all entries in internalEntries array and populate the\n            entries of parBlk with them using IndInternal::setEntry(). */\n\n            delete parBlk;\n\n            return SUCCESS;\n        }\n\n        // obtain new internal index block to be used as the right block in the splitting\n        newRightBlk = new IndInternal();\n\n        // assign parBlk as the left block in the splitting.\n        leftBlk = parBlk;\n\n        // update leftBlkNum with parBlkNum.\n        // update newRightBlkNum with block number of newRightBlk using BlockBuffer::getBlockNum().\n\n        if (newRightBlkNum == E_DISKFULL) {\n            // (failed to obtain an empty internal index because the disk is full.)\n\n            /* destroy the right subtree, given by newRightBlkNum, build up till now that\n            has not yet been connected to the existing B+ Tree, using bPlusDestroy(). */\n\n            // destroy the existing B+ tree by passing rootBlock to bPlusDestroy().\n\n            // update the rootBlock of attribute cache entry to -1 using AttrCacheTable::setAttrCatEntry().\n\n            delete leftBlk;\n            delete newRightBlk;\n\n            return E_DISKFULL;\n        }\n\n        // update leftBlkHeader with parHeader.\n\n        // update newRightBlkHeader with the header of the new right block using BlockBuffer::getHeader()\n\n        // update number of entries of leftBlkHeader as MAX_KEYS_INTERNAL/2 (50) using BlockBuffer::setHeader().\n\n        // update number of entries of newRightBlkHeader as MAX_KEYS_INTERNAL/2 using BlockBuffer::setHeader().\n\n        /*set the first 50 entries of leftBlk = first 50 entries of internalEntries array and\n            set the first 50 entries of newRightBlk = entries from 51 to 100 of internalEntries array\n            using IndInternal::setEntry().*/\n\n        /*store the block type of a child of any entry (say, the rchild of 50th entry) of the\n            internalEntries array in type, using StaticBuffer::getStaticBlockType().*/\n        int type;\n\n        // ** update the pblock of all the children of the new right block **\n        for (/*i = 50 to 100*/) {\n            IndBuffer* childBuff;\n            struct HeadInfo childBuffHead;\n\n            // assign the rchild block of ith index in internalEntries of the appropriate type to childBuff.\n            if (type == IND_LEAF)\n                childBuff = new IndLeaf(internalEntries[i].rChild);\n            else\n                childBuff = new IndInternal(internalEntries[i].rChild);\n\n            /*update pblock of the childBuff block to newRightBlkNum using\n                BlockBuffer::getHeader() and BlockBuffer::setHeader().*/\n\n            delete childBuff;\n        }\n\n        delete leftBlk;\n        delete newRightBlk;\n\n        // update parBlkNum as the pblock of leftBlk.\n\n        /*update newAttrVal to the attribute value of 50th entry in the internalEntries array;\n            this is attribute value which needs to be inserted in the parent block.*/\n    }\n\n    // (root block has been split)\n\n    // Need to allot a new block which would be the root of the B+ Tree.\n\n    // load a new internal index block to newRootBlk using IndInternal::IndInternal().\n    IndInternal newRootBlk;\n\n    // store the block number of newRootBlk in newRootBlkNum using BlockBuffer::getBlockNum().\n    int newRootBlkNum;\n\n    if (newRootBlkNum == E_DISKFULL) {\n        // (failed to obtain an empty internal index block because the disk is full.)\n\n        /* destroy the right subtree, given by newRightBlkNum, build up till now that\n        has not yet been connected to the existing B+ Tree, using bPlusDestroy(). */\n\n        // destroy the existing B+ tree by passing rootBlock member field to bPlusDestroy().\n\n        // update the rootBlock of attribute cache entry to -1 using AttrCacheTable::setAttrCatEntry().\n\n        return E_DISKFULL;\n    }\n\n    // let newRootHeader be the header of newRootBlk.\n    HeadInfo newRootHeader;\n\n    // update number of entries in newRootBlk as 1 using BlockBuffer::setHeader() and BlockBuffer::getHeader().\n\n    /*add the struct InternalEntry entry with lChild as leftBlkNum, attrVal as newAttrVal,\n        and rChild as newRightBlkNum as the first entry to newRootBlk using IndInternal::setEntry().*/\n\n    /* obtain new record buffers for leftBlkNum and newRightBlkNum and store it\n        in leftBlk and newRightBlk\n        the type of leftBlkNum and newRightBlkNum has to be checked and appropriate\n        IndLeaf or IndInternal instance needs to be used*/\n\n    /*update the pblock of leftBlk and newRightBlk to newRootBlkNum\n        using BlockBuffer::setHeader() and BlockBuffer::getHeader().*/\n\n    // update rootBlock of attribute catalog cache entry as newBlkNum using AttrCacheTable::setAttrCatEntry().\n\n    delete leftBlk;\n    delete newRightBlk;\n\n    return SUCCESS;\n}\n")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"bplussearch"},"bPlusSearch"),(0,r.kt)("h4",{id:"description-2"},"Description"),(0,r.kt)("p",null,"Used to search the first/ next record entry in the relation whose attribute value corresponding to ",(0,r.kt)("inlineCode",{parentName:"p"},"attrName")," satisfies the relational operation for the input attribute value. ",(0,r.kt)("br",null),"\nThe method makes use of the searchIndex field of the attribute in the Attribute Catalog Cache for this purpose. A valid index id holds the index id of the entry in the leaf block of the B+ Tree that corresponded to a hit in the previous search. The search is resumed from the next index entry. An invalid index id means that the search is being done for the first time. ",(0,r.kt)("br",null),"\nThis method can be called multiple times to get all the records in the relation that satisfy op for input attrVal."),(0,r.kt)("admonition",{title:"NOTE",type:"info"},(0,r.kt)("p",{parentName:"admonition"},"The caller is expected to verify that an index exists on attrName for the relation. {-1, -1} will be returned otherwise.")),(0,r.kt)("h4",{id:"arguments-2"},"Arguments"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Attribute")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Type")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Description")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"relId"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"int")),(0,r.kt)("td",{parentName:"tr",align:null},"Relation Id of the relation containing the attribute with index.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"attrName"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"char[ATTR_SIZE]")),(0,r.kt)("td",{parentName:"tr",align:null},"Attribute/column name (which has an index) to which condition need to be checked with.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"attrVal"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"union Attribute")),(0,r.kt)("td",{parentName:"tr",align:null},"value of attribute that has to be checked against the operater.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"op"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"int")),(0,r.kt)("td",{parentName:"tr",align:null},"Conditional Operator (can be one among ",(0,r.kt)("inlineCode",{parentName:"td"},"EQ")," , ",(0,r.kt)("inlineCode",{parentName:"td"},"LE")," , ",(0,r.kt)("inlineCode",{parentName:"td"},"LT")," , ",(0,r.kt)("inlineCode",{parentName:"td"},"GE")," , ",(0,r.kt)("inlineCode",{parentName:"td"},"GT")," , ",(0,r.kt)("inlineCode",{parentName:"td"},"NE")," corresponding to equal, less or than equal, less than ,greater than or equal, greater than, not equal operators respectively).")))),(0,r.kt)("h4",{id:"return-values-2"},"Return values"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Value")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Description")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"{block#, index#}")),(0,r.kt)("td",{parentName:"tr",align:null},"returns the ",(0,r.kt)("em",{parentName:"td"},"block number and slot number")," of the record corresponding to the next hit. This corresponds to type ",(0,r.kt)("inlineCode",{parentName:"td"},"RecId"),".")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"{-1, -1}")),(0,r.kt)("td",{parentName:"tr",align:null},"If no valid next hit is found or if a B+ tree does not exist for the attribute. This corresponds to type ",(0,r.kt)("inlineCode",{parentName:"td"},"RecId"),".")))),(0,r.kt)("h4",{id:"algorithm-2"},"Algorithm"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"RecId BPlusTree::bPlusSearch(int relId, char attrName[ATTR_SIZE], Attribute attrVal, int op) {\n    // let searchIndex be used to store search index for attrName.\n    IndexId searchIndex;\n\n    // get the search index from the attribute cache using the AttrCacheTable::getSearchIndex().\n\n    /* reset the search index to {-1,-1} using AttrCacheTable::resetSearchIndex().\n    (this will be set to the correct index id if an entry satisfying op for given\n    attrVal is found in the course of the search.)*/\n\n    // let attrCatEntry be used to store the attribute cache entry for attrName.\n    AttrCatEntry attrCatEntry;\n\n    // load the attribute catalog cache entry using AttrCacheTable::getAttrCatEntry().\n\n    // let block and index variables be used to locate the entry to be searched.\n    int block, index;\n\n    if (/* searchIndex == {-1, -1}*/) {\n        // (search is done for the first time)\n\n        // start the search from the first entry of root.\n        block = attrCatEntry.rootBlock;\n        index = 0;\n\n        if (/* attrName doesn't have a B+ tree (block == -1)*/) {\n            // return the recId {-1, -1};\n        }\n\n    } else {\n        /*a valid searchIndex points to an entry in the leaf index of the attribute's\n        B+ Tree which had previously satisfied the op for the given attrVal.*/\n\n        block = searchIndex.block;\n        index = searchIndex.index + 1;  // search is resumed from the next index.\n\n        // load block into leaf using IndLeaf::IndLeaf().\n        IndLeaf leaf(block);\n\n        // let leafHead be used to hold the header of leaf.\n        HeadInfo leafHead;\n\n        // load header into leafHead using BlockBuffer::getHeader().\n\n        if (index >= leafHead.numEntries) {\n            /* (all the entries in the block has been searched; search from the\n            beginning of the next leaf index block. */\n\n            // update block to rblock of current block and index to 0.\n\n            if (block == -1) {\n                // (end of linked list reached - the search is done.)\n                // return the recId {-1, -1};\n            }\n        }\n    }\n\n    /******Traverse through all the internal nodes according to value of AttrVal and the operator op******/\n\n    while (/*block is of type IND_INTERNAL */) {  // use StaticBuffer::getStaticBlockType().\n\n        // load the block into internalBlk using IndInternal::IndInternal().\n        IndInternal internalBlk(block);\n\n        HeadInfo intHead;\n\n        // load the header of internalBlock into intHead using BlockBuffer::getHeader()\n\n        // let intEntry be used to store an internal entry of the internalBlk.\n        InternalEntry intEntry;\n\n        if (/* op is one of NE, LT, LE */) {\n            /*\n            - NE: need to search the entire linked list of leaf indices of the B+ Tree,\n            starting from the leftmost leaf index. Thus, always move to the left.\n\n            - LT and LE: the attribute values are arranged in ascending order in the leaf\n            indices of the B+ Tree. Values that satisfy these conditions, if any exist,\n            will always be found in the left-most leaf index. Thus, always move to the left.\n            */\n\n            // load entry in the first slot of the block into intEntry using IndInternal::getEntry().\n            block = intEntry.lChild;\n\n        } else {\n            /*\n            - EQ, GT and GE: move to the left child of the first entry that is\n            greater than (or equal to) attrVal\n            (we are trying to find the first entry that satisfies the condition.\n            since the values are in ascending order we move to the left child which\n            might contain more entries that satisfy the condition)\n            */\n\n            /*\n             traverse through all entries of internalBlk and find an entry that satisfies\n             the condition.\n             if op == EQ or GE, then intEntry.attrVal >= attrVal\n             if op == GT, then intEntry.attrVal > attrVal\n             Hint: the helper function compareAttrs() can be used for comparing\n            */\n\n            if (/* such an entry is found*/) {\n                // move to the left child of that entry\n                block =  // left child of the entry\n\n            } else {\n                // move to the right child of the last entry of the block\n                // i.e numEntries - 1 th entry of the block\n\n                block =  // right child of last entry\n            }\n        }\n\n        // NOTE: the block is now a leaf index block.\n\n        /******Traverse through index entries in the leaf index block from the index entry numbered as index******/\n        while (block != -1) {\n            // load the block into leafBlk using IndLeaf::IndLeaf().\n            IndLeaf leafBlk(block);\n            HeadInfo leafHead;\n\n            // load the header to leafHead using BlockBuffer::getHeader().\n\n            Index leafEntry;\n\n            while (/*index < numEntries in leafBlk*/) {  // numEntries can be obtained from leafHead.\n\n                // load entry corresponding to block and index into leafEntry using IndLeaf::getEntry().\n\n                int cmpVal = /* comparison between leafEntry's attribute value and input attrVal using compareAttrs()*/;\n\n                if (\n                    (op == EQ && cmpVal == 0) ||\n                    (op == LE && cmpVal <= 0) ||\n                    (op == LT && cmpVal < 0) ||\n                    (op == GT && cmpVal > 0) ||\n                    (op == GE && cmpVal >= 0) ||\n                    (op == NE && cmpVal != 0)\n                ) {\n                    // (entry satisfying the condition found)\n\n                    // set search index to {block, index}\n\n                    // return the recId {leafEntry.block, leafEntry.slot}.\n\n                } else if ((op == EQ || op == LE || op == LT) && cmpVal > 0) {\n                    /*future entries will not satisfy EQ, LE, LT since the values are\n                    arranged in ascending order in the leaves */\n\n                    // return RecId {-1, -1};\n                }\n\n                // search next index.\n                ++index;\n            }\n\n            /*only for NE do we have to check the entire linked list;\n            for all the other op it is guaranteed that the block being searched will have an entry,if it exists,\n            satisying that op.*/\n            if (op != NE) {\n                break;\n            }\n\n            // block = next block in the linked list, i.e., the rblock in the leafHead.\n            // update index to 0.\n        }\n\n        // no entry satisying the op was found; return the recId {-1,-1}\n    }\n}\n")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"bplusdestroy"},"bPlusDestroy"),(0,r.kt)("h4",{id:"description-3"},"Description"),(0,r.kt)("p",null,"Used to delete a B+ Tree. The caller passes the root block of the B+ Tree as input to the method. The method recursively deletes the constituent index blocks, both internal and leaf index blocks, until the full B+ Tree is deleted."),(0,r.kt)("p",null,"This method is called in a situation where no further disk blocks can be allotted during the creation of/ insertion to a B+ Tree. This function is also called while deleting an entire relation in NITCbase."),(0,r.kt)("admonition",{title:"NOTE",type:"info"},(0,r.kt)("p",{parentName:"admonition"},"The caller is responsible for updating the rootBlock field in the corresponding attribute catalog after deletion.")),(0,r.kt)("h4",{id:"arguments-3"},"Arguments"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Attribute")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Type")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Description")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"rootBlockNum"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"int")),(0,r.kt)("td",{parentName:"tr",align:null},"block number of the root of the B+ tree to be destroyed")))),(0,r.kt)("h4",{id:"return-values-3"},"Return values"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Value")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Description")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/constants"},(0,r.kt)("inlineCode",{parentName:"a"},"SUCCESS"))),(0,r.kt)("td",{parentName:"tr",align:null},"On successful deletion of the B+ tree rooted at rootBlockNum")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/constants"},(0,r.kt)("inlineCode",{parentName:"a"},"E_OUTOFBOUND"))),(0,r.kt)("td",{parentName:"tr",align:null},"if ",(0,r.kt)("inlineCode",{parentName:"td"},"rootBlockNum")," is outside the valid range of block numbers")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/constants"},(0,r.kt)("inlineCode",{parentName:"a"},"E_INVALIDBLOCK"))),(0,r.kt)("td",{parentName:"tr",align:null},"if ",(0,r.kt)("inlineCode",{parentName:"td"},"rootBlockNum")," does not correspond to an index block")))),(0,r.kt)("h4",{id:"algorithm-3"},"Algorithm"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"int BPlusTree::bPlusDestroy(int rootBlockNum) {\n    if (/*rootBlockNum lies outside the valid range [0,DISK_BLOCKS-1]*/) {\n        return E_OUTOFBOUND;\n    }\n\n    // store the type of block having using StaticBuffer::getStaticBlockType()\n    int type;\n\n    if (type == IND_LEAF) {\n        // let leafBlk be used to hold block of rootBlockNum using IndLeaf::IndLeaf().\n        IndLeaf leafBlk(rootBlockNum);\n\n        // release the block using BlockBuffer::releaseBlock().\n\n        return SUCCESS;\n\n    } else if (type == IND_INTERNAL) {\n        // let internalBlk be used to hold block of blockNum using IndInternal::IndInternal().\n        IndInternal internalBlk(rootBlockNum);\n\n        // let internalHead be used to store header of internalBlk.\n        HeadInfo internalHead;\n\n        // load the header using BlockBuffer::getHeader().\n\n        // let entry be used to hold an entry of the internalBlk.\n        InternalEntry entry;\n\n        /*iterate through all the entries of the internalBlk and destroy the lChild\n        of the first entry and rChild of all entries using BPlusTree::bPlusDestroy().\n        (take care not to delete overlapping children more than once)*/\n\n        // release the block using BlockBuffer::releaseBlock().\n\n        return SUCCESS;\n\n    } else {\n        // (block is not an index block.)\n        return E_INVALIDBLOCK;\n    }\n}\n")))}u.isMDXComponent=!0}}]);