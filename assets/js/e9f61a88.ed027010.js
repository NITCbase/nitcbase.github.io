"use strict";(self.webpackChunknitcbase=self.webpackChunknitcbase||[]).push([[9300],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>h});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},l=Object.keys(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var c=a.createContext({}),s=function(e){var t=a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},d=function(e){var t=s(e.components);return a.createElement(c.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,l=e.originalType,c=e.parentName,d=i(e,["components","mdxType","originalType","parentName"]),u=s(n),h=r,m=u["".concat(c,".").concat(h)]||u[h]||p[h]||l;return n?a.createElement(m,o(o({ref:t},d),{},{components:n})):a.createElement(m,o({ref:t},d))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var l=n.length,o=new Array(l);o[0]=u;var i={};for(var c in t)hasOwnProperty.call(t,c)&&(i[c]=t[c]);i.originalType=e,i.mdxType="string"==typeof e?e:r,o[1]=i;for(var s=2;s<l;s++)o[s]=n[s];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},9043:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>o,default:()=>p,frontMatter:()=>l,metadata:()=>i,toc:()=>s});var a=n(7462),r=(n(7294),n(3905));const l={title:"Stage 8 : Creating and Deleting Relations"},o="Stage 8 : Creating and Deleting Relations (10 hours)",i={unversionedId:"Roadmap/Stage08",id:"Roadmap/Stage08",title:"Stage 8 : Creating and Deleting Relations",description:"- Implement the creation of relations by inserting records into the catalogs",source:"@site/docs/Roadmap/Stage08.md",sourceDirName:"Roadmap",slug:"/Roadmap/Stage08",permalink:"/docs/Roadmap/Stage08",draft:!1,tags:[],version:"current",frontMatter:{title:"Stage 8 : Creating and Deleting Relations"},sidebar:"Roadmap",previous:{title:"Stage 7 : Inserting Records Into Relations",permalink:"/docs/Roadmap/Stage07"}},c={},s=[{value:"Introduction",id:"introduction",level:2},{value:"Implementation",id:"implementation",level:2},{value:"Exercises",id:"exercises",level:2}],d={toc:s};function p(e){let{components:t,...l}=e;return(0,r.kt)("wrapper",(0,a.Z)({},d,l,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"stage-8--creating-and-deleting-relations-10-hours"},"Stage 8 : Creating and Deleting Relations (10 hours)"),(0,r.kt)("admonition",{title:"Learning Objectives",type:"note"},(0,r.kt)("ul",{parentName:"admonition"},(0,r.kt)("li",{parentName:"ul"},"Implement the creation of relations by inserting records into the catalogs"),(0,r.kt)("li",{parentName:"ul"},"Implement the deletion of relations and the subsequent freeing of blocks"))),(0,r.kt)("h2",{id:"introduction"},"Introduction"),(0,r.kt)("p",null,"In previous stages, we had implemented the insertion of records into existing relations. In this stage, we will implement the functionality to create and delete relations in NITCbase."),(0,r.kt)("p",null,"Creating a relation, in essence, involves inserting records into the relation and attribute catalog specifying the details of the relation and its attributes. This functionality is implemented in the ",(0,r.kt)("a",{parentName:"p",href:"/docs/Design/Schema%20Layer"},"Schema Layer")," and the ",(0,r.kt)("a",{parentName:"p",href:"/docs/Design/Block%20Access%20Layer"},"Block Access Layer")," and is called using the ",(0,r.kt)("a",{parentName:"p",href:"/docs/User%20Interface%20Commands/ddl#create-table"},"CREATE TABLE")," command."),(0,r.kt)("p",null,"Deleting a relation is done using the ",(0,r.kt)("a",{parentName:"p",href:"/docs/User%20Interface%20Commands/ddl#drop-table"},"DROP TABLE")," command. This process involves freeing all the blocks used to store the record of the relation and removing all the records corresponding to the relation from the catalogs. Note that NITCbase does not allow you to delete individual records from a relation, only a relation as a whole."),(0,r.kt)("h2",{id:"implementation"},"Implementation"),(0,r.kt)("p",null,"A sequence diagram showing the call sequence involved in the implementation of the create and delete functionality are shown below."),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},(0,r.kt)("strong",{parentName:"p"},"NOTE"),": The functions are denoted with circles as follows.",(0,r.kt)("br",null),"\n\ud83d\udd35 -> methods that are already in their final state",(0,r.kt)("br",null),"\n\ud83d\udfe2 -> methods that will attain their final state in this stage",(0,r.kt)("br",null),"\n\ud83d\udfe0 -> methods that we will modify in this stage, and in subsequent stages ",(0,r.kt)("br",null),"\n\ud83d\udfe4 -> methods that we built earlier and require more work later, but will leave as is in this stage")),(0,r.kt)("mermaid",{value:"%%{init: { 'sequence': {'mirrorActors':false} } }%%\nsequenceDiagram\n  actor User\n  participant Frontend User Interface\n  participant Frontend Programming Interface\n  participant Schema Layer\n  participant Block Access Layer\n  participant Cache Layer\n  participant Buffer Layer\n  User->>Frontend User Interface: CREATE TABLE\n  activate Frontend User Interface\n  Frontend User Interface->>Frontend Programming Interface :create_table()\ud83d\udfe2\n  activate Frontend Programming Interface\n  Frontend Programming Interface->>Schema Layer:createRel()\ud83d\udfe2\n  activate Schema Layer\n  Schema Layer->>Block Access Layer:insert()\ud83d\udfe4\n  activate Block Access Layer\n  Block Access Layer ->> Buffer Layer: *update the catalog record blocks*\n  activate Buffer Layer\n  Buffer Layer--\x3e>Block Access Layer:operation status\n  deactivate Buffer Layer\n  Block Access Layer->>Cache Layer: *update catalogs in relation cache*\n  activate Cache Layer\n  Cache Layer--\x3e>Block Access Layer:operation status\n  deactivate Cache Layer\n  Block Access Layer--\x3e>User:operation status\n  deactivate Block Access Layer\n  deactivate Schema Layer\n  deactivate Frontend Programming Interface\n  deactivate Frontend User Interface"}),(0,r.kt)("br",null),(0,r.kt)("mermaid",{value:"%%{init: { 'sequence': {'mirrorActors':false} } }%%\nsequenceDiagram\n  actor User\n  participant Frontend User Interface\n  participant Frontend Programming Interface\n  participant Schema Layer\n  participant Block Access Layer\n  participant Cache Layer\n  participant Buffer Layer\n  User->>Frontend User Interface: DROP TABLE\n  activate Frontend User Interface\n  Frontend User Interface->>Frontend Programming Interface :drop_table()\ud83d\udfe2\n  activate Frontend Programming Interface\n  Frontend Programming Interface->>Schema Layer:deleteRel()\ud83d\udfe2\n  activate Schema Layer\n  Schema Layer->>Block Access Layer:deleteRelation()\ud83d\udfe2\n  activate Block Access Layer\n  Block Access Layer ->> Buffer Layer: *update the catalog record blocks*\n  activate Buffer Layer\n  Buffer Layer--\x3e>Block Access Layer:operation status\n  deactivate Buffer Layer\n  loop for all record blocks of the relation\n    Block Access Layer ->> Buffer Layer: releaseBlock()\ud83d\udfe2\n    activate Buffer Layer\n    Buffer Layer--\x3e>Block Access Layer:operation status\n    deactivate Buffer Layer\n  end\n  Block Access Layer->>Cache Layer: *update catalogs in relation cache*\n  activate Cache Layer\n  Cache Layer--\x3e>Block Access Layer:operation status\n  deactivate Cache Layer\n  Block Access Layer--\x3e>User:operation status\n  deactivate Block Access Layer\n  deactivate Schema Layer\n  deactivate Frontend Programming Interface\n  deactivate Frontend User Interface\n"}),(0,r.kt)("br",null),(0,r.kt)("p",null,"A class diagram showing the methods relevant to this functionality in the ",(0,r.kt)("a",{parentName:"p",href:"/docs/Design/Schema%20Layer"},"Schema Layer"),", ",(0,r.kt)("a",{parentName:"p",href:"/docs/Design/Block%20Access%20Layer"},"Block Access Layer")," and ",(0,r.kt)("a",{parentName:"p",href:"/docs/Design/Buffer%20Layer/intro"},"Buffer Layer")," is shown below."),(0,r.kt)("mermaid",{value:"classDiagram\n  class Schema{\n    +openRel(char relName[ATTR_SIZE])$ int\ud83d\udd35\n    +closeRel(char relName[ATTR_SIZE])$ int\ud83d\udd35\n    +renameRel(char oldRelName[ATTR_SIZE], char newRelName[ATTR_SIZE])$ int\ud83d\udd35\n    +renameAttr(char relName[ATTR_SIZE], char oldAttrName[ATTR_SIZE], char newAttrName[ATTR_SIZE])$ int\ud83d\udd35\n    +createRel(char relName[ATTR_SIZE], int numOfAttributes, char attrNames[][ATTR_SIZE], int attrType[])$ int\ud83d\udfe2\n    +deleteRel(char relName[ATTR_SIZE])$ \ud83d\udfe2\n  }"}),(0,r.kt)("mermaid",{value:"classDiagram\n  class BlockAccess{\n    +linearSearch(int relId, char attrName[ATTR_SIZE], Attribute attrVal, int op)$ RecId\ud83d\udd35\n    +renameRelation(char oldName[ATTR_SIZE], char newName[ATTR_SIZE])$ int\ud83d\udd35\n    +renameAttribute(char relName[ATTR_SIZE], char oldName[ATTR_SIZE], char newName[ATTR_SIZE])$ int\ud83d\udd35\n    +insert(int relId, union Attribute* record)$ int\ud83d\udfe4\n    +search(int relId, Attribute *record, char attrName[ATTR_SIZE], Attribute attrVal, int op)$ int\ud83d\udfe0\n    +deleteRelation(char relName[ATTR_SIZE])$ int\ud83d\udfe0\n  }"}),(0,r.kt)("br",null),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Cache Layer")),(0,r.kt)("mermaid",{value:"classDiagram\ndirection RL\n  RelCacheTable <|.. OpenRelTable : friend\n  AttrCacheTable <|.. OpenRelTable : friend\n  class RelCacheTable{\n    -relCache[MAX_OPEN] : RelCacheEntry*\n    -recordToRelCatEntry(union Attribute record[RELCAT_NO_ATTRS], RelCatEntry *relCatEntry)$ void\ud83d\udd35\n    -relCatEntryToRecord(RelCatEntry *relCatEntry, union Attribute record[RELCAT_NO_ATTRS])$ void\ud83d\udd35\n    +getRelCatEntry(int relId, RelCatEntry *relCatBuf)$ int\ud83d\udd35\n    +setRelCatEntry(int relId, RelCatEntry *relCatBuf)$ int\ud83d\udd35\n    +getSearchIndex(int relId, RecId *searchIndex)$ int\ud83d\udd35\n    +setSearchIndex(int relId, RecId *searchIndex)$ int\ud83d\udd35\n    +resetSearchIndex(int relId)$ int\ud83d\udd35\n  }\n  class AttrCacheTable{\n    -attrCache[MAX_OPEN] : AttrCacheEntry*\n    -recordToAttrCatEntry(union Attribute record[ATTRCAT_NO_ATTRS], AttrCatEntry *attrCatEntry)$ void\ud83d\udd35\n    +getAttrCatEntry(int relId, int attrOffset, AttrCatEntry *attrCatBuf)$ int\ud83d\udd35\n    +getAttrCatEntry(int relId, char attrName[ATTR_SIZE], AttrCatEntry *attrCatBuf)$ int\ud83d\udd35\n  }\n  class OpenRelTable{\n    -tableMetaInfo[MAX_OPEN] : OpenRelTableMetaInfo\n    +OpenRelTable(): \ud83d\udd35\n    +~OpenRelTable(): \ud83d\udfe2\n    -getFreeOpenRelTableEntry()$ int\ud83d\udd35\n    +getRelId(char relName[ATTR_SIZE])$ int\ud83d\udd35\n    +openRel(char relName[ATTR_SIZE])$ int\ud83d\udd35\n    +closeRel(int relId)$ int\ud83d\udfe4\n  }\n"}),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Buffer Layer")),(0,r.kt)("mermaid",{value:"classDiagram\n  direction LR\n  BlockBuffer <|-- RecBuffer\n  StaticBuffer<|..RecBuffer : uses\n  StaticBuffer<|..BlockBuffer : uses\n  class RecBuffer{\n    +RecBuffer() \ud83d\udd35\n    +RecBuffer(int blockNum) \ud83d\udd35\n    +getRecord(union Attribute *rec, int slotNum) int\ud83d\udd35\n    +setRecord(union Attribute *rec, int slotNum) int\ud83d\udd35\n    +getSlotMap(unsigned char *slotMap) int\ud83d\udd35\n    +setSlotMap(unsigned char *slotMap) int\ud83d\udd35\n  }\n  class BlockBuffer{\n    #blockNum: int\n    +BlockBuffer(char blockType) \ud83d\udd35\n    +BlockBuffer(int blockNum) \ud83d\udd35\n    +getHeader(struct HeadInfo *head) int\ud83d\udd35\n    +setHeader(struct HeadInfo *head) int\ud83d\udd35\n    +releaseBlock() void\ud83d\udfe2\n    #setBlockType(int blockType) int\ud83d\udd35\n    #getFreeBlock(int blockType) int\ud83d\udd35\n    #loadBlockAndGetBufferPtr(unsigned char **buffPtr) int\ud83d\udd35\n  }\n  class StaticBuffer{\n    -blocks[BUFFER_CAPACITY][BLOCK_SIZE]: unsigned char\n    -metainfo[BUFFER_CAPACITY]: struct BufferMetaInfo\n    -blockAllocMap[DISK_BLOCKS]: unsigned char\n    +StaticBuffer() \ud83d\udd35\n    +~StaticBuffer() \ud83d\udd35\n    -getFreeBuffer(int blockNum)$ int\ud83d\udd35\n    -getBufferNum(int blockNum)$ int\ud83d\udd35\n    +setDirtyBit(int blockNum)$ int\ud83d\udd35\n  }"}),(0,r.kt)("br",null),(0,r.kt)("p",null,"As shown in the sequence diagram above, the Frontend User Interface will parse the ",(0,r.kt)("inlineCode",{parentName:"p"},"CREATE TABLE")," command and call the ",(0,r.kt)("inlineCode",{parentName:"p"},"Frontend::create_table()")," function in the Frontend Programming Interface. This call is then transferred along to the ",(0,r.kt)("a",{parentName:"p",href:"/docs/Design/Schema%20Layer"},"Schema Layer"),". Hence, the implementation of the ",(0,r.kt)("inlineCode",{parentName:"p"},"Frontend::create_table()")," function only involves a call to the ",(0,r.kt)("inlineCode",{parentName:"p"},"Schema::createRel()")," function. Similarly, the ",(0,r.kt)("inlineCode",{parentName:"p"},"DROP TABLE")," command leads to the ",(0,r.kt)("inlineCode",{parentName:"p"},"Frontend::drop_table()")," function which in turn transfers control to ",(0,r.kt)("inlineCode",{parentName:"p"},"Schema::deleteRel()"),"."),(0,r.kt)("details",null,(0,r.kt)("summary",null,"Frontend/Frontend.cpp"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"int Frontend::create_table(char relname[ATTR_SIZE], int no_attrs, char attributes[][ATTR_SIZE], int type_attrs[]) {\n  return Schema::createRel(relname, no_attrs, attributes, type_attrs);\n}\n\nint Frontend::drop_table(char relname[ATTR_SIZE]) {\n  return Schema::deleteRel(relname);\n}\n"))),(0,r.kt)("p",null,"Now, let us implement the functions in the ",(0,r.kt)("a",{parentName:"p",href:"/docs/Design/Schema%20Layer"},"Schema Layer")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"Schema::createRel()")," function checks for duplicate relation and attribute names and inserts the records into the catalogs using ",(0,r.kt)("inlineCode",{parentName:"p"},"BlockAccess:insert()"),". The ",(0,r.kt)("inlineCode",{parentName:"p"},"Schema::deleteRel()")," function confirms that the relation is closed and then calls the ",(0,r.kt)("inlineCode",{parentName:"p"},"BlockAccess::deleteRelation()")," function to delete the relation (we will implement this function later in this stage)."),(0,r.kt)("details",null,(0,r.kt)("summary",null,"Schema/Schema.cpp"),(0,r.kt)("p",null,"Implement the following functions looking at their respective design docs"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/docs/Design/Schema%20Layer#schema--createrel"},(0,r.kt)("inlineCode",{parentName:"a"},"Schema::createRel()"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/docs/Design/Schema%20Layer#schema--deleterel"},(0,r.kt)("inlineCode",{parentName:"a"},"Schema::deleteRel()"))))),(0,r.kt)("p",null,"The creation/deletion of a relation modifies the ",(0,r.kt)("inlineCode",{parentName:"p"},"numRecords")," entry in the relation cache for the relation and attribute catalog. In the previous stage, we had implemented write-back for a cache entry on closing of the relation. In this stage, we update the destructor of the ",(0,r.kt)("a",{parentName:"p",href:"/docs/Design/Cache%20Layer/OpenRelTable"},"class OpenRelTable")," to handle the write-back for the relation."),(0,r.kt)("details",null,(0,r.kt)("summary",null,"Cache/OpenRelTable.cpp"),(0,r.kt)("p",null,"Implement the ",(0,r.kt)("inlineCode",{parentName:"p"},"OpenRelTable::~OpenRelTable()")," function by looking at the ",(0,r.kt)("a",{parentName:"p",href:"/docs/Design/Cache%20Layer/OpenRelTable#openreltable--openreltable-destructor"},"design docs"),".")),(0,r.kt)("p",null,"In the ",(0,r.kt)("a",{parentName:"p",href:"/docs/Design/Buffer%20Layer/intro"},"Buffer Layer"),", we implement the ",(0,r.kt)("inlineCode",{parentName:"p"},"BlockBuffer::releaseBlock()")," function which takes a block number as an argument and frees that block in the buffer and the block allocation map, thus making the block available for use again."),(0,r.kt)("details",null,(0,r.kt)("summary",null,"Buffer/BlockBuffer.cpp"),(0,r.kt)("p",null,"Implement the ",(0,r.kt)("inlineCode",{parentName:"p"},"BlockBuffer::releaseBlock()")," function by looking at the ",(0,r.kt)("a",{parentName:"p",href:"/docs/Design/Buffer%20Layer/BlockBuffer#blockbuffer--releaseblock"},"design docs"),".")),(0,r.kt)("p",null,"In the ",(0,r.kt)("a",{parentName:"p",href:"/docs/Design/Block%20Access%20Layer"},"Block Access Layer"),", we implement the ",(0,r.kt)("inlineCode",{parentName:"p"},"search()")," function and the ",(0,r.kt)("inlineCode",{parentName:"p"},"deleteRelation()")," function."),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"search()")," function in it's final state will be used to either do a linear search or a b-plus tree search on the records of a relation depending on whether an index exists for the relation. However, since we have not implemented indexes yet, our current implementation will just call the ",(0,r.kt)("inlineCode",{parentName:"p"},"linearSearch()")," function."),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"deleteRelation()")," function releases all the record blocks of the relation and deletes the relation's entries from the relation and attribute catalog. If the deletion of the entries in the attribute catalog causes one of its blocks to be completely unoccupied, we release that block as well. We then update the changes in the records of the catalogs in the catalog caches."),(0,r.kt)("details",null,(0,r.kt)("summary",null,"BlockAccess/BlockAccess.cpp"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"int BlockAccess::search(int relId, Attribute *record, char attrName[ATTR_SIZE], Attribute attrVal, int op) {\n    // Declare a variable called recid to store the searched record\n    RecId recId;\n\n    /* search for the record id (recid) corresponding to the attribute with\n    attribute name attrName, with value attrval and satisfying the condition op\n    using linearSearch() */\n\n    // if there's no record satisfying the given condition (recId = {-1, -1})\n    //    return E_NOTFOUND;\n\n    /* Copy the record with record id (recId) to the record buffer (record)\n       For this Instantiate a RecBuffer class object by passing the recId and\n       call the appropriate method to fetch the record\n    */\n\n    return SUCCESS;\n}\n")),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},(0,r.kt)("strong",{parentName:"p"},"TASK"),": Implement the ",(0,r.kt)("inlineCode",{parentName:"p"},"BlockAccess::deleteRelation()")," method by looking at the ",(0,r.kt)("a",{parentName:"p",href:"/docs/Design/Block%20Access%20Layer#blockaccess--deleterelation"},"design docs"),". The algorithm specified in the docs calls ",(0,r.kt)("inlineCode",{parentName:"p"},"BPlusTree::bPlusDestroy()")," to free any indexes that exist for the relation. Since we have not yet implemented indexing, this call can be omitted. The rest of the design remains the same."))),(0,r.kt)("p",null,"Your NITCbase now supports the creation of relations. With that, we have now implemented all the core functionality for storing data in our database. We can now create relations, insert records into it and search for these records. Quite some progress!"),(0,r.kt)("h2",{id:"exercises"},"Exercises"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Q1"),". In your NITCbase, run the following command to fetch the details of the attribute catalog from the relation catalog."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT * FROM RELATIONCAT INTO null WHERE RelName=ATTRIBUTECAT\n")),(0,r.kt)("p",null,"Make note of the value of the ",(0,r.kt)("inlineCode",{parentName:"p"},"LastBlock")," field of the attribute catalog. Then, create the following relations using the ",(0,r.kt)("a",{parentName:"p",href:"/docs/User%20Interface%20Commands/ddl#create-table"},"CREATE TABLE")," command and insert all the records from ",(0,r.kt)("a",{target:"_blank",href:n(9137).Z},"this csv file")," into the relation ",(0,r.kt)("inlineCode",{parentName:"p"},"Products"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"Products(id NUM, name STR, cost NUM, stock NUM, color STR)\nStores(id NUM, name STR, owner STR, location STR, startDate STR)\nSales(id NUM, storeId NUM, productId NUM, purchaser STR, discount NUM, billId NUM)\nBills(id NUM, totalCost NUM, tax NUM, tip NUM)\n")),(0,r.kt)("p",null,"Now, run the following commands ",(0,r.kt)("strong",{parentName:"p"},"in the XFS Interface")," to verify the creation of the relations. (Note that you need to ",(0,r.kt)("strong",{parentName:"p"},"exit from NITCbase before starting the XFS Interface"),". refer: ",(0,r.kt)("a",{parentName:"p",href:"/docs/Roadmap/Stage01#the-disk-class"},"runtime disk"),")"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"dump relcat\ndump attrcat\nprint table Products\n")),(0,r.kt)("p",null,"Open ",(0,r.kt)("inlineCode",{parentName:"p"},"Files/Output_Files/relation_catalog")," and verify that the new relations are present in the relation catalog. Also, ensure that the ",(0,r.kt)("inlineCode",{parentName:"p"},"LastBlock")," of the attribute catalog is now pointing to a new block."),(0,r.kt)("p",null,"Open ",(0,r.kt)("inlineCode",{parentName:"p"},"Files/Output_Files/attribute_catalog")," and verify that the new attributes have been added to the attribute catalog."),(0,r.kt)("p",null,"Now, ",(0,r.kt)("strong",{parentName:"p"},"in your NITCbase"),", delete the relation ",(0,r.kt)("inlineCode",{parentName:"p"},"Products")," using the ",(0,r.kt)("a",{parentName:"p",href:"/docs/User%20Interface%20Commands/ddl#drop-table"},"DROP TABLE")," command."),(0,r.kt)("p",null,"Run the following commands to print all the entries in the relation and attribute catalog and ensure that the results you get are consistent."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"SELECT * FROM RELATIONCAT INTO null WHERE #Attributes>0\nSELECT * FROM ATTRIBUTECAT INTO null WHERE Offset>=0\n")),(0,r.kt)("p",null,"Then, delete the relations ",(0,r.kt)("inlineCode",{parentName:"p"},"Stores"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"Sales")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Bills")," that we created above using the ",(0,r.kt)("a",{parentName:"p",href:"/docs/User%20Interface%20Commands/ddl#drop-table"},"DROP TABLE")," command. Run the following commands to verify that the deletion has completed successfully."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT * FROM RELATIONCAT INTO null WHERE RelName=ATTRIBUTECAT\nSELECT * FROM ATTRIBUTECAT INTO null WHERE Offset>=0\n")),(0,r.kt)("p",null,"Ensure that the ",(0,r.kt)("inlineCode",{parentName:"p"},"LastBlock")," field of the attribute catalog has returned to the value you had noted earlier (the newly allocated block should've been released). Also, verify that the contents of the attribute catalog are as expected."))}p.isMDXComponent=!0},9137:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/files/s8products-a11e35aaa0866dcd1bfe9b00353ff4eb.txt"}}]);