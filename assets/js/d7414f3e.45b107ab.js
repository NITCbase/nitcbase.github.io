"use strict";(self.webpackChunknitcbase=self.webpackChunknitcbase||[]).push([[3427],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>p});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),c=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},d=function(e){var t=c(e.components);return a.createElement(s.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,s=e.parentName,d=i(e,["components","mdxType","originalType","parentName"]),u=c(n),p=r,m=u["".concat(s,".").concat(p)]||u[p]||h[p]||o;return n?a.createElement(m,l(l({ref:t},d),{},{components:n})):a.createElement(m,l({ref:t},d))}));function p(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,l=new Array(o);l[0]=u;var i={};for(var s in t)hasOwnProperty.call(t,s)&&(i[s]=t[s]);i.originalType=e,i.mdxType="string"==typeof e?e:r,l[1]=i;for(var c=2;c<o;c++)l[c]=n[c];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},1150:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>l,default:()=>h,frontMatter:()=>o,metadata:()=>i,toc:()=>c});var a=n(7462),r=(n(7294),n(3905));const o={sidebar_position:5,title:"Block Access Layer"},l=void 0,i={unversionedId:"Design/Block Access Layer",id:"Design/Block Access Layer",title:"Block Access Layer",description:"The files corresponding to this layer can be found in the BlockAccess directory. The code is to be written in the file BlockAccess.cpp. The declaration for the functions can be found in the header file BlockAccess.h.",source:"@site/docs/Design/Block Access Layer.md",sourceDirName:"Design",slug:"/Design/Block Access Layer",permalink:"/docs/Design/Block Access Layer",draft:!1,tags:[],version:"current",sidebarPosition:5,frontMatter:{sidebar_position:5,title:"Block Access Layer"},sidebar:"Design",previous:{title:"Schema Layer",permalink:"/docs/Design/Schema Layer"},next:{title:"B+ Tree Layer",permalink:"/docs/Design/B+ Tree Layer"}},s={},c=[{value:"Layout",id:"layout",level:2},{value:"class BlockAccess",id:"class-blockaccess",level:2},{value:"BlockAccess :: linearSearch()",id:"blockaccess--linearsearch",level:3},{value:"Description",id:"description",level:4},{value:"Arguments",id:"arguments",level:4},{value:"Return Values",id:"return-values",level:4},{value:"Algorithm",id:"algorithm",level:4},{value:"BlockAccess :: search()",id:"blockaccess--search",level:3},{value:"Description",id:"description-1",level:4},{value:"Arguments",id:"arguments-1",level:4},{value:"Return Values",id:"return-values-1",level:4},{value:"Algorithm",id:"algorithm-1",level:4},{value:"BlockAccess :: insert()",id:"blockaccess--insert",level:3},{value:"Description",id:"description-2",level:4},{value:"Arguments",id:"arguments-2",level:4},{value:"Return Values",id:"return-values-2",level:4},{value:"Algorithm",id:"algorithm-2",level:4},{value:"BlockAccess :: renameRelation()",id:"blockaccess--renamerelation",level:3},{value:"Description",id:"description-3",level:4},{value:"Arguments",id:"arguments-3",level:4},{value:"Return Values",id:"return-values-3",level:4},{value:"Algorithm",id:"algorithm-3",level:4},{value:"BlockAccess :: renameAttribute()",id:"blockaccess--renameattribute",level:3},{value:"Description",id:"description-4",level:4},{value:"Arguments",id:"arguments-4",level:4},{value:"Return Values",id:"return-values-4",level:4},{value:"Algorithm",id:"algorithm-4",level:4},{value:"BlockAccess :: deleteRelation()",id:"blockaccess--deleterelation",level:3},{value:"Description",id:"description-5",level:4},{value:"Arguments",id:"arguments-5",level:4},{value:"Return Values",id:"return-values-5",level:4},{value:"Algorithm",id:"algorithm-5",level:4},{value:"BlockAccess :: project()",id:"blockaccess--project",level:3},{value:"Description",id:"description-6",level:4},{value:"Arguments",id:"arguments-6",level:4},{value:"Return Values",id:"return-values-6",level:4},{value:"Algorithm",id:"algorithm-6",level:4}],d={toc:c};function h(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("admonition",{title:"note",type:"info"},(0,r.kt)("p",{parentName:"admonition"},"The files corresponding to this layer can be found in the ",(0,r.kt)("inlineCode",{parentName:"p"},"BlockAccess")," directory. The code is to be written in the file ",(0,r.kt)("inlineCode",{parentName:"p"},"BlockAccess.cpp"),". The declaration for the functions can be found in the header file ",(0,r.kt)("inlineCode",{parentName:"p"},"BlockAccess.h"),"."),(0,r.kt)("p",{parentName:"admonition"},(0,r.kt)("a",{parentName:"p",href:"/docs/Misc/stub/block_access"},(0,r.kt)("strong",{parentName:"a"},"The stub code for this layer can be found here.")))),(0,r.kt)("h2",{id:"layout"},"Layout"),(0,r.kt)("p",null,"In any database management system, in order to retrieve data from the database or to alter the schema of the relations in the database, the system has to work with the disk blocks. ",(0,r.kt)("em",{parentName:"p"},"Block Access layer provides an abstraction that hides the disk structures to the above layers (",(0,r.kt)("a",{parentName:"em",href:"/docs/Design/Algebra%20Layer"},"Algebra layer")," and ",(0,r.kt)("a",{parentName:"em",href:"/docs/Design/Schema%20Layer"},"Schema layer"),")"),"."),(0,r.kt)("p",null,"The ",(0,r.kt)("em",{parentName:"p"},"block access layer also provides an interface to the above layers in terms of records instead of disk blocks.")," Hence, the Block Access layer processes the requests for update/retrieval from the algebra and schema layers and works with disk blocks that are buffered by the ",(0,r.kt)("a",{parentName:"p",href:"/docs/Design/Buffer%20Layer/intro"},(0,r.kt)("em",{parentName:"a"},"Buffer layer")),"."),(0,r.kt)("p",null,"NITCbase follows an Object-Oriented design for Block Access Layer. The class definition is as shown below."),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"class-blockaccess"},"class BlockAccess"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"class BlockAccess {\npublic:\n\n    static int search(int relId, Attribute *record, char attrName[ATTR_SIZE], Attribute attrVal, int op,\n        int flagValidAttrName);\n\n    static int insert(int relId, union Attribute *record);\n\n    static int renameRelation(char oldName[ATTR_SIZE], char newName[ATTR_SIZE]);\n\n    static int renameAttribute(char relName[ATTR_SIZE], char oldName[ATTR_SIZE], char newName[ATTR_SIZE]);\n\n    static int deleteRelation(char relName[ATTR_SIZE]);\n\n    static RecId linearSearch(int relId, char attrName[ATTR_SIZE], Attribute attrVal, int op);\n\n    static int project(int relId, Attribute *record);\n\n};\n")),(0,r.kt)("h3",{id:"blockaccess--linearsearch"},"BlockAccess :: linearSearch()"),(0,r.kt)("h4",{id:"description"},"Description"),(0,r.kt)("p",null,"This method searches the relation specified linearly to find the next record that satisfies the specified condition. The condition value is given by the argument ",(0,r.kt)("inlineCode",{parentName:"p"},"attrVal"),". This function returns the recId of the next record satisfying the condition. The condition that is checked for is the following."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"value-in-record `op` attrVal\n")),(0,r.kt)("h4",{id:"arguments"},"Arguments"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Name")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Type")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Description")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"relId"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"int")),(0,r.kt)("td",{parentName:"tr",align:null},"rel-id of relation to which search has to be made.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"attrName"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"char[ATTR_SIZE]")),(0,r.kt)("td",{parentName:"tr",align:null},"Attribute/column name to which condition need to be checked against.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"attrVal"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"union Attribute")),(0,r.kt)("td",{parentName:"tr",align:null},"value of attribute that has to be checked against the value in the record.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"op"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"int")),(0,r.kt)("td",{parentName:"tr",align:null},"The conditional operator (which can be one among ",(0,r.kt)("inlineCode",{parentName:"td"},"EQ"),", ",(0,r.kt)("inlineCode",{parentName:"td"},"LE"),", ",(0,r.kt)("inlineCode",{parentName:"td"},"LT"),", ",(0,r.kt)("inlineCode",{parentName:"td"},"GE"),", ",(0,r.kt)("inlineCode",{parentName:"td"},"GT"),", ",(0,r.kt)("inlineCode",{parentName:"td"},"NE")," corresponding to the following operators: ",(0,r.kt)("em",{parentName:"td"},"equal to, less than or equal to, less than, greater than or equal to, greater than, not equal to"),")")))),(0,r.kt)("h4",{id:"return-values"},"Return Values"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Value")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Description")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"{block#, slot#}")),(0,r.kt)("td",{parentName:"tr",align:null},"returns the ",(0,r.kt)("em",{parentName:"td"},"block number and slot number")," of the record corresponding to the next hit. This corresponds to type ",(0,r.kt)("inlineCode",{parentName:"td"},"RecId"),".")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"{-1, -1}")),(0,r.kt)("td",{parentName:"tr",align:null},"If no valid next hit is found. This corresponds to type ",(0,r.kt)("inlineCode",{parentName:"td"},"RecId"),".")))),(0,r.kt)("admonition",{title:"note",type:"info"},(0,r.kt)("ul",{parentName:"admonition"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},'This function reads the "next" record from the given relation that satisfies a given condition. The search index of the relation (stored in the ',(0,r.kt)("a",{parentName:"p",href:"/docs/Design/Cache%20Layer/RelCacheTable"},"RelCacheTable")," entry of the relation) is used to identify the location of the previous record that was returned. This function reads the next record and updates the value of the search index to the position of the newly read record, before passing the record to the caller.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"If ",(0,r.kt)("inlineCode",{parentName:"p"},"searchIndex")," was reset to ",(0,r.kt)("inlineCode",{parentName:"p"},"{-1,-1}")," before the call, this function starts reading from the beginning and returns the first record of the relation that satisfies the condition. The ",(0,r.kt)("inlineCode",{parentName:"p"},"RelCacheTable::resetSearchIndex()")," function may be used to reset the value of the search index.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"If the ",(0,r.kt)("inlineCode",{parentName:"p"},"searchIndex")," value of a relation corresponds to the last record of the relation that satisfies the condition, this function will return ",(0,r.kt)("inlineCode",{parentName:"p"},"{-1, -1}"),', as there is no "next" record to be read.')),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"If ",(0,r.kt)("inlineCode",{parentName:"p"},"searchIndex")," has reached the last record of the relation, it is the responsibility of the caller to reset the search index if it is required that the function starts reading from the beginning of the relation again. If not done, every subsequent call to this function will return ",(0,r.kt)("inlineCode",{parentName:"p"},"{-1, -1}"),".")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"The ",(0,r.kt)("a",{parentName:"p",href:"#blockaccess--linearsearch"},(0,r.kt)("inlineCode",{parentName:"a"},"linearSearch()"))," and ",(0,r.kt)("inlineCode",{parentName:"p"},"project()")," functions make use of the same search index. Hence, changes in the value of ",(0,r.kt)("inlineCode",{parentName:"p"},"searchIndex")," will affect the functioning of both these functions.")))),(0,r.kt)("h4",{id:"algorithm"},"Algorithm"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'RecId BlockAccess::linearSearch(int relId, char attrName[ATTR_SIZE], union Attribute attrVal, int op) {\n    // get the previous search index of the relation relId from the relation cache\n    // (use RelCacheTable::getSearchIndex() function)\n\n    // let block and slot denote the record id of the record being currently checked\n\n    // if the current search index record is invalid(i.e. both block and slot = -1)\n    if (prevRecId.block == -1 && prevRecId.slot == -1)\n    {\n        // (no hits from previous search; search should start from the\n        // first record itself)\n\n        // get the first record block of the relation from the relation cache\n        // (use RelCacheTable::getRelCatEntry() function of Cache Layer)\n\n        // block = first record block of the relation\n        // slot = 0\n    }\n    else\n    {\n        // (there is a hit from previous search; search should start from\n        // the record next to the search index record)\n\n        // block = search index\'s block\n        // slot = search index\'s slot + 1\n    }\n\n    /* The following code searches for the next record in the relation\n       that satisfies the given condition\n       We start from the record id (block, slot) and iterate over the remaining\n       records of the relation\n    */\n    while (block != -1)\n    {\n        /* create a RecBuffer object for block (use RecBuffer Constructor for\n           existing block) */\n\n        // get the record with id (block, slot) using RecBuffer::getRecord()\n        // get header of the block using RecBuffer::getHeader() function\n        // get slot map of the block using RecBuffer::getSlotMap() function\n\n        // If slot >= the number of slots per block(i.e. no more slots in this block)\n        {\n            // update block = right block of block\n            // update slot = 0\n            continue;  // continue to the beginning of this while loop\n        }\n\n        // if slot is free skip the loop\n        // (i.e. check if slot\'th entry in slot map of block contains SLOT_UNOCCUPIED)\n        {\n            // increment slot and continue to the next record slot\n        }\n\n        // compare record\'s attribute value to the the given attrVal as below:\n        /*\n            firstly get the attribute offset for the attrName attribute\n            from the attribute cache entry of the relation using\n            AttrCacheTable::getAttrCatEntry()\n        */\n        /* use the attribute offset to get the value of the attribute from\n           current record */\n\n        int cmpVal;  // will store the difference between the attributes\n        // set cmpVal using compareAttrs()\n\n        /* Next task is to check whether this record satisfies the given condition.\n           It is determined based on the output of previous comparison and\n           the op value received.\n           The following code sets the cond variable if the condition is satisfied.\n        */\n        if (\n            (op == NE && cmpVal != 0) ||    // if op is "not equal to"\n            (op == LT && cmpVal < 0) ||     // if op is "less than"\n            (op == LE && cmpVal <= 0) ||    // if op is "less than or equal to"\n            (op == EQ && cmpVal == 0) ||    // if op is "equal to"\n            (op == GT && cmpVal > 0) ||     // if op is "greater than"\n            (op == GE && cmpVal >= 0)       // if op is "greater than or equal to"\n        ) {\n            /*\n            set the search index in the relation cache as\n            the record id of the record that satisfies the given condition\n            (use RelCacheTable::setSearchIndex function)\n            */\n\n            return RecId{block, slot};\n        }\n\n        slot++;\n    }\n\n    // no record in the relation with Id relid satisfies the given condition\n    return RecId{-1, -1};\n}\n')),(0,r.kt)("h3",{id:"blockaccess--search"},"BlockAccess :: search()"),(0,r.kt)("h4",{id:"description-1"},"Description"),(0,r.kt)("p",null,"This method searches the relation specified to find the next record that satisfies the specified condition on attribute attrVal and updates the corresponding search index in the cache entry of the relation. It uses the B+ tree if target attribute is indexed, otherwise, it does linear search."),(0,r.kt)("h4",{id:"arguments-1"},"Arguments"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Name")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Type")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Description")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"relId"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"int")),(0,r.kt)("td",{parentName:"tr",align:null},"rel-id of relation to which search has to be made.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"record"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"union Attribute*")),(0,r.kt)("td",{parentName:"tr",align:null},"pointer to record where next found record satisfying given condition is to be placed.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"attrName"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"char[ATTR_SIZE]")),(0,r.kt)("td",{parentName:"tr",align:null},"Attribute/column name to which condition need to be checked with.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"attrVal"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"union Attribute")),(0,r.kt)("td",{parentName:"tr",align:null},"value of attribute that has to be checked against the operater.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"op"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"int")),(0,r.kt)("td",{parentName:"tr",align:null},"Conditional Operator (can be one among ",(0,r.kt)("inlineCode",{parentName:"td"},"EQ")," , ",(0,r.kt)("inlineCode",{parentName:"td"},"LE")," , ",(0,r.kt)("inlineCode",{parentName:"td"},"LT")," , ",(0,r.kt)("inlineCode",{parentName:"td"},"GE")," , ",(0,r.kt)("inlineCode",{parentName:"td"},"GT")," , ",(0,r.kt)("inlineCode",{parentName:"td"},"NE")," corresponding to equal, less or than equal, less than ,greater than or equal, greater than, not equal operators respectively).")))),(0,r.kt)("h4",{id:"return-values-1"},"Return Values"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Value")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Description")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/docs/constants"},(0,r.kt)("inlineCode",{parentName:"a"},"SUCCESS"))),(0,r.kt)("td",{parentName:"tr",align:null},"On successful copy of record to record")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/docs/constants"},(0,r.kt)("inlineCode",{parentName:"a"},"E_NOTFOUND"))),(0,r.kt)("td",{parentName:"tr",align:null},"If it fails to find a record satisfying the given condition")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/docs/constants"},(0,r.kt)("inlineCode",{parentName:"a"},"E_OUTOFBOUND"))),(0,r.kt)("td",{parentName:"tr",align:null},"Input relId is outside the valid set of possible relation ids")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/docs/constants"},(0,r.kt)("inlineCode",{parentName:"a"},"E_RELNOTOPEN"))),(0,r.kt)("td",{parentName:"tr",align:null},"Entry corresponding to ",(0,r.kt)("inlineCode",{parentName:"td"},"relId")," is free in the cache")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/docs/constants"},(0,r.kt)("inlineCode",{parentName:"a"},"E_ATTRNOTEXIST"))),(0,r.kt)("td",{parentName:"tr",align:null},"No attribute with the input attribute name exists")))),(0,r.kt)("admonition",{title:"note",type:"info"},(0,r.kt)("ul",{parentName:"admonition"},(0,r.kt)("li",{parentName:"ul"},'This function reads the "next" record from the given relation that satisfies a given condition. It can do either a linear search using ',(0,r.kt)("inlineCode",{parentName:"li"},"BlockAccess::linearSearch()")," or a B+ search using ",(0,r.kt)("inlineCode",{parentName:"li"},"BPlusTree::bPlussearch()")," depending on whether an index exists."),(0,r.kt)("li",{parentName:"ul"},"If a linear search is being done, it is required that the search index of the relation is reset in the relation cache with a call to the ",(0,r.kt)("inlineCode",{parentName:"li"},"RelCacheTable::resetSearchIndex()")," function."),(0,r.kt)("li",{parentName:"ul"},"Subsequent search operations will read from the search index and return the corresponding record. The search index is then advanced so that the search continues from the next record"),(0,r.kt)("li",{parentName:"ul"},"Once the last record satisfying the condition is returned, every subsequent call to this function will return ",(0,r.kt)("a",{parentName:"li",href:"/docs/constants"},"E_NOTFOUND"),"."),(0,r.kt)("li",{parentName:"ul"},"This function assumes that the search query has been validated by the caller before the call to this function. Validation includes checking for whether the operator is valid, whether the type of the value passed is compatible with the actual attribute type and so on."))),(0,r.kt)("h4",{id:"algorithm-1"},"Algorithm"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"int BlockAccess::search(int relId, Attribute *record, char attrName[ATTR_SIZE], Attribute attrVal, int op) {\n    // Declare a variable called recid to store the searched record\n    RecId recId;\n\n    /* get the attribute catalog entry from the attribute cache corresponding\n    to the relation with Id=relid and with attribute_name=attrName  */\n\n    // if this call returns an error, return the appropriate error code\n\n    // get rootBlock from the attribute catalog entry\n    /* if Index does not exist for the attribute (check rootBlock == -1) */ {\n\n        /* search for the record id (recid) corresponding to the attribute with\n           attribute name attrName, with value attrval and satisfying the\n           condition op using linearSearch()\n        */\n    }\n\n    /* else */ {\n        // (index exists for the attribute)\n\n        /* search for the record id (recid) correspoding to the attribute with\n        attribute name attrName and with value attrval and satisfying the\n        condition op using BPlusTree::bPlusSearch() */\n    }\n\n\n    // if there's no record satisfying the given condition (recId = {-1, -1})\n    //     return E_NOTFOUND;\n\n    /* Copy the record with record id (recId) to the record buffer (record).\n       For this, instantiate a RecBuffer class object by passing the recId and\n       call the appropriate method to fetch the record\n    */\n\n    return SUCCESS;\n}\n")),(0,r.kt)("h3",{id:"blockaccess--insert"},"BlockAccess :: insert()"),(0,r.kt)("h4",{id:"description-2"},"Description"),(0,r.kt)("p",null,"This method inserts the record into relation as specified in arguments."),(0,r.kt)("h4",{id:"arguments-2"},"Arguments"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Name")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Type")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Description")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"relId"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"int")),(0,r.kt)("td",{parentName:"tr",align:null},"rel-id of relation to which record is to be inserted")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"record"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"union Attribute*")),(0,r.kt)("td",{parentName:"tr",align:null},"Pointer to record(containing values for all the attributes), ",(0,r.kt)("inlineCode",{parentName:"td"},"record")," is an array of Attribute type")))),(0,r.kt)("h4",{id:"return-values-2"},"Return Values"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Value")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Description")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/docs/constants"},(0,r.kt)("inlineCode",{parentName:"a"},"SUCCESS"))),(0,r.kt)("td",{parentName:"tr",align:null},"On successful insert of the given record")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/docs/constants"},(0,r.kt)("inlineCode",{parentName:"a"},"E_INDEX_BLOCKS_RELEASED"))),(0,r.kt)("td",{parentName:"tr",align:null},"Record was inserted successfully, but the index existing on one or more attributes had to be deleted due to insufficient disk space")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/docs/constants"},(0,r.kt)("inlineCode",{parentName:"a"},"E_DISKFULL"))),(0,r.kt)("td",{parentName:"tr",align:null},"If disk space is not sufficient for inserting the record")))),(0,r.kt)("h4",{id:"algorithm-2"},"Algorithm"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"int BlockAccess::insert(int relId, Attribute *record) {\n    // get the relation catalog entry from relation cache\n    // ( use RelCacheTable::getRelCatEntry() of Cache Layer)\n\n    int blockNum = /* first record block of the relation (from the rel-cat entry)*/;\n\n    // rec_id will be used to store where the new record will be inserted\n    RecId rec_id = {-1, -1};\n\n    int numOfSlots = /* number of slots per record block */;\n    int numOfAttributes = /* number of attributes of the relation */;\n\n    int prevBlockNum = /* block number of the last element in the linked list = -1 */;\n\n    /*\n        Traversing the linked list of existing record blocks of the relation\n        until a free slot is found OR\n        until the end of the list is reached\n    */\n    while (blockNum != -1) {\n        // create a RecBuffer object for blockNum (using appropriate constructor!)\n\n        // get header of block(blockNum) using RecBuffer::getHeader() function\n\n        // get slot map of block(blockNum) using RecBuffer::getSlotMap() function\n\n        // search for free slot in the block 'blockNum' and store it's rec-id in rec_id\n        // (Free slot can be found by iterating over the slot map of the block)\n        /* slot map stores SLOT_UNOCCUPIED if slot is free and\n           SLOT_OCCUPIED if slot is occupied) */\n\n        /* if a free slot is found, set rec_id and discontinue the traversal\n           of the linked list of record blocks (break from the loop) */\n\n        /* otherwise, continue to check the next block by updating the\n           block numbers as follows:\n              update prevBlockNum = blockNum\n              update blockNum = header.rblock (next element in the linked\n                                               list of record blocks)\n        */\n    }\n\n    //  if no free slot is found in existing record blocks (rec_id = {-1, -1})\n    {\n        // if relation is RELCAT, do not allocate any more blocks\n        //     return E_MAXRELATIONS;\n\n        // Otherwise,\n        // get a new record block (using the appropriate RecBuffer constructor!)\n        // get the block number of the newly allocated block\n        // (use BlockBuffer::getBlockNum() function)\n        // let ret be the return value of getBlockNum() function call\n        if (ret == E_DISKFULL) {\n            return E_DISKFULL;\n        }\n\n        // Assign rec_id.block = new block number(i.e. ret) and rec_id.slot = 0\n\n        /*\n            set the header of the new record block such that it links with\n            existing record blocks of the relation\n            set the block's header as follows:\n            blockType: REC, pblock: -1\n            lblock\n                  = -1 (if linked list of existing record blocks was empty\n                         i.e this is the first insertion into the relation)\n                  = prevBlockNum (otherwise),\n            rblock: -1, numEntries: 0,\n            numSlots: numOfSlots, numAttrs: numOfAttributes\n            (use BlockBuffer::setHeader() function)\n        */\n\n        /*\n            set block's slot map with all slots marked as free\n            (i.e. store SLOT_UNOCCUPIED for all the entries)\n            (use RecBuffer::setSlotMap() function)\n        */\n\n        // if prevBlockNum != -1\n        {\n            // create a RecBuffer object for prevBlockNum\n            // get the header of the block prevBlockNum and\n            // update the rblock field of the header to the new block\n            // number i.e. rec_id.block\n            // (use BlockBuffer::setHeader() function)\n        }\n        // else\n        {\n            // update first block field in the relation catalog entry to the\n            // new block (using RelCacheTable::setRelCatEntry() function)\n        }\n\n        // update last block field in the relation catalog entry to the\n        // new block (using RelCacheTable::setRelCatEntry() function)\n    }\n\n    // create a RecBuffer object for rec_id.block\n    // insert the record into rec_id'th slot using RecBuffer.setRecord())\n\n    /* update the slot map of the block by marking entry of the slot to\n       which record was inserted as occupied) */\n    // (ie store SLOT_OCCUPIED in free_slot'th entry of slot map)\n    // (use RecBuffer::getSlotMap() and RecBuffer::setSlotMap() functions)\n\n    // increment the numEntries field in the header of the block to\n    // which record was inserted\n    // (use BlockBuffer::getHeader() and BlockBuffer::setHeader() functions)\n\n    // Increment the number of records field in the relation cache entry for\n    // the relation. (use RelCacheTable::setRelCatEntry function)\n\n    //highlight-start\n    /* B+ Tree Insertions */\n    // (the following section is only relevant once indexing has been implemented)\n\n    int flag = SUCCESS;\n    // Iterate over all the attributes of the relation\n    // (let attrOffset be iterator ranging from 0 to numOfAttributes-1)\n    {\n        // get the attribute catalog entry for the attribute from the attribute cache\n        // (use AttrCacheTable::getAttrCatEntry() with args relId and attrOffset)\n\n        // get the root block field from the attribute catalog entry\n\n        // if index exists for the attribute(i.e. rootBlock != -1)\n        {\n            /* insert the new record into the attribute's bplus tree using\n             BPlusTree::bPlusInsert()*/\n            int retVal = BPlusTree::bPlusInsert(relId, attrCatEntry.attrName,\n                                                record[attrOffset], rec_id);\n\n            if (retVal == E_DISKFULL) {\n                //(index for this attribute has been destroyed)\n                // flag = E_INDEX_BLOCKS_RELEASED\n            }\n        }\n    }\n    //highlight-end\n\n    return flag;\n}\n")),(0,r.kt)("h3",{id:"blockaccess--renamerelation"},"BlockAccess :: renameRelation()"),(0,r.kt)("h4",{id:"description-3"},"Description"),(0,r.kt)("p",null,"This method changes the relation name of specified relation to the new name specified in arguments."),(0,r.kt)("h4",{id:"arguments-3"},"Arguments"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Name")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Type")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Description")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"oldName"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"char[ATTR_SIZE]")),(0,r.kt)("td",{parentName:"tr",align:null},"Old Name of relation of which name has to be changed")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"newName"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"char[ATTR_SIZE]")),(0,r.kt)("td",{parentName:"tr",align:null},"New name for the relation")))),(0,r.kt)("h4",{id:"return-values-3"},"Return Values"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Value")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Description")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/docs/constants"},(0,r.kt)("inlineCode",{parentName:"a"},"SUCCESS"))),(0,r.kt)("td",{parentName:"tr",align:null},"On successful renaming of the relation")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/docs/constants"},(0,r.kt)("inlineCode",{parentName:"a"},"E_RELNOTEXIST"))),(0,r.kt)("td",{parentName:"tr",align:null},"If the relation with name oldName does not exist")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/docs/constants"},(0,r.kt)("inlineCode",{parentName:"a"},"E_RELEXIST"))),(0,r.kt)("td",{parentName:"tr",align:null},"If the relation with name newName already exists")))),(0,r.kt)("h4",{id:"algorithm-3"},"Algorithm"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'int BlockAccess::renameRelation(char oldName[ATTR_SIZE], char newName[ATTR_SIZE]){\n    /* reset the searchIndex of the relation catalog using\n       RelCacheTable::resetSearchIndex() */\n\n    Attribute newRelationName;    // set newRelationName with newName\n\n    // search the relation catalog for an entry with "RelName" = newRelationName\n\n    // If relation with name newName already exists (result of linearSearch\n    //                                               is not {-1, -1})\n    //    return E_RELEXIST;\n\n\n    /* reset the searchIndex of the relation catalog using\n       RelCacheTable::resetSearchIndex() */\n\n    Attribute oldRelationName;    // set oldRelationName with oldName\n\n    // search the relation catalog for an entry with "RelName" = oldRelationName\n\n    // If relation with name oldName does not exist (result of linearSearch is {-1, -1})\n    //    return E_RELNOTEXIST;\n\n    /* get the relation catalog record of the relation to rename using a RecBuffer\n       on the relation catalog [RELCAT_BLOCK] and RecBuffer.getRecord function\n    */\n    /* update the relation name attribute in the record with newName.\n       (use RELCAT_REL_NAME_INDEX) */\n    // set back the record value using RecBuffer.setRecord\n\n    /*\n    update all the attribute catalog entries in the attribute catalog corresponding\n    to the relation with relation name oldName to the relation name newName\n    */\n\n    /* reset the searchIndex of the attribute catalog using\n       RelCacheTable::resetSearchIndex() */\n\n    //for i = 0 to numberOfAttributes :\n    //    linearSearch on the attribute catalog for relName = oldRelationName\n    //    get the record using RecBuffer.getRecord\n    //\n    //    update the relName field in the record to newName\n    //    set back the record using RecBuffer.setRecord\n\n    return SUCCESS;\n}\n')),(0,r.kt)("h3",{id:"blockaccess--renameattribute"},"BlockAccess :: renameAttribute()"),(0,r.kt)("h4",{id:"description-4"},"Description"),(0,r.kt)("p",null,"This method changes the name of an attribute/column present in a specified relation, to the new name specified in arguments."),(0,r.kt)("h4",{id:"arguments-4"},"Arguments"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Name")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Type")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Description")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"relName"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"char[ATTR_SIZE]")),(0,r.kt)("td",{parentName:"tr",align:null},"Name of the relation")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"oldName"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"char[ATTR_SIZE]")),(0,r.kt)("td",{parentName:"tr",align:null},"Old Name of attribute")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"newName"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"char[ATTR_SIZE]")),(0,r.kt)("td",{parentName:"tr",align:null},"New name for attribute")))),(0,r.kt)("h4",{id:"return-values-4"},"Return Values"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Value")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Description")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/docs/constants"},(0,r.kt)("inlineCode",{parentName:"a"},"SUCCESS"))),(0,r.kt)("td",{parentName:"tr",align:null},"On successful renaming of the attribute")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/docs/constants"},(0,r.kt)("inlineCode",{parentName:"a"},"E_RELNOTEXIST"))),(0,r.kt)("td",{parentName:"tr",align:null},"If the relation with name relName does not exist")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/docs/constants"},(0,r.kt)("inlineCode",{parentName:"a"},"E_ATTRNOTEXIST"))),(0,r.kt)("td",{parentName:"tr",align:null},"If the attribute with name oldName does not exist")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/docs/constants"},(0,r.kt)("inlineCode",{parentName:"a"},"E_ATTREXIST"))),(0,r.kt)("td",{parentName:"tr",align:null},"If the attribute with name newName already exists")))),(0,r.kt)("h4",{id:"algorithm-4"},"Algorithm"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"int BlockAccess::renameAttribute(char relName[ATTR_SIZE], char oldName[ATTR_SIZE], char newName[ATTR_SIZE]) {\n\n    /* reset the searchIndex of the relation catalog using\n       RelCacheTable::resetSearchIndex() */\n\n    Attribute relNameAttr;    // set relNameAttr to relName\n\n    // Search for the relation with name relName in relation catalog using linearSearch()\n    // If relation with name relName does not exist (search returns {-1,-1})\n    //    return E_RELNOTEXIST;\n\n    /* reset the searchIndex of the attribute catalog using\n       RelCacheTable::resetSearchIndex() */\n\n    /* declare variable attrToRenameRecId used to store the attr-cat recId\n    of the attribute to rename */\n    RecId attrToRenameRecId{-1, -1};\n    Attribute attrCatEntryRecord[ATTRCAT_NO_ATTRS];\n\n    /* iterate over all Attribute Catalog Entry record corresponding to the\n       relation to find the required attribute */\n    while (true) {\n        // linear search on the attribute catalog for RelName = relNameAttr\n\n        // if there are no more attributes left to check (linearSearch returned {-1,-1})\n        //     break;\n\n        /* Get the record from the attribute catalog using RecBuffer.getRecord\n          into attrCatEntryRecord */\n\n        // if attrCatEntryRecord.attrName = oldName\n        //     attrToRenameRecId = block and slot of this record\n\n        // if attrCatEntryRecord.attrName = newName\n        //     return E_ATTREXIST;\n    }\n\n    // if attrToRenameRecId == {-1, -1}\n    //     return E_ATTRNOTEXIST;\n\n\n    // Update the entry corresponding to the attribute in the Attribute Catalog Relation.\n    /*   declare a RecBuffer for attrToRenameRecId.block and get the record at\n         attrToRenameRecId.slot */\n    //   update the AttrName of the record with newName\n    //   set back the record with RecBuffer.setRecord\n\n    return SUCCESS;\n}\n")),(0,r.kt)("h3",{id:"blockaccess--deleterelation"},"BlockAccess :: deleteRelation()"),(0,r.kt)("h4",{id:"description-5"},"Description"),(0,r.kt)("p",null,"This method deletes the relation with the name specified as argument. This involves freeing the record blocks and index blocks allocated to this relation, as well as deleting the records corresponding to the relation in the relation catalog and attribute catalog."),(0,r.kt)("h4",{id:"arguments-5"},"Arguments"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Name")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Type")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Description")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"relName"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"char[ATTR_SIZE]")),(0,r.kt)("td",{parentName:"tr",align:null},"Name of relation to delete")))),(0,r.kt)("h4",{id:"return-values-5"},"Return Values"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Value")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Description")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/docs/constants"},(0,r.kt)("inlineCode",{parentName:"a"},"SUCCESS"))),(0,r.kt)("td",{parentName:"tr",align:null},"On successful deletion of the given relation")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/docs/constants"},(0,r.kt)("inlineCode",{parentName:"a"},"E_RELNOTEXIST"))),(0,r.kt)("td",{parentName:"tr",align:null},"If the relation does not exist")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/docs/constants"},(0,r.kt)("inlineCode",{parentName:"a"},"E_NOTPERMITTED"))),(0,r.kt)("td",{parentName:"tr",align:null},"If relName is either ",(0,r.kt)("em",{parentName:"td"},'"RELATIONCAT"')," or ",(0,r.kt)("em",{parentName:"td"},'"ATTRIBUTECAT"'),". i.e., when the user tries to delete the catalogs.")))),(0,r.kt)("h4",{id:"algorithm-5"},"Algorithm"),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"If at any point getHeader(), setHeader(), getRecord(), setRecord(), getSlotMap() or setSlotMap() methods of ",(0,r.kt)("a",{parentName:"p",href:"/docs/Design/Buffer%20Layer/intro"},"Buffer Layer")," are being called, make sure to get the return value and if it is not ",(0,r.kt)("a",{parentName:"p",href:"/docs/constants"},"SUCCESS"),", then to return the error code from the method.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'int BlockAccess::deleteRelation(char relName[ATTR_SIZE]) {\n    // if the relation to delete is either Relation Catalog or Attribute Catalog,\n    //     return E_NOTPERMITTED\n        // (check if the relation names are either "RELATIONCAT" and "ATTRIBUTECAT".\n        // you may use the following constants: RELCAT_NAME and ATTRCAT_NAME)\n\n    /* reset the searchIndex of the relation catalog using\n       RelCacheTable::resetSearchIndex() */\n\n    Attribute relNameAttr; // (stores relName as type union Attribute)\n    // assign relNameAttr.sVal = relName\n\n    //  linearSearch on the relation catalog for RelName = relNameAttr\n\n    // if the relation does not exist (linearSearch returned {-1, -1})\n    //     return E_RELNOTEXIST\n\n    Attribute relCatEntryRecord[RELCAT_NO_ATTRS];\n    /* store the relation catalog record corresponding to the relation in\n       relCatEntryRecord using RecBuffer.getRecord */\n\n    /* get the first record block of the relation (firstBlock) using the\n       relation catalog entry record */\n    /* get the number of attributes corresponding to the relation (numAttrs)\n       using the relation catalog entry record */\n\n    /*\n     Delete all the record blocks of the relation\n    */\n    // for each record block of the relation:\n    //     get block header using BlockBuffer.getHeader\n    //     get the next block from the header (rblock)\n    //     release the block using BlockBuffer.releaseBlock\n    //\n    //     Hint: to know if we reached the end, check if nextBlock = -1\n\n\n    /***\n        Deleting attribute catalog entries corresponding the relation and index\n        blocks corresponding to the relation with relName on its attributes\n    ***/\n\n    // reset the searchIndex of the attribute catalog\n\n    int numberOfAttributesDeleted = 0;\n\n    while(true) {\n        RecId attrCatRecId;\n        // attrCatRecId = linearSearch on attribute catalog for RelName = relNameAttr\n\n        // if no more attributes to iterate over (attrCatRecId == {-1, -1})\n        //     break;\n\n        numberOfAttributesDeleted++;\n\n        // create a RecBuffer for attrCatRecId.block\n        // get the header of the block\n        // get the record corresponding to attrCatRecId.slot\n\n        // declare variable rootBlock which will be used to store the root\n        // block field from the attribute catalog record.\n        int rootBlock = /* get root block from the record */;\n        // (This will be used later to delete any indexes if it exists)\n\n        // Update the Slotmap for the block by setting the slot as SLOT_UNOCCUPIED\n        // Hint: use RecBuffer.getSlotMap and RecBuffer.setSlotMap\n\n        /* Decrement the numEntries in the header of the block corresponding to\n           the attribute catalog entry and then set back the header\n           using RecBuffer.setHeader */\n\n        /* If number of entries become 0, releaseBlock is called after fixing\n           the linked list.\n        */\n        if (/*   header.numEntries == 0  */) {\n            /* Standard Linked List Delete for a Block\n               Get the header of the left block and set it\'s rblock to this\n               block\'s rblock\n            */\n\n            // create a RecBuffer for lblock and call appropriate methods\n\n            if (/* header.rblock != -1 */) {\n                /* Get the header of the right block and set it\'s lblock to\n                   this block\'s lblock */\n                // create a RecBuffer for rblock and call appropriate methods\n\n            } else {\n                // (the block being released is the "Last Block" of the relation.)\n                /* update the Relation Catalog entry\'s LastBlock field for this\n                   relation with the block number of the previous block. */\n            }\n\n            // (Since the attribute catalog will never be empty(why?), we do not\n            //  need to handle the case of the linked list becoming empty - i.e\n            //  every block of the attribute catalog gets released.)\n\n            // call releaseBlock()\n        }\n\n        //highlight-start\n        // (the following part is only relevant once indexing has been implemented)\n        // if index exists for the attribute (rootBlock != -1), call bplus destroy\n        if (rootBlock != -1) {\n            // delete the bplus tree rooted at rootBlock using BPlusTree::bPlusDestroy()\n        }\n        //highlight-end\n    }\n\n    /*** Delete the entry corresponding to the relation from relation catalog ***/\n    // Fetch the header of Relcat block\n\n    /* Decrement the numEntries in the header of the block corresponding to the\n       relation catalog entry and set it back */\n\n    /* Get the slotmap in relation catalog, update it by marking the slot as\n       free(SLOT_UNOCCUPIED) and set it back. */\n\n    /*** Updating the Relation Cache Table ***/\n    /** Update relation catalog record entry (number of records in relation\n        catalog is decreased by 1) **/\n    // Get the entry corresponding to relation catalog from the relation\n    // cache and update the number of records and set it back\n    // (using RelCacheTable::setRelCatEntry() function)\n\n    /** Update attribute catalog entry (number of records in attribute catalog\n        is decreased by numberOfAttributesDeleted) **/\n    // i.e., #Records = #Records - numberOfAttributesDeleted\n\n    // Get the entry corresponding to attribute catalog from the relation\n    // cache and update the number of records and set it back\n    // (using RelCacheTable::setRelCatEntry() function)\n\n    return SUCCESS;\n}\n')),(0,r.kt)("h3",{id:"blockaccess--project"},"BlockAccess :: project()"),(0,r.kt)("h4",{id:"description-6"},"Description"),(0,r.kt)("p",null,"This function is used to fetch ",(0,r.kt)("strong",{parentName:"p"},"one")," record of the relation. Each subsequent call would return the next record until there are no more records to be returned. It also updates ",(0,r.kt)("inlineCode",{parentName:"p"},"searchIndex")," in the cache."),(0,r.kt)("h4",{id:"arguments-6"},"Arguments"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Name")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Type")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Description")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"relId"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"int")),(0,r.kt)("td",{parentName:"tr",align:null},"rel-id of relation to which projection has to be done.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"record"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"union Attribute*")),(0,r.kt)("td",{parentName:"tr",align:null},"pointer to record where next record is to be placed.")))),(0,r.kt)("h4",{id:"return-values-6"},"Return Values"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Value")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Description")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/docs/constants"},(0,r.kt)("inlineCode",{parentName:"a"},"SUCCESS"))),(0,r.kt)("td",{parentName:"tr",align:null},"On successful copy of record to ",(0,r.kt)("em",{parentName:"td"},"record"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/docs/constants"},(0,r.kt)("inlineCode",{parentName:"a"},"E_NOTFOUND"))),(0,r.kt)("td",{parentName:"tr",align:null},"If there are no more records to be fetched for the relation")))),(0,r.kt)("admonition",{title:"note",type:"info"},(0,r.kt)("ul",{parentName:"admonition"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},'This function reads the "next" record from the given relation. The search index of the relation (stored in the ',(0,r.kt)("a",{parentName:"p",href:"/docs/Design/Cache%20Layer/RelCacheTable"},"RelCacheTable")," entry of the relation) is used to identify the location of the previous record that was returned. This function reads the next record and updates the value of the search index to the position of the newly read record, before passing the record to the caller.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"If ",(0,r.kt)("inlineCode",{parentName:"p"},"searchIndex")," is reset to ",(0,r.kt)("inlineCode",{parentName:"p"},"{-1,-1}"),", this function starts reading from the beginning and returns the first record of the relation. The ",(0,r.kt)("inlineCode",{parentName:"p"},"RelCacheTable::resetSearchIndex()")," function may be used to reset the value of the search index.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"If the ",(0,r.kt)("inlineCode",{parentName:"p"},"searchIndex")," value of a relation corresponds to the last record of the relation, this function will return ",(0,r.kt)("a",{parentName:"p",href:"/docs/constants"},"E_NOTFOUND"),', as there is no "next" record to be read.')),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"If ",(0,r.kt)("inlineCode",{parentName:"p"},"searchIndex")," has reached the last record of the relation, it is the responsibility of the caller to reset the search index if it is required that the function starts reading from the beginning of the relation again. If not done, every subsequent call to this function will return ",(0,r.kt)("a",{parentName:"p",href:"/docs/constants"},"E_NOTFOUND"),".")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"The ",(0,r.kt)("a",{parentName:"p",href:"#blockaccess--linearsearch"},(0,r.kt)("inlineCode",{parentName:"a"},"linearSearch()"))," and ",(0,r.kt)("inlineCode",{parentName:"p"},"project()")," functions make use of the same search index. Hence, changes in the value of ",(0,r.kt)("inlineCode",{parentName:"p"},"searchIndex")," will affect the functioning of both these functions.")))),(0,r.kt)("h4",{id:"algorithm-6"},"Algorithm"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"/*\nNOTE: the caller is expected to allocate space for the argument `record` based\n      on the size of the relation. This function will only copy the result of\n      the projection onto the array pointed to by the argument.\n*/\nint BlockAccess::project(int relId, Attribute *record) {\n    // get the previous search index of the relation relId from the relation\n    // cache (use RelCacheTable::getSearchIndex() function)\n\n    // declare block and slot which will be used to store the record id of the\n    // slot we need to check.\n    int block, slot;\n\n    /* if the current search index record is invalid(i.e. = {-1, -1})\n       (this only happens when the caller reset the search index)\n    */\n    if (prevRecId.block == -1 && prevRecId.slot == -1)\n    {\n        // (new project operation. start from beginning)\n\n        // get the first record block of the relation from the relation cache\n        // (use RelCacheTable::getRelCatEntry() function of Cache Layer)\n\n        // block = first record block of the relation\n        // slot = 0\n    }\n    else\n    {\n        // (a project/search operation is already in progress)\n\n        // block = previous search index's block\n        // slot = previous search index's slot + 1\n    }\n\n\n    // The following code finds the next record of the relation\n    /* Start from the record id (block, slot) and iterate over the remaining\n       records of the relation */\n    while (block != -1)\n    {\n        // create a RecBuffer object for block (using appropriate constructor!)\n\n        // get header of the block using RecBuffer::getHeader() function\n        // get slot map of the block using RecBuffer::getSlotMap() function\n\n        if(/* slot >= the number of slots per block*/)\n        {\n            // (no more slots in this block)\n            // update block = right block of block\n            // update slot = 0\n            // (NOTE: if this is the last block, rblock would be -1. this would\n            //        set block = -1 and fail the loop condition )\n        }\n        else if (/* slot is free */)\n        { // (i.e slot-th entry in slotMap contains SLOT_UNOCCUPIED)\n\n            // increment slot\n        }\n        else {\n            // (the next occupied slot / record has been found)\n            break;\n        }\n    }\n\n    if (block == -1){\n        // (a record was not found. all records exhausted)\n        return E_NOTFOUND;\n    }\n\n    // declare nextRecId to store the RecId of the record found\n    RecId nextRecId{block, slot};\n\n    // set the search index to nextRecId using RelCacheTable::setSearchIndex\n\n    /* Copy the record with record id (nextRecId) to the record buffer (record)\n       For this Instantiate a RecBuffer class object by passing the recId and\n       call the appropriate method to fetch the record\n    */\n\n    return SUCCESS;\n}\n")))}h.isMDXComponent=!0}}]);