"use strict";(self.webpackChunknitcbase=self.webpackChunknitcbase||[]).push([[1184],{3905:(e,t,a)=>{a.d(t,{Zo:()=>s,kt:()=>h});var n=a(7294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function l(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?l(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):l(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},l=Object.keys(e);for(n=0;n<l.length;n++)a=l[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(n=0;n<l.length;n++)a=l[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var p=n.createContext({}),d=function(e){var t=n.useContext(p),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},s=function(e){var t=d(e.components);return n.createElement(p.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},m=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,l=e.originalType,p=e.parentName,s=o(e,["components","mdxType","originalType","parentName"]),m=d(a),h=r,u=m["".concat(p,".").concat(h)]||m[h]||c[h]||l;return a?n.createElement(u,i(i({ref:t},s),{},{components:a})):n.createElement(u,i({ref:t},s))}));function h(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var l=a.length,i=new Array(l);i[0]=m;var o={};for(var p in t)hasOwnProperty.call(t,p)&&(o[p]=t[p]);o.originalType=e,o.mdxType="string"==typeof e?e:r,i[1]=o;for(var d=2;d<l;d++)i[d]=a[d];return n.createElement.apply(null,i)}return n.createElement.apply(null,a)}m.displayName="MDXCreateElement"},3495:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>p,contentTitle:()=>i,default:()=>c,frontMatter:()=>l,metadata:()=>o,toc:()=>d});var n=a(7462),r=(a(7294),a(3905));const l={title:"class RelCacheTable",sidebar_position:2},i=void 0,o={unversionedId:"Design/Cache Layer/RelCacheTable",id:"Design/Cache Layer/RelCacheTable",title:"class RelCacheTable",description:"The class RelCacheTable is used to cache Relation Catalog entries of all the open relations in NITCbase. The first two entries of the Relation Cache Table corresponding to RELCATRELID and ATTRCATRELID are reserved for storing the entries of Relation Catalog relation and Attribute Catalog relation, respectively. These are loaded into the cache by the _OpenRelTable constructor_ at the start of the session. These relations remain in the cache memory throughout the session and can only be closed by the _OpenRelTable destructor_ during shutdown.",source:"@site/docs/Design/Cache Layer/RelCacheTable.md",sourceDirName:"Design/Cache Layer",slug:"/Design/Cache Layer/RelCacheTable",permalink:"/docs/Design/Cache Layer/RelCacheTable",draft:!1,tags:[],version:"current",sidebarPosition:2,frontMatter:{title:"class RelCacheTable",sidebar_position:2},sidebar:"Design",previous:{title:"Introduction",permalink:"/docs/Design/Cache Layer/intro"},next:{title:"class AttrCacheTable",permalink:"/docs/Design/Cache Layer/AttrCacheTable"}},p={},d=[{value:"RelCacheTable :: getRelCatEntry",id:"relcachetable--getrelcatentry",level:3},{value:"Description",id:"description",level:4},{value:"Arguments",id:"arguments",level:4},{value:"Return Values",id:"return-values",level:4},{value:"Algorithm",id:"algorithm",level:4},{value:"RelCacheTable :: setRelCatEntry",id:"relcachetable--setrelcatentry",level:3},{value:"Description",id:"description-1",level:4},{value:"Arguments",id:"arguments-1",level:4},{value:"Return Values",id:"return-values-1",level:4},{value:"Algorithm",id:"algorithm-1",level:4},{value:"RelCacheTable :: getSearchIndex",id:"relcachetable--getsearchindex",level:3},{value:"Description",id:"description-2",level:4},{value:"Arguments",id:"arguments-2",level:4},{value:"Return Values",id:"return-values-2",level:4},{value:"Algorithm",id:"algorithm-2",level:4},{value:"RelCacheTable :: setSearchIndex",id:"relcachetable--setsearchindex",level:3},{value:"Description",id:"description-3",level:4},{value:"Arguments",id:"arguments-3",level:4},{value:"Return Values",id:"return-values-3",level:4},{value:"Algorithm",id:"algorithm-3",level:4},{value:"RelCacheTable :: resetSearchIndex",id:"relcachetable--resetsearchindex",level:3},{value:"Description",id:"description-4",level:4},{value:"Arguments",id:"arguments-4",level:4},{value:"Return Values",id:"return-values-4",level:4},{value:"Algorithm",id:"algorithm-4",level:4},{value:"RelCacheTable :: recordToRelCatEntry",id:"relcachetable--recordtorelcatentry",level:3},{value:"Description",id:"description-5",level:4},{value:"Arguments",id:"arguments-5",level:4},{value:"Return Values",id:"return-values-5",level:4},{value:"RelCacheTable :: relCatEntryToRecord",id:"relcachetable--relcatentrytorecord",level:3},{value:"Description",id:"description-6",level:4},{value:"Arguments",id:"arguments-6",level:4},{value:"Return Values",id:"return-values-6",level:4}],s={toc:d};function c(e){let{components:t,...a}=e;return(0,r.kt)("wrapper",(0,n.Z)({},s,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The class RelCacheTable is used to cache ",(0,r.kt)("em",{parentName:"p"},"Relation Catalog")," entries of all the ",(0,r.kt)("strong",{parentName:"p"},"open")," relations in NITCbase. The first two entries of the ",(0,r.kt)("em",{parentName:"p"},"Relation Cache")," Table corresponding to ",(0,r.kt)("inlineCode",{parentName:"p"},"RELCAT_RELID")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"ATTRCAT_RELID")," are reserved for storing the entries of ",(0,r.kt)("em",{parentName:"p"},"Relation Catalog")," relation and ",(0,r.kt)("em",{parentName:"p"},"Attribute Catalog")," relation, respectively. ",(0,r.kt)("strong",{parentName:"p"},"These are loaded into the cache by the ",(0,r.kt)("em",{parentName:"strong"},(0,r.kt)("inlineCode",{parentName:"em"},"OpenRelTable")," constructor")," at the start of the session. These relations remain in the cache memory throughout the session and can only be closed by the ",(0,r.kt)("em",{parentName:"strong"},(0,r.kt)("inlineCode",{parentName:"em"},"OpenRelTable")," destructor")," during shutdown.")),(0,r.kt)("p",null,"The class contains a ",(0,r.kt)("inlineCode",{parentName:"p"},"private")," member field, ",(0,r.kt)("inlineCode",{parentName:"p"},"relCache"),", which is an array of pointers to ",(0,r.kt)("inlineCode",{parentName:"p"},"struct RelCacheEntry")," with size ",(0,r.kt)("inlineCode",{parentName:"p"},"MAX_OPEN"),". For each relation opened, an entry is made in the array ",(0,r.kt)("inlineCode",{parentName:"p"},"relCache"),", at the index corresponding to the ",(0,r.kt)("em",{parentName:"p"},"relation id")," of the relation. This entry points to the ",(0,r.kt)("inlineCode",{parentName:"p"},"struct RelCacheEntry")," that stores all the attribute values of the relation's entry from the ",(0,r.kt)("em",{parentName:"p"},"Relation Catalog")," block along with other meta-data of the relation."),(0,r.kt)("p",null,"The class provides ",(0,r.kt)("inlineCode",{parentName:"p"},"public")," methods - ",(0,r.kt)("inlineCode",{parentName:"p"},"getRelCatEntry()")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"setRelCatEntry()")," to retrieve and update the ",(0,r.kt)("em",{parentName:"p"},"Relation Catalog")," Entry of a relation in the ",(0,r.kt)("em",{parentName:"p"},"Relation Cache")," Table. The class also provides ",(0,r.kt)("inlineCode",{parentName:"p"},"public")," methods ",(0,r.kt)("inlineCode",{parentName:"p"},"getSearchIndex()")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"setSearchIndex()")," for retrieving and updating the ",(0,r.kt)("inlineCode",{parentName:"p"},"searchIndex")," field of ",(0,r.kt)("em",{parentName:"p"},"Relation Cache")," Entry."),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"private")," method ",(0,r.kt)("inlineCode",{parentName:"p"},"recordToRelCatEntry()")," is used to convert a ",(0,r.kt)("em",{parentName:"p"},"record")," (implemented as an array of ",(0,r.kt)("inlineCode",{parentName:"p"},"union Attribute"),") to ",(0,r.kt)("inlineCode",{parentName:"p"},"RelCatEntry")," structure. This function is called by the friend class, ",(0,r.kt)("inlineCode",{parentName:"p"},"OpenRelTable"),", while opening a relation. Similarly, the ",(0,r.kt)("inlineCode",{parentName:"p"},"private")," method ",(0,r.kt)("inlineCode",{parentName:"p"},"relCatEntryToRecord()")," is used to convert ",(0,r.kt)("inlineCode",{parentName:"p"},"RelCatEntry")," structure to a record. This function is also called from the friend class, ",(0,r.kt)("inlineCode",{parentName:"p"},"OpenRelTable"),", while closing a relation."),(0,r.kt)("admonition",{title:"C++ Static Classes",type:"note"},(0,r.kt)("p",{parentName:"admonition"},(0,r.kt)("inlineCode",{parentName:"p"},"RelCacheTable")," is a ",(0,r.kt)("em",{parentName:"p"},"static class"),", that is, all member fields and methods are declared ",(0,r.kt)("inlineCode",{parentName:"p"},"static"),". Memory is allocated statically for all member fields of the class. This ",(0,r.kt)("em",{parentName:"p"},"static methods")," in this class is used to access its ",(0,r.kt)("em",{parentName:"p"},"static member fields"),". C++ allows static methods to be accessed using the semantics ",(0,r.kt)("inlineCode",{parentName:"p"},"class_name :: function_name()"),".")),(0,r.kt)("admonition",{title:"note",type:"info"},(0,r.kt)("p",{parentName:"admonition"},"The class ",(0,r.kt)("inlineCode",{parentName:"p"},"OpenRelTable")," is a friend class to the ",(0,r.kt)("inlineCode",{parentName:"p"},"RelCacheTable")," class. This allows all methods in ",(0,r.kt)("inlineCode",{parentName:"p"},"OpenRelTable")," to access the private fields and methods of the ",(0,r.kt)("inlineCode",{parentName:"p"},"RelCacheTable")," class.")),(0,r.kt)("p",null,"The class definition of ",(0,r.kt)("inlineCode",{parentName:"p"},"RelCacheTable")," is given below."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"class RelCacheTable {\n\nfriend class OpenRelTable;\n\npublic:\n  //methods\n  static int getRelCatEntry(int relId, RelCatEntry *relCatBuf);\n  static int setRelCatEntry(int relId, RelCatEntry *relCatBuf);\n  static int getSearchIndex(int relId, RecId *searchIndex);\n  static int setSearchIndex(int relId, RecId *searchIndex);\n  static int resetSearchIndex(int relId);\n\nprivate:\n  //field\n  static RelCacheEntry* relCache[MAX_OPEN];\n\n  //methods\n  static void recordToRelCatEntry(union Attribute record[RELCAT_NO_ATTRS], RelCatEntry *relCatEntry);\n  static void relCatEntryToRecord(RelCatEntry *relCatEntry, union Attribute record[RELCAT_NO_ATTRS]);\n\n};\n")),(0,r.kt)("p",null,"The following are the specifications for the methods in ",(0,r.kt)("inlineCode",{parentName:"p"},"class RelCacheTable"),"."),(0,r.kt)("h3",{id:"relcachetable--getrelcatentry"},"RelCacheTable :: getRelCatEntry"),(0,r.kt)("h4",{id:"description"},"Description"),(0,r.kt)("p",null,"Gives the ",(0,r.kt)("em",{parentName:"p"},"Relation Catalog")," entry corresponding to the specified relation from ",(0,r.kt)("em",{parentName:"p"},"Relation Cache")," Table."),(0,r.kt)("admonition",{title:"note",type:"caution"},(0,r.kt)("p",{parentName:"admonition"},"The caller should allocate memory for the ",(0,r.kt)("inlineCode",{parentName:"p"},"struct RelCatEntry")," before calling the function.")),(0,r.kt)("h4",{id:"arguments"},"Arguments"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Name")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Type")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Description")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"relId"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"int")),(0,r.kt)("td",{parentName:"tr",align:null},"The relation id of the relation in the ",(0,r.kt)("em",{parentName:"td"},"Relation Cache")," Table")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"relCatBuf"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"RelCatEntry*")),(0,r.kt)("td",{parentName:"tr",align:null},"Pointer to struct RelCatEntry to which the ",(0,r.kt)("em",{parentName:"td"},"Relation Catalog")," entry corresponding to input relId is to be copied")))),(0,r.kt)("h4",{id:"return-values"},"Return Values"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Value")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Description")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/constants"},(0,r.kt)("inlineCode",{parentName:"a"},"SUCCESS"))),(0,r.kt)("td",{parentName:"tr",align:null},"Successfully copied the ",(0,r.kt)("em",{parentName:"td"},"Relation Catalog")," entry")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/constants"},(0,r.kt)("inlineCode",{parentName:"a"},"E_OUTOFBOUND"))),(0,r.kt)("td",{parentName:"tr",align:null},"Input relId is outside the valid set of possible relation ids")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/constants"},(0,r.kt)("inlineCode",{parentName:"a"},"E_RELNOTOPEN"))),(0,r.kt)("td",{parentName:"tr",align:null},"Entry corresponding to input relId is free in the ",(0,r.kt)("em",{parentName:"td"},"Relation Cache")," Table. Use OpenRelTable::openRel() to load the relation to cache memory.")))),(0,r.kt)("h4",{id:"algorithm"},"Algorithm"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"int RelCacheTable::getRelCatEntry(int relId, RelCatEntry *relCatBuf) {\n\n  if(/*relId is outside the range [0, MAX_OPEN-1]*/) {\n    return E_OUTOFBOUND;\n  }\n\n  if(/*entry corresponding to the relId in the Relation Cache Table is free*/) {\n    return E_RELNOTOPEN;\n  }\n\n  // copy the corresponding Relation Catalog entry in the Relation Cache Table\n  // to relCatBuf.\n\n  return SUCCESS;\n\n}\n")),(0,r.kt)("h3",{id:"relcachetable--setrelcatentry"},"RelCacheTable :: setRelCatEntry"),(0,r.kt)("h4",{id:"description-1"},"Description"),(0,r.kt)("p",null,"Sets the ",(0,r.kt)("em",{parentName:"p"},"Relation Catalog")," entry corresponding to the specified relation in the ",(0,r.kt)("em",{parentName:"p"},"Relation Cache")," Table."),(0,r.kt)("admonition",{title:"note",type:"caution"},(0,r.kt)("p",{parentName:"admonition"},"The caller should allocate memory for the ",(0,r.kt)("inlineCode",{parentName:"p"},"struct RelCatEntry")," before calling the function.")),(0,r.kt)("h4",{id:"arguments-1"},"Arguments"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Name")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Type")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Description")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"relId"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"int")),(0,r.kt)("td",{parentName:"tr",align:null},"The relation id of the relation in the ",(0,r.kt)("em",{parentName:"td"},"Relation Cache")," Table")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"relCatBuf"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"RelCatEntry*")),(0,r.kt)("td",{parentName:"tr",align:null},"Pointer to struct RelCatEntry using which the ",(0,r.kt)("em",{parentName:"td"},"Relation Catalog")," entry corresponding to input relId is to be updated")))),(0,r.kt)("h4",{id:"return-values-1"},"Return Values"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Value")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Description")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/constants"},(0,r.kt)("inlineCode",{parentName:"a"},"SUCCESS"))),(0,r.kt)("td",{parentName:"tr",align:null},"Successfully copied the ",(0,r.kt)("em",{parentName:"td"},"Relation Catalog")," entry")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/constants"},(0,r.kt)("inlineCode",{parentName:"a"},"E_OUTOFBOUND"))),(0,r.kt)("td",{parentName:"tr",align:null},"Input relId is outside the valid set of possible relation ids")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/constants"},(0,r.kt)("inlineCode",{parentName:"a"},"E_RELNOTOPEN"))),(0,r.kt)("td",{parentName:"tr",align:null},"Entry corresponding to input relId is free in the ",(0,r.kt)("em",{parentName:"td"},"Relation Cache")," Table. Use OpenRelTable::openRel() to load the relation to cache memory.")))),(0,r.kt)("h4",{id:"algorithm-1"},"Algorithm"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"int RelCacheTable::setRelCatEntry(int relId, RelCatEntry *relCatBuf) {\n\n  if(/*relId is outside the range [0, MAX_OPEN-1]*/) {\n    return E_OUTOFBOUND;\n  }\n\n  if(/*entry corresponding to the relId in the Relation Cache Table is free*/) {\n    return E_RELNOTOPEN;\n  }\n\n  // copy the relCatBuf to the corresponding Relation Catalog entry in\n  // the Relation Cache Table.\n\n  // set the dirty flag of the corresponding Relation Cache entry in\n  // the Relation Cache Table.\n\n  return SUCCESS;\n\n}\n")),(0,r.kt)("h3",{id:"relcachetable--getsearchindex"},"RelCacheTable :: getSearchIndex"),(0,r.kt)("h4",{id:"description-2"},"Description"),(0,r.kt)("p",null,"Gives the value of ",(0,r.kt)("inlineCode",{parentName:"p"},"searchIndex")," field of the given relation from ",(0,r.kt)("em",{parentName:"p"},"Relation Cache")," Table. This is used by the linear search algorithm to find the ",(0,r.kt)("strong",{parentName:"p"},"location of the previous hit")," so that the search can be resumed from the next record."),(0,r.kt)("admonition",{title:"note",type:"caution"},(0,r.kt)("p",{parentName:"admonition"},"The caller should allocate memory for the struct RecId before calling the function.")),(0,r.kt)("h4",{id:"arguments-2"},"Arguments"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Name")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Type")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Description")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"relId"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"int")),(0,r.kt)("td",{parentName:"tr",align:null},"The relation id of the relation in the ",(0,r.kt)("em",{parentName:"td"},"Relation Cache")," Table")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"searchIndex"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"RecId*")),(0,r.kt)("td",{parentName:"tr",align:null},"Pointer to struct RecId to which the searchIndex field of the ",(0,r.kt)("em",{parentName:"td"},"Relation Cache")," entry corresponding to input relId is to be copied")))),(0,r.kt)("h4",{id:"return-values-2"},"Return Values"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Value")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Description")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/constants"},(0,r.kt)("inlineCode",{parentName:"a"},"SUCCESS"))),(0,r.kt)("td",{parentName:"tr",align:null},"Successfully copied the ",(0,r.kt)("em",{parentName:"td"},"Relation Catalog")," entry")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/constants"},(0,r.kt)("inlineCode",{parentName:"a"},"E_OUTOFBOUND"))),(0,r.kt)("td",{parentName:"tr",align:null},"Input relId is outside the valid set of possible relation ids")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/constants"},(0,r.kt)("inlineCode",{parentName:"a"},"E_RELNOTOPEN"))),(0,r.kt)("td",{parentName:"tr",align:null},"Entry corresponding to input relId is free in the ",(0,r.kt)("em",{parentName:"td"},"Relation Cache")," Table. Use OpenRelTable::openRel() to load the relation to cache memory.")))),(0,r.kt)("h4",{id:"algorithm-2"},"Algorithm"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"int relCacheTable::getSearchIndex(int relid, recId *recidbuff_ptr) {\n\n  if(/*relId is outside the range [0, MAX_OPEN-1]*/) {\n    return E_OUTOFBOUND;\n  }\n\n  if(/*entry corresponding to the relId in the Relation Cache Table is free*/) {\n    return E_RELNOTOPEN;\n  }\n\n  // copy the searchIndex field of the Relation Cache entry corresponding to\n  // input relId to searchIndex variable.\n\n  return SUCCESS;\n}\n")),(0,r.kt)("h3",{id:"relcachetable--setsearchindex"},"RelCacheTable :: setSearchIndex"),(0,r.kt)("h4",{id:"description-3"},"Description"),(0,r.kt)("p",null,"Sets the value of ",(0,r.kt)("inlineCode",{parentName:"p"},"searchIndex")," field of the given relation in ",(0,r.kt)("em",{parentName:"p"},"Relation Cache")," Table. This is used by the linear search algorithm to set the location of the previous hit so that the search can be resumed from the next record."),(0,r.kt)("admonition",{title:"note",type:"caution"},(0,r.kt)("p",{parentName:"admonition"},"The caller should allocate memory for the struct RecId before calling the function.")),(0,r.kt)("h4",{id:"arguments-3"},"Arguments"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Name")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Type")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Description")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"relId"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"int")),(0,r.kt)("td",{parentName:"tr",align:null},"The relation id of the relation in the ",(0,r.kt)("em",{parentName:"td"},"Relation Cache")," Table")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"searchIndex"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"RecId*")),(0,r.kt)("td",{parentName:"tr",align:null},"Pointer to struct RecId using which the searchIndex field of the ",(0,r.kt)("em",{parentName:"td"},"Relation Cache")," entry corresponding to input relId is to be updated")))),(0,r.kt)("h4",{id:"return-values-3"},"Return Values"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Value")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Description")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/constants"},(0,r.kt)("inlineCode",{parentName:"a"},"SUCCESS"))),(0,r.kt)("td",{parentName:"tr",align:null},"Successfully copied the ",(0,r.kt)("em",{parentName:"td"},"Relation Catalog")," entry")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/constants"},(0,r.kt)("inlineCode",{parentName:"a"},"E_OUTOFBOUND"))),(0,r.kt)("td",{parentName:"tr",align:null},"Input relId is outside the valid set of possible relation ids")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/constants"},(0,r.kt)("inlineCode",{parentName:"a"},"E_RELNOTOPEN"))),(0,r.kt)("td",{parentName:"tr",align:null},"Entry corresponding to input relId is free in the ",(0,r.kt)("em",{parentName:"td"},"Relation Cache")," Table. Use OpenRelTable::openRel() to load the relation to cache memory.")))),(0,r.kt)("h4",{id:"algorithm-3"},"Algorithm"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"int RelCacheTable::setSearchIndex(int relId, recId *searchIndex) {\n\n  if(/*relId is outside the range [0, MAX_OPEN-1]*/) {\n    return E_OUTOFBOUND;\n  }\n\n  if(/*entry corresponding to the relId in the Relation Cache Table is free*/) {\n    return E_RELNOTOPEN;\n  }\n\n  // copy the searchIndex variable to the searchIndex field of the Relation\n  // Cache entry corresponding to input relId.\n\n  return SUCCESS;\n\n}\n")),(0,r.kt)("h3",{id:"relcachetable--resetsearchindex"},"RelCacheTable :: resetSearchIndex"),(0,r.kt)("h4",{id:"description-4"},"Description"),(0,r.kt)("p",null,"Resets the value of ",(0,r.kt)("inlineCode",{parentName:"p"},"searchIndex")," field of the given relation in ",(0,r.kt)("em",{parentName:"p"},"Relation Cache")," Table to {-1, -1}. This is used so that the linear search can be restarted from the first record."),(0,r.kt)("h4",{id:"arguments-4"},"Arguments"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Name")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Type")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Description")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"relId"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"int")),(0,r.kt)("td",{parentName:"tr",align:null},"The relation id of the relation in the ",(0,r.kt)("em",{parentName:"td"},"Relation Cache")," Table")))),(0,r.kt)("h4",{id:"return-values-4"},"Return Values"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Value")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Description")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/constants"},(0,r.kt)("inlineCode",{parentName:"a"},"SUCCESS"))),(0,r.kt)("td",{parentName:"tr",align:null},"Successfully copied the ",(0,r.kt)("em",{parentName:"td"},"Relation Catalog")," entry")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/constants"},(0,r.kt)("inlineCode",{parentName:"a"},"E_OUTOFBOUND"))),(0,r.kt)("td",{parentName:"tr",align:null},"Input relId is outside the valid set of possible relation ids")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/constants"},(0,r.kt)("inlineCode",{parentName:"a"},"E_RELNOTOPEN"))),(0,r.kt)("td",{parentName:"tr",align:null},"Entry corresponding to input relId is free in the ",(0,r.kt)("em",{parentName:"td"},"Relation Cache")," Table. Use OpenRelTable::openRel() to load the relation to cache memory.")))),(0,r.kt)("h4",{id:"algorithm-4"},"Algorithm"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"int RelCacheTable::resetSearchIndex(int relId) {\n\n  // declare a RecId having value {-1, -1}\n  // set the search index to {-1, -1} using RelCacheTable::setSearchIndex\n  // return the value returned by setSearchIndex\n}\n")),(0,r.kt)("h3",{id:"relcachetable--recordtorelcatentry"},"RelCacheTable :: recordToRelCatEntry"),(0,r.kt)("h4",{id:"description-5"},"Description"),(0,r.kt)("p",null,"A utility function that converts a record, implemented as an array of ",(0,r.kt)("inlineCode",{parentName:"p"},"union Attribute"),", to ",(0,r.kt)("inlineCode",{parentName:"p"},"RelCatEntry")," structure. This function can be used to convert a record in a ",(0,r.kt)("em",{parentName:"p"},"Relation Catalog")," block to the corresponding ",(0,r.kt)("em",{parentName:"p"},"Relation Cache")," entry when caching a relation in ",(0,r.kt)("em",{parentName:"p"},"Relation Cache")," Table. The details of the implementation are left to you."),(0,r.kt)("admonition",{title:"note",type:"caution"},(0,r.kt)("p",{parentName:"admonition"},"The caller should allocate memory for the ",(0,r.kt)("inlineCode",{parentName:"p"},"struct RelCatEntry")," and array of ",(0,r.kt)("inlineCode",{parentName:"p"},"union Attribute")," before calling the function.")),(0,r.kt)("h4",{id:"arguments-5"},"Arguments"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Name")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Type")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Description")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"record"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"union Attribute[RELCAT_SIZE"),"]"),(0,r.kt)("td",{parentName:"tr",align:null},"The record which is to be converted to a ",(0,r.kt)("inlineCode",{parentName:"td"},"RelCatEntry"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"RelCatEntry"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"RelCatEntry*")),(0,r.kt)("td",{parentName:"tr",align:null},"Pointer to struct ",(0,r.kt)("inlineCode",{parentName:"td"},"RelCatEntry")," to which the contents of the input record is to be copied")))),(0,r.kt)("h4",{id:"return-values-5"},"Return Values"),(0,r.kt)("p",null,"Nil"),(0,r.kt)("h3",{id:"relcachetable--relcatentrytorecord"},"RelCacheTable :: relCatEntryToRecord"),(0,r.kt)("h4",{id:"description-6"},"Description"),(0,r.kt)("p",null,"A utility function that converts ",(0,r.kt)("inlineCode",{parentName:"p"},"RelCatEntry")," structure to a record, implemented as an array of ",(0,r.kt)("inlineCode",{parentName:"p"},"union Attribute"),". This function can be used to convert the ",(0,r.kt)("em",{parentName:"p"},"Relation Cache")," entry to the corresponding record that can be written back to ",(0,r.kt)("em",{parentName:"p"},"Relation Catalog")," block when closing a relation in the cache memory. The details of the implementation are left to you."),(0,r.kt)("admonition",{title:"note",type:"caution"},(0,r.kt)("p",{parentName:"admonition"},"The caller should allocate memory for the struct RelCatEntry and array of union Attribute before calling the function.")),(0,r.kt)("h4",{id:"arguments-6"},"Arguments"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Name")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Type")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Description")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"RelCatEntry"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"RelCatEntry*")),(0,r.kt)("td",{parentName:"tr",align:null},"Pointer to struct ",(0,r.kt)("inlineCode",{parentName:"td"},"RelCatEntry")," which is to be converted to a record.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"record"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"union Attribute[RELCAT_SIZE]")),(0,r.kt)("td",{parentName:"tr",align:null},"The record to which the contents of the input ",(0,r.kt)("inlineCode",{parentName:"td"},"RelCatEntry")," is to be copied")))),(0,r.kt)("h4",{id:"return-values-6"},"Return Values"),(0,r.kt)("p",null,"Nil"),(0,r.kt)("hr",null))}c.isMDXComponent=!0}}]);