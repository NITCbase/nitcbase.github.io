"use strict";(self.webpackChunknitcbase=self.webpackChunknitcbase||[]).push([[9889],{3905:(e,t,a)=>{a.d(t,{Zo:()=>d,kt:()=>u});var n=a(7294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function l(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var c=n.createContext({}),s=function(e){var t=n.useContext(c),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},d=function(e){var t=s(e.components);return n.createElement(c.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},h=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,i=e.originalType,c=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),h=s(a),u=r,m=h["".concat(c,".").concat(u)]||h[u]||p[u]||i;return a?n.createElement(m,o(o({ref:t},d),{},{components:a})):n.createElement(m,o({ref:t},d))}));function u(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=a.length,o=new Array(i);o[0]=h;var l={};for(var c in t)hasOwnProperty.call(t,c)&&(l[c]=t[c]);l.originalType=e,l.mdxType="string"==typeof e?e:r,o[1]=l;for(var s=2;s<i;s++)o[s]=a[s];return n.createElement.apply(null,o)}return n.createElement.apply(null,a)}h.displayName="MDXCreateElement"},1235:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>c,contentTitle:()=>o,default:()=>p,frontMatter:()=>i,metadata:()=>l,toc:()=>s});var n=a(7462),r=(a(7294),a(3905));const i={title:"Stage 4 : Opening, Closing and Searching"},o="Stage 4",l={unversionedId:"Roadmap/Stage04",id:"Roadmap/Stage04",title:"Stage 4 : Opening, Closing and Searching",description:"- Learn",source:"@site/docs/Roadmap/Stage04.md",sourceDirName:"Roadmap",slug:"/Roadmap/Stage04",permalink:"/docs/Roadmap/Stage04",draft:!1,tags:[],version:"current",frontMatter:{title:"Stage 4 : Opening, Closing and Searching"},sidebar:"Roadmap",previous:{title:"Stage 3 : The Disk Buffer and Catalog Caches",permalink:"/docs/Roadmap/Stage03"}},c={},s=[{value:"Introduction",id:"introduction",level:2},{value:"Open and Closed Relations",id:"open-and-closed-relations",level:3},{value:"Searching",id:"searching",level:3},{value:"Implementation",id:"implementation",level:2},{value:"Exercises",id:"exercises",level:2}],d={toc:s};function p(e){let{components:t,...a}=e;return(0,r.kt)("wrapper",(0,n.Z)({},d,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"stage-4"},"Stage 4"),(0,r.kt)("admonition",{title:"Learning Objectives",type:"note"},(0,r.kt)("ul",{parentName:"admonition"},(0,r.kt)("li",{parentName:"ul"},"Learn"))),(0,r.kt)("h2",{id:"introduction"},"Introduction"),(0,r.kt)("p",null,"We discussed about the relation and attribute cache in the previous stage. Your implementation must now be able to read the rows and columns of the relations ",(0,r.kt)("inlineCode",{parentName:"p"},"RELCAT")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"ATTRCAT")," from the caches and display the attributes for these relations. In this stage, we'll extend this functionality to any relation in the DBMS. Additionally, we'll also implement a search functionality so that we can search through all the records of a relation."),(0,r.kt)("h3",{id:"open-and-closed-relations"},"Open and Closed Relations"),(0,r.kt)("p",null,"A relation that has it's rleation and attribute catalog entries stored in the respective caches is called an ",(0,r.kt)("strong",{parentName:"p"},"open relation"),". NITCbase supports opening 12 relations at once (10 in practice. Why?). If we want to open any more relations, we will have to ",(0,r.kt)("strong",{parentName:"p"},"close")," some relation. ",(0,r.kt)("strong",{parentName:"p"},"NITCbase requires that a relation be opened before any operations can be performed on it"),"."),(0,r.kt)("p",null,"We discussed about the ",(0,r.kt)("a",{parentName:"p",href:"/docs/Design/Cache%20Layer#class-relcachetable"},"RelCacheTable")," and ",(0,r.kt)("a",{parentName:"p",href:"/docs/Design/Cache%20Layer#class-attrcachetable"},"AttrCacheTable")," classes in the preceeding stage. Here, we introduce the class ",(0,r.kt)("a",{parentName:"p",href:"/docs/Design/Cache%20Layer#class-openreltable"},"OpenRelTable")," class. This class manages the open and closing of relations and handles the caching operations. It has a member ",(0,r.kt)("inlineCode",{parentName:"p"},"tableMetaInfo")," which is a ",(0,r.kt)("a",{parentName:"p",href:"/constants"},"MAX_OPEN")," sized array of type ",(0,r.kt)("a",{parentName:"p",href:"/docs/Design/Cache%20Layer#openreltablemetainfo"},"struct OpenRelTableMetaInfo"),". ",(0,r.kt)("inlineCode",{parentName:"p"},"tableMetaInfo")," is used to store which entries of the caches are free and the relation to which an occupied entry belongs."),(0,r.kt)("p",null,"For any index ",(0,r.kt)("inlineCode",{parentName:"p"},"i")," that is occupied in the caches, the entries at index ",(0,r.kt)("inlineCode",{parentName:"p"},"i")," in ",(0,r.kt)("inlineCode",{parentName:"p"},"relCache"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"attrCache")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"tableMetaInfo")," will correspond to the same relation. Recall that this index ",(0,r.kt)("inlineCode",{parentName:"p"},"i")," is called the relation's rel-id. These three tables comprise the core functionality of the ",(0,r.kt)("a",{parentName:"p",href:"/docs/Design/Cache%20Layer"},"Cache Layer")," of NITCbase. A table can be opened by the user with the ",(0,r.kt)("a",{parentName:"p",href:"/docs/User%20Interface%20Commands/ddl#open-table"},"OPEN TABLE")," command."),(0,r.kt)("h3",{id:"searching"},"Searching"),(0,r.kt)("p",null,"A search operation involves fetching all records that satisfy some condition. This is also known as a selection operation in ",(0,r.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Relational_algebra"},"relational algebra"),". NITCbase supports selection with the following operators: ",(0,r.kt)("inlineCode",{parentName:"p"},"="),", ",(0,r.kt)("inlineCode",{parentName:"p"},"!="),", ",(0,r.kt)("inlineCode",{parentName:"p"},">"),", ",(0,r.kt)("inlineCode",{parentName:"p"},">="),", ",(0,r.kt)("inlineCode",{parentName:"p"},"<")," ",(0,r.kt)("inlineCode",{parentName:"p"},">="),". We'll implement a function that will do the appropriate search and return to us a record that satisfies our condition each time it's called. Higher levels can call this function repeatedly until there are no more records to be found."),(0,r.kt)("p",null,"You might've realized that the above function would require some global state to work as intended. We'll need to keep track of the previously found record so that we can fetch the next record that satisfies the condition. And that is exactly what the ",(0,r.kt)("inlineCode",{parentName:"p"},"searchIndex")," field in the caches do. ",(0,r.kt)("inlineCode",{parentName:"p"},"searchIndex")," in the relation cache is used to store the last hit during linear search on that relation. A value of ",(0,r.kt)("inlineCode",{parentName:"p"},"{-1, -1}")," indicates that the search should start over from the beginning again."),(0,r.kt)("p",null,"The search functionality is implemented in the ",(0,r.kt)("a",{parentName:"p",href:"/docs/Design/Block%20Access%20Layer"},"Block Access Layer")," of NITCbase and made available to the user through the ",(0,r.kt)("a",{parentName:"p",href:"/docs/User%20Interface%20Commands/dml#select--from-table-where"},"SELECT")," command in the ",(0,r.kt)("a",{parentName:"p",href:"/docs/Design/Algebra%20Layer"},"Algebra Layer"),"."),(0,r.kt)("h2",{id:"implementation"},"Implementation"),(0,r.kt)("p",null,"The difficulty in implementation here comes from the fact that these two operations are intertwined. Opening a relation requires us to search for the corresponding records in the catalogs. To search through the records of a relation, we require that the relation be open. You must see now why the relation catalog and attribute catalog are always kept open."),(0,r.kt)("p",null,"Sequence diagrams documenting the flow of data between the layers is shown below."),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},(0,r.kt)("strong",{parentName:"p"},"NOTE"),": The functions are denoted with circles as follows.",(0,r.kt)("br",null),"\n\ud83d\udd35 -> methods that are already in their final state",(0,r.kt)("br",null),"\n\ud83d\udfe2 -> methods that will attain their final state in this stage",(0,r.kt)("br",null),"\n\ud83d\udfe0 -> methods that we will modify in this stage, but will require more work")),(0,r.kt)("br",null),(0,r.kt)("mermaid",{value:" %%{init: { 'sequence': {'mirrorActors':false} } }%%\nsequenceDiagram\n    actor User\n    participant Frontend Interface\n    participant Frontend\n    participant Schema Layer\n    participant Cache Layer\n    participant Block Access Layer\n    participant Buffer Layer\n    User->>Frontend Interface: OPEN TABLE\n    activate Frontend Interface\n    Frontend Interface->>Frontend:open_table()\ud83d\udfe2\n    activate Frontend\n    Frontend->>Schema Layer:openRel()\ud83d\udfe0\n    activate Schema Layer\n    Schema Layer->>Cache Layer:openRel()\ud83d\udfe2\n    activate Cache Layer\n    loop until all catalog entries are read\n      Cache Layer->>Block Access Layer:linearSearch()\ud83d\udfe2\n      activate Block Access Layer\n      Block Access Layer--\x3e>Cache Layer: recId\n      deactivate Block Access Layer\n      Cache Layer->>Buffer Layer:getHeader()\ud83d\udd35, getRecord()\ud83d\udd35, getSlotmap()\ud83d\udfe2\n      activate Buffer Layer\n      Buffer Layer--\x3e>Cache Layer: record block info\n      deactivate Buffer Layer\n    end\n    Cache Layer--\x3e>User:operation status\n    deactivate Cache Layer\n    deactivate Schema Layer\n    deactivate Frontend\n    deactivate Frontend Interface\n"}),(0,r.kt)("br",null),(0,r.kt)("mermaid",{value:" %%{init: { 'sequence': {'mirrorActors':false} } }%%\nsequenceDiagram\n    actor User\n    participant Frontend Interface\n    participant Frontend\n    participant Algebra Layer\n    participant Block Access Layer\n    participant Cache Layer\n    participant Buffer Layer\n    User->>Frontend Interface: SELECT\n    activate Frontend Interface\n    Frontend Interface->>Frontend:select_from_table_where()\ud83d\udfe2\n    activate Frontend\n    Frontend->>Algebra Layer:select()\ud83d\udfe0\n    activate Algebra Layer\n    loop until all records found\n      Algebra Layer->>Block Access Layer:linearSearch()\ud83d\udfe2\n      activate Block Access Layer\n      Block Access Layer->>Cache Layer:cache functions\n      activate Cache Layer\n      Cache Layer--\x3e>Block Access Layer:relCatEntry, attrCatEntry\n      deactivate Cache Layer\n      Block Access Layer->>Buffer Layer:getHeader()\ud83d\udd35, getRecord()\ud83d\udd35, getSlotmap()\ud83d\udfe2\n      activate Buffer Layer\n      Buffer Layer--\x3e>Block Access Layer: record block info\n      deactivate Buffer Layer\n      Block Access Layer--\x3e>Algebra Layer:recId\n      deactivate Block Access Layer\n    end\n    Algebra Layer--\x3e>User:operation status\n    deactivate Algebra Layer\n    deactivate Frontend\n    deactivate Frontend Interface\n"}),(0,r.kt)("br",null),(0,r.kt)("p",null,"A class diagram showing the methods relevant to this functionality in the Cache Layer is shown below."),(0,r.kt)("mermaid",{value:"classDiagram\n  direction RL\n  RelCacheTable <|.. OpenRelTable : friend\n  AttrCacheTable <|.. OpenRelTable : friend\n\n  class RelCacheTable{\n    -relCache[MAX_OPEN] : RelCacheEntry*\n    -recordToRelCatEntry(union Attribute record[RELCAT_NO_ATTRS], RelCatEntry *relCatEntry)$ void\ud83d\udd35\n    +getRelCatEntry(int relId, RelCatEntry *relCatBuf)$ int\ud83d\udfe2\n    +getSearchIndex(int relId, RecId *searchIndex)$ int\ud83d\udfe2\n    +setSearchIndex(int relId, RecId *searchIndex)$ int\ud83d\udfe2\n    +resetSearchIndex(int relId)$ int\ud83d\udfe2\n  }\n  class AttrCacheTable{\n      -attrCache[MAX_OPEN] : AttrCacheEntry*\n      -recordToAttrCatEntry(union Attribute record[ATTRCAT_NO_ATTRS], AttrCatEntry *attrCatEntry)$ void\ud83d\udd35\n      +getAttrCatEntry(int relId, char attrName[ATTR_SIZE], AttrCatEntry *attrCatBuf)$ int\ud83d\udfe2\n      +getAttrCatEntry(int relId, int attrOffset, AttrCatEntry *attrCatBuf)$ int\ud83d\udfe2\n  }\n  class OpenRelTable{\n      -tableMetaInfo[MAX_OPEN] : OpenRelTableMetaInfo\n      +OpenRelTable(): \ud83d\udfe2\n      +~OpenRelTable(): \ud83d\udfe0\n      -getFreeOpenRelTableEntry()$ int\ud83d\udfe2\n      +getRelId(char relName[ATTR_SIZE])$ int\ud83d\udfe2\n      +openRel(char relName[ATTR_SIZE])$ int\ud83d\udfe2\n      +closeRel(int relId)$ int\ud83d\udfe0\n  }\n"}),(0,r.kt)("br",null),(0,r.kt)("h2",{id:"exercises"},"Exercises"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"insert records and search")))}p.isMDXComponent=!0}}]);