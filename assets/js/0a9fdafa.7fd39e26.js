"use strict";(self.webpackChunknitcbase_beta=self.webpackChunknitcbase_beta||[]).push([[1130],{3905:function(e,n,t){t.d(n,{Zo:function(){return l},kt:function(){return b}});var r=t(7294);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function f(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){o(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function u(e,n){if(null==e)return{};var t,r,o=function(e,n){if(null==e)return{};var t,r,o={},i=Object.keys(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var c=r.createContext({}),a=function(e){var n=r.useContext(c),t=n;return e&&(t="function"==typeof e?e(n):f(f({},n),e)),t},l=function(e){var n=a(e.components);return r.createElement(c.Provider,{value:n},e.children)},s={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},d=r.forwardRef((function(e,n){var t=e.components,o=e.mdxType,i=e.originalType,c=e.parentName,l=u(e,["components","mdxType","originalType","parentName"]),d=a(t),b=o,h=d["".concat(c,".").concat(b)]||d[b]||s[b]||i;return t?r.createElement(h,f(f({ref:n},l),{},{components:t})):r.createElement(h,f({ref:n},l))}));function b(e,n){var t=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var i=t.length,f=new Array(i);f[0]=d;var u={};for(var c in n)hasOwnProperty.call(n,c)&&(u[c]=n[c]);u.originalType=e,u.mdxType="string"==typeof e?e:o,f[1]=u;for(var a=2;a<i;a++)f[a]=t[a];return r.createElement.apply(null,f)}return r.createElement.apply(null,t)}d.displayName="MDXCreateElement"},8335:function(e,n,t){t.r(n),t.d(n,{frontMatter:function(){return u},contentTitle:function(){return c},metadata:function(){return a},toc:function(){return l},default:function(){return d}});var r=t(7462),o=t(3366),i=(t(7294),t(3905)),f=["components"],u={},c="Buffer Layer Stub Code",a={type:"mdx",permalink:"/buffer_stub",source:"@site/src/pages/buffer_stub.md"},l=[{value:"StaticBuffer.cpp",id:"staticbuffercpp",children:[],level:2},{value:"StaticBuffer.h",id:"staticbufferh",children:[],level:2},{value:"BlockBuffer.cpp",id:"blockbuffercpp",children:[],level:2},{value:"BlockBuffer.h",id:"blockbufferh",children:[],level:2}],s={toc:l};function d(e){var n=e.components,t=(0,o.Z)(e,f);return(0,i.kt)("wrapper",(0,r.Z)({},s,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"buffer-layer-stub-code"},"Buffer Layer Stub Code"),(0,i.kt)("h2",{id:"staticbuffercpp"},"StaticBuffer.cpp"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},'#include "StaticBuffer.h"\n\n#include "StaticBuffer.h"\n#include "../define(/constants).h"\n#include "../Disk_Class/Disk.cpp"\n\nunsigned char StaticBuffer::blocks[BUFFER_CAPACITY][BLOCK_SIZE];\nstruct BufferMetaInfo StaticBuffer::metainfo[BUFFER_CAPACITY];\nunsigned char StaticBuffer::blockAllocMap[DISK_BLOCKS];\n\nStaticBuffer::StaticBuffer() {\n\n    // copy blockAllocMap blocks from disk to buffer (using readblock() of disk)\n\n    //initialise metainfo of all the buffer blocks with dirty:false, free:true, timestamp:-1 and blockNum:-1\n\n}\n\nStaticBuffer::~StaticBuffer() {\n    // copy blockAllocMap blocks from buffer to disk(using writeblock() of disk)\n\n    /*iterate through all the buffer blocks,\n        write back blocks with meta info as free:false,dirty:true (using writeblock() of disk)*/\n\n}\n\nint StaticBuffer::getStaticBlockType(int blockNum) {\n    // Check if blockNum is valid (non zero and less than number of disk blocks)\n    // and return E_OUTOFBOUND if not valid.\n\n\n    // Access the entry in block allocation map corresponding to the blockNum argument\n    // and return the block type after type casting to integer.\n}\n\nint StaticBuffer::setDirtyBit(int blockNum) {\n    //find the buffer index corresponding to the block using the getBufferNum().\n\n    // if Buffer is valid, bufferNum != E_BLOCKNOTINBUFFER\n\n        // set the dirty bit of that buffer in the metaInfo to true.\n\n    // else Buffer is ivalid\n\n        // return the returned error code from getBufferNum call \n\n            // E_OUTOFBOUND - blockNum is invalid\n            // E_BLOCKNOTINBUFFER - block with blockNum is not present in Buffer\n\n    // return SUCCESS\n}\n\nint StaticBuffer::getBufferNum(int blockNum) {\n    // Check if blockNum is valid (non zero and less than number of disk blocks)\n    // and return E_OUTOFBOUND if not valid.\n\n    //traverse through the metainfo array,\n    // find the buffer index of the buffer to which the block is loaded.\n\n\n    //if found return buffer index.\n\n    // if block not found in buffer return E_BLOCKNOTINBUFFER\n\n}\n\nint StaticBuffer::getFreeBuffer(int blockNum) {\n    // Check if blockNum is valid (non zero and less than number of disk blocks)\n    // and return E_OUTOFBOUND if not valid.\n\n    // increase the time stamps in metainfo of all the occupied buffers.\n \n    // if free buffer is available, bufferIndex is the index of the free buffer.\n\n    // if free buffer is not available, replace the buffer with the largest timestamp and set it as bufferIndex.\n\n    // update the metainfo array corresponding to the buffer index.\n\n    // return the buffer index\n\n}\n\n\n\n')),(0,i.kt)("h2",{id:"staticbufferh"},"StaticBuffer.h"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},'#ifndef NITCBASE_STATICBUFFER_H\n#define NITCBASE_STATICBUFFER_H\n\n#include "../define(/constants).h"\n\nstruct BufferMetaInfo {\n    bool free;\n    bool dirty;\n    int blockNum;\n    int timeStamp;\n};\n\nclass StaticBuffer {\n\n    friend class BlockBuffer;\n\nprivate:\n    //fields\n    static unsigned char blocks[BUFFER_CAPACITY][BLOCK_SIZE];\n    static struct BufferMetaInfo metainfo[BUFFER_CAPACITY];\n    static unsigned char blockAllocMap[DISK_BLOCKS];\n\n    //methods\n    static int getFreeBuffer(int blockNum);\n\n    static int getBufferNum(int blockNum);\n\npublic:\n    //methods\n    static int getStaticBlockType(int blockNum);\n\n    static int setDirtyBit(int blockNum);\n\n    StaticBuffer();\n\n    ~StaticBuffer();\n\n};\n\n#endif //NITCBASE_STATICBUFFER_H\n\n')),(0,i.kt)("h2",{id:"blockbuffercpp"},"BlockBuffer.cpp"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"#include \"BlockBuffer.h\"\n#include \"StaticBuffer.h\"\n#include \"../Disk_Class/Disk.h\"\n\nusing namespace std;\n\n// Constructor 1\nBlockBuffer::BlockBuffer(char blockType) {\n    // allocate a block on the disc and a buffer in memory to hold the new block of given type using getFreeBlock function.\n\n    // set the blockNum field of the object to that of the allocated block number.\n    // TODO: what happens if disk full..note down\n}\n\n// Constructor 2\nBlockBuffer::BlockBuffer(int blockNum) {\n    // set the blockNum field of the object to input argument.\n}\n\nint BlockBuffer::getBlockNum() {\n    // return corresponding block number\n}\n\nint BlockBuffer::getBlockType() {\n    unsigned char *bufferPtr;\n    // get the starting address of the buffer containing the block using loadBlockAndGetBufferPtr(&bufferPtr).\n    \n    // if the call to loadBlockAndGetBufferPtr(&bufferPtr) return SUCCESS \n    \n        // return the first 4 bytes of the buffer that stores the block type. (Hint: cast using int32_t)\n    \n    // else load failed due to E_OUTOFBOUND, invalid block number, return the value returned by the call.\n    \n}\n\nint BlockBuffer::setBlockType(int blockType) {\n    unsigned char *bufferPtr;\n    // get the starting address of the buffer containing the block using loadBlockAndGetBufferPtr(&bufferPtr).\n\n    // if loadBlockAndGetBufferPtr(&bufferPtr) != SUCCESS\n        // return the value returned by the call.\n\n    // store the input block type in the first 4 bytes of the buffer.\n\n    // update the StaticBuffer::blockAllocMap entry corresponding to the object's block number.\n\n    // update dirty bit by calling appropriate method of StaticBuffer class.\n    // if setDirtyBit() failed\n        // return the returned value from the call\n\n    // return SUCCESS\n}\n\nint BlockBuffer::getHeader(struct HeadInfo *head) {\n    unsigned char *bufferPtr;\n    // get the starting address of the buffer containing the block using loadBlockAndGetBufferPtr(&bufferPtr).\n\n    // if loadBlockAndGetBufferPtr(&bufferPtr) != SUCCESS\n        // return the value returned by the call.\n\n    // Use type casting here to cast the returned pointer type to the appropriate struct pointer to get the headInfo\n\n    // copy the header of block to the memory location pointed to by the argument head.\n        // not copying reserved\n\n    // return SUCCESS\n}\n\nint BlockBuffer::setHeader(struct HeadInfo *head) {\n    unsigned char *bufferPtr;\n    // get the starting address of the buffer containing the block using loadBlockAndGetBufferPtr(&bufferPtr).\n    \n    // if loadBlockAndGetBufferPtr(&bufferPtr) != SUCCESS\n        // return the value returned by the call.\n\n    // Use type casting here to cast the returned pointer type to the appropriate struct pointer to get the headInfo\n\n    //copy the contents of the memory location pointed to by head to the header of block using appropriate.\n        // not copying reserved\n\n    // update dirty bit by calling appropriate method of StaticBuffer class.\n    // if setDirtyBit() failed, return the error code\n\n    // return SUCCESS;\n}\n\nvoid BlockBuffer::releaseBlock() {\n    // if blockNum is INVALID_BLOCK (-1), or it is invalidated already, do nothing\n        \n    // else\n        // get the buffer number of the buffer assigned to the block using StaticBuffer::getBufferNum().\n\n        // if the buffer number is valid (!=E_BLOCKNOTINBUFFER), free the buffer by setting the free flag of its metaInfo entry to true.\n\n        // free the block in disk by setting the data type of the entry corresponding to the block number in StaticBuffer::blockAllocMap to UNUSED_BLK.\n\n        // set the object's blockNum to INVALID_BLOCK (-1)\n}\n\n/* NOTE: This function will NOT check if the block already exists in disk or not,\n   rather will copy whatever content is there in that disk block to the buffer.\n   Only call this if the Block exists in disk already, otherwise call constructor 1 to allocate space for a new block.\n   Also ensure that all getter and setter methods accessing the block's data should call the loadBlockAndGetBufferPtr().\n */\nint BlockBuffer::loadBlockAndGetBufferPtr(unsigned char ** buffPtr) {\n    // check whether the block is already present in the buffer using StaticBuffer.getBufferNum()\n    int bufferNum = StaticBuffer::getBufferNum(this->blockNum);\n\n    // if present (!=E_BLOCKNOTINBUFFER), set the timestamp of the corresponding buffer to 0 and increment the timpestamps of all other occupied buffers in the BufferMetaInfo.\n\n    \n    // else\n        // if not present, get a free buffer using StaticBuffer.getFreeBuffer()\n\n        // if the call returns E_OUTOFBOUND, return E_OUTOFBOUND here as the blockNum is invalid\n        \n        // Read the block into the free buffer using readBlock()\n        \n        // If the read failed, the block number is invalid return E_OUTOFBOUND;\n\n    // store the pointer to this buffer (blocks[bufferNum]) in *buffPtr\n\n    // return SUCCESS;\n}\n\nint BlockBuffer::getFreeBlock(int blockType) {\n    //iterate through the StaticBuffer.blockAllocMap and find the index of a free block in the disk.\n\n    //if no block is free, return E_DISKFULL.\n\n    //set the object's blockNum to the block number of the free block.\n\n    //find a free buffer using StaticBuffer.getFreeBuffer()\n\n    //initialize the header of the block with pblock: -1, lblock: -1, rblock: -1, numEntries: 0, numAttrs: 0 and numSlots: 0 using setHeader().\n\n    //update the block type of the block to the input block type using setBlockType().\n\n    //return block number of the free block.\n\n}\n\n//this is the way to call parent non-default constructor.\n// 'R' is used to denote RecBuffer.\nRecBuffer::RecBuffer() : BlockBuffer('R') {}\n\n//this is the way to call parent non-default constructor.\nRecBuffer::RecBuffer(int blockNum) : BlockBuffer(blockNum) {}\n\nint RecBuffer::getSlotMap(unsigned char *slotMap) {\n    unsigned char *bufferPtr;\n    // get the starting address of the buffer containing the block using loadBlockAndGetBufferPtr(&bufferPtr).\n\n    // if loadBlockAndGetBufferPtr(&bufferPtr) != SUCCESS\n        // return the value returned by the call.\n\n    // Use type casting here to cast the returned pointer type to the appropriate struct pointer\n\n    // get the number of slots in the block.\n\n    // using offset range copy the slotmap of the block to the memory pointed by the argument.\n\n    // return SUCCESS\n}\n\nint RecBuffer::setSlotMap(unsigned char *slotMap) {\n    unsigned char *bufferPtr;\n    // get the starting address of the buffer containing the block using loadBlockAndGetBufferPtr(&bufferPtr).\n\n    // if loadBlockAndGetBufferPtr(&bufferPtr) != SUCCESS\n        // return the value returned by the call.\n\n    // Use type casting here to cast the returned pointer type to the appropriate struct pointer to access headInfo\n\n    // get the number of slots in the block.\n\n    // using offset range copy the slotmap from the memory pointed by the argument to that of the block.\n\n    // update dirty bit.\n    // if setDirtyBit failed, return the value returned by the call\n\n    // return SUCCESS\n}\n\nint RecBuffer::getRecord(union Attribute *rec, int slotNum) {\n    unsigned char *bufferPtr;\n    // get the starting address of the buffer containing the block using loadBlockAndGetBufferPtr(&bufferPtr).\n\n    // if loadBlockAndGetBufferPtr(&bufferPtr) != SUCCESS\n        // return the value returned by the call.\n\n    // Use type casting here to cast the returned pointer type to the appropriate struct pointer to access headInfo\n\n    // get number of attributes in the block.\n\n    // get the number of slots in the block.\n\n    // if input slotNum is not in the permitted range return E_OUTOFBOUND\n\n    // if slot corresponding to input slotNum is free return E_FREESLOT\n\n    // using offset range copy slotNumth record to the memory pointed by rec.\n\n    // return SUCCESS\n\n}\n\nint RecBuffer::setRecord(union Attribute *rec, int slotNum) {\n    unsigned char *bufferPtr;\n    // get the starting address of the buffer containing the block using loadBlockAndGetBufferPtr(&bufferPtr).\n    \n    // if loadBlockAndGetBufferPtr(&bufferPtr) != SUCCESS\n        // return the value returned by the call.\n\n    // Use type casting here to cast the returned pointer type to the appropriate struct pointer to access headInfo\n\n    // get number of attributes in the block.\n\n    // get the number of slots in the block.\n\n    // if input slotNum is not in the permitted range return E_OUTOFBOUND.\n\n    // using offset range copy contents of the memory pointed by rec to slotNumth record.\n\n    // update dirty bit.\n    // if setDirtyBit failed, return the value returned by the call\n\n    // return SUCCESS\n}\n\n\nIndBuffer::IndBuffer(char blockType) : BlockBuffer(blockType) {}\n\nIndBuffer::IndBuffer(int blockNum) : BlockBuffer(blockNum) {}\n\n\nIndInternal::IndInternal() : IndBuffer('I') {}\n\nIndInternal::IndInternal(int blockNum) : IndBuffer(blockNum) {}\n\nint IndInternal::getEntry(void *ptr, int indexNum) {\n    unsigned char *bufferPtr;\n    // get the starting address of the buffer containing the block using loadBlockAndGetBufferPtr(&bufferPtr).\n    \n    // if loadBlockAndGetBufferPtr(&bufferPtr) != SUCCESS\n        // return the value returned by the call.\n\n    // if the indexNum is not in the valid range of 0-(MAX_KEYS_INTERNAL-1), return E_OUTOFBOUND.\n\n    // copy the indexNum'th Internalentry in block to memory ptr(ptr can be type casted appropriately if needed).\n\n    // return SUCCESS.\n}\n\nint IndInternal::setEntry(void *ptr, int indexNum) {\n    unsigned char *bufferPtr;\n    // get the starting address of the buffer containing the block using loadBlockAndGetBufferPtr(&bufferPtr).\n    \n    // if loadBlockAndGetBufferPtr(&bufferPtr) != SUCCESS\n        // return the value returned by the call.\n\n    // if the indexNum is not in the valid range of 0-(MAX_KEYS_INTERNAL-1), return E_OUTOFBOUND.\n\n    // copy the struct InternalEntry pointed by ptr to indexNum'th entry in block.\n\n    // update dirty bit.\n    // if setDirtyBit failed, return the value returned by the call\n\n    // return SUCCESS\n}\n\nIndLeaf::IndLeaf() : IndBuffer('L') {}\n\nIndLeaf::IndLeaf(int blockNum) : IndBuffer(blockNum) {}\n\nint IndLeaf::getEntry(void *ptr, int indexNum) {\n    unsigned char *bufferPtr;\n    // get the starting address of the buffer containing the block using loadBlockAndGetBufferPtr(&bufferPtr).\n    \n    // if loadBlockAndGetBufferPtr(&bufferPtr) != SUCCESS\n        // return the value returned by the call.\n\n    // if the indexNum is not in the valid range of 0-(MAX_KEYS_LEAF-1), return E_OUTOFBOUND.\n\n    // copy the indexNum'th Index entry in block to memory ptr(ptr can be type casted appropriately if needed).\n\n    // return SUCCESS.\n}\n\nint IndLeaf::setEntry(void *ptr, int indexNum) {\n    unsigned char *bufferPtr;\n    // get the starting address of the buffer containing the block using loadBlockAndGetBufferPtr(&bufferPtr).\n\n    // if loadBlockAndGetBufferPtr(&bufferPtr) != SUCCESS\n        // return the value returned by the call.\n\n\n    // if the indexNum is not in the valid range of 0-(MAX_KEYS_LEAF-1), return E_OUTOFBOUND.\n\n    // copy the struct Index pointed by ptr to indexNum'th entry in block.\n\n    //update dirty bit.\n\n    //return SUCCESS\n}\n")),(0,i.kt)("h2",{id:"blockbufferh"},"BlockBuffer.h"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},'#ifndef NITCBASE_BLOCKBUFFER_H\n#define NITCBASE_BLOCKBUFFER_H\n\n#include "../define/constants.h"\n#include "../define/errors.h"\n#include <cstdint>\n\n\nstruct HeadInfo {\n    int32_t blockType;\n    int32_t pblock;\n    int32_t lblock;\n    int32_t rblock;\n    int32_t numEntries;\n    int32_t numAttrs;\n    int32_t numSlots;\n    unsigned char reserved[4];\n};\n\ntypedef union Attribute {\n    float nVal;\n    char sVal[ATTR_SIZE];\n} Attribute;\n\nstruct InternalEntry {\n    int32_t lChild;\n    union Attribute attrVal;\n    int32_t rChild;\n};\n\nstruct Index {\n    union Attribute attrVal;\n    int32_t block;\n    int32_t slot;\n    unsigned char unused[8];\n};\n\nclass BlockBuffer {\nprotected:\n    // field\n    int blockNum;\n\n    // methods\n    int loadBlockAndGetBufferPtr(unsigned char **buffPtr);\n\n    int getFreeBlock(int BlockType);\n\npublic:\n    // methods\n    BlockBuffer(char blockType);\n\n    BlockBuffer(int blockNum);\n\n    int getBlockNum();\n\n    int getBlockType();\n\n    int setBlockType(int blockType);\n\n    int getHeader(struct HeadInfo *head);\n\n    int setHeader(struct HeadInfo *head);\n\n    void releaseBlock();\n};\n\nclass RecBuffer : public BlockBuffer {\npublic:\n\n    //methods\n    RecBuffer();\n\n    RecBuffer(int blockNum);\n\n    int getSlotMap(unsigned char *slotMap);\n\n    int setSlotMap(unsigned char *slotMap);\n\n    int getRecord(union Attribute *rec, int slotNum);\n\n    int setRecord(union Attribute *rec, int slotNum);\n};\n\nclass IndBuffer : public BlockBuffer {\npublic:\n    IndBuffer(int blockNum);\n\n    IndBuffer(char blockType);\n\n    virtual int getEntry(void *ptr, int indexNum) = 0;\n\n    virtual int setEntry(void *ptr, int indexNum) = 0;\n};\n\nclass IndInternal : public IndBuffer {\npublic:\n    IndInternal();//update in documentation\n    IndInternal(int blockNum);\n\n    int getEntry(void *ptr, int indexNum);\n\n    int setEntry(void *ptr, int indexNum);\n};\n\nclass IndLeaf : public IndBuffer {\npublic:\n    IndLeaf();\n\n    IndLeaf(int blockNum);\n\n    int getEntry(void *ptr, int indexNum);\n\n    int setEntry(void *ptr, int indexNum);\n};\n\n#endif //NITCBASE_BLOCKBUFFER_H\n')))}d.isMDXComponent=!0}}]);