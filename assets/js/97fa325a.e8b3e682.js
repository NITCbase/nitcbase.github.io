"use strict";(self.webpackChunknitcbase=self.webpackChunknitcbase||[]).push([[2002],{3905:(e,t,a)=>{a.d(t,{Zo:()=>m,kt:()=>h});var n=a(7294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function o(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?o(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function l(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},o=Object.keys(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var s=n.createContext({}),c=function(e){var t=n.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},m=function(e){var t=c(e.components);return n.createElement(s.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},p=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,o=e.originalType,s=e.parentName,m=l(e,["components","mdxType","originalType","parentName"]),p=c(a),h=r,u=p["".concat(s,".").concat(h)]||p[h]||d[h]||o;return a?n.createElement(u,i(i({ref:t},m),{},{components:a})):n.createElement(u,i({ref:t},m))}));function h(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=a.length,i=new Array(o);i[0]=p;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:r,i[1]=l;for(var c=2;c<o;c++)i[c]=a[c];return n.createElement.apply(null,i)}return n.createElement.apply(null,a)}p.displayName="MDXCreateElement"},1157:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>d,frontMatter:()=>o,metadata:()=>l,toc:()=>c});var n=a(7462),r=(a(7294),a(3905));const o={title:"Stage 9 : Selection and Projection on Relations"},i="Stage 9 : Selection and Projection on Relations (10 hours)",l={unversionedId:"Roadmap/Stage09",id:"Roadmap/Stage09",title:"Stage 9 : Selection and Projection on Relations",description:"- Complete the implementation of SELECT and PROJECT operations in NITCbase",source:"@site/docs/Roadmap/Stage09.md",sourceDirName:"Roadmap",slug:"/Roadmap/Stage09",permalink:"/docs/Roadmap/Stage09",draft:!1,tags:[],version:"current",frontMatter:{title:"Stage 9 : Selection and Projection on Relations"},sidebar:"Roadmap",previous:{title:"Stage 8 : Creating and Deleting Relations",permalink:"/docs/Roadmap/Stage08"}},s={},c=[{value:"Introduction",id:"introduction",level:2},{value:"Implementation",id:"implementation",level:2},{value:"Exercises",id:"exercises",level:2}],m={toc:c};function d(e){let{components:t,...o}=e;return(0,r.kt)("wrapper",(0,n.Z)({},m,o,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"stage-9--selection-and-projection-on-relations-10-hours"},"Stage 9 : Selection and Projection on Relations (10 hours)"),(0,r.kt)("admonition",{title:"Learning Objectives",type:"note"},(0,r.kt)("ul",{parentName:"admonition"},(0,r.kt)("li",{parentName:"ul"},"Complete the implementation of ",(0,r.kt)("strong",{parentName:"li"},"SELECT")," and ",(0,r.kt)("strong",{parentName:"li"},"PROJECT")," operations in NITCbase"))),(0,r.kt)("h2",{id:"introduction"},"Introduction"),(0,r.kt)("p",null,"In previous stages, you had implemented linear search on relations and a rudimentary version of the ",(0,r.kt)("a",{parentName:"p",href:"/docs/User%20Interface%20Commands/dml#select--from-table-where"},"SELECT")," command to select records from a relation. In this stage, we will complete the implementation of the select operation and the project operation."),(0,r.kt)("p",null,"As discussed earlier, a SELECT operation in relational algebra involves fetching all the records that satisfy a given condition. Our previous implementation would select records from a relation and print them to the console. The actual NITCbase specification defines the SELECT operation as selecting records from a relation that satisfy a specific condition and writing those records into a newly created relation of a specified name. Since we have now implemented relation creation, we can finish our implementation of the ",(0,r.kt)("a",{parentName:"p",href:"/docs/User%20Interface%20Commands/dml#select--from-table-where"},"SELECT ","*"," FROM TABLE WHERE")," command."),(0,r.kt)("p",null,"A PROJECT operation on a relation is used to pick a subset of columns from the relation. In NITCbase, doing a PROJECT operation on a relation would result in the creation of a new relation with a subset of the attributes of the source relation. The required attributes will be picked from each record and inserted into the new relation."),(0,r.kt)("p",null,"Once you implement the ",(0,r.kt)("inlineCode",{parentName:"p"},"select()")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"project()")," operations in the ",(0,r.kt)("a",{parentName:"p",href:"/docs/Design/Algebra%20Layer"},"Algebra Layer"),", you will be able to add the following commands to your NITCbase using a combination of the two functions."),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Frontend User Interface Command"),(0,r.kt)("th",{parentName:"tr",align:null},"Operation"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/docs/User%20Interface%20Commands/dml#select--from-table-where"},"SELECT ","*"," FROM RelName INTO TargetName WHERE Attribute ",(0,r.kt)("inlineCode",{parentName:"a"},"op")," value")),(0,r.kt)("td",{parentName:"tr",align:null},"selection")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/docs/User%20Interface%20Commands/dml#select--from-table"},"SELECT ","*"," FROM RelName INTO TargetName")),(0,r.kt)("td",{parentName:"tr",align:null},"projection (clone relation)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/docs/User%20Interface%20Commands/dml#select-attrlist-from-table"},"SELECT Attr1,Attr2 FROM RelName INTO TargetName")),(0,r.kt)("td",{parentName:"tr",align:null},"projection")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/docs/User%20Interface%20Commands/dml#select-attrlist-from-table-where"},"SELECT Attr1,Attr2 FROM RelName INTO TargetName WHERE Attr ",(0,r.kt)("inlineCode",{parentName:"a"},"op")," value")),(0,r.kt)("td",{parentName:"tr",align:null},"selection ",(0,r.kt)("strong",{parentName:"td"},"and")," projection")))),(0,r.kt)("h2",{id:"implementation"},"Implementation"),(0,r.kt)("p",null,"A sequence diagram documenting the call sequence involved in a call to the ",(0,r.kt)("a",{parentName:"p",href:"/docs/User%20Interface%20Commands/dml##select-attrlist-from-table-where"},"SELECT AttrList FROM TABLE WHERE")," command is shown below. The calls to the ",(0,r.kt)("a",{parentName:"p",href:"/docs/Design/Cache%20Layer/intro"},"Cache Layer")," and ",(0,r.kt)("a",{parentName:"p",href:"/docs/Design/Buffer%20Layer/intro"},"Buffer Layer")," are omitted for the sake of clarity."),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},(0,r.kt)("strong",{parentName:"p"},"NOTE"),": The functions are denoted with circles as follows.",(0,r.kt)("br",null),"\n\ud83d\udd35 -> methods that are already in their final state",(0,r.kt)("br",null),"\n\ud83d\udfe2 -> methods that will attain their final state in this stage",(0,r.kt)("br",null),"\n\ud83d\udfe0 -> methods that we will modify in this stage, and in subsequent stages ",(0,r.kt)("br",null),"\n\ud83d\udfe4 -> methods that we built earlier and require more work later, but will leave as is in this stage")),(0,r.kt)("br",null),(0,r.kt)("mermaid",{value:" %%{init: { 'sequence': {'mirrorActors':false} } }%%\nsequenceDiagram\n    actor User\n    participant Frontend User Interface\n    participant Frontend Programming Interface\n    participant Algebra Layer\n    participant Schema Layer\n    participant Block Access Layer\n    User->>Frontend User Interface: SELECT attr1,attr2 FROM table\n    activate Frontend User Interface\n    Frontend User Interface->>Frontend Programming Interface:select_attrlist_from_table()\ud83d\udfe2\n    activate Frontend Programming Interface\n    Frontend Programming Interface->>Algebra Layer:project()\ud83d\udfe2\n    activate Algebra Layer\n\t\tAlgebra Layer->>Schema Layer:createRel()\ud83d\udd35\n\t\tactivate Schema Layer\n\t\tSchema Layer--\x3e>Algebra Layer: operation status\n\t\tdeactivate Schema Layer\n\t\tnote right of Algebra Layer: open new relation for insertion of records\n    loop for every record of source relation\n      Algebra Layer->>Block Access Layer:project()\ud83d\udfe2\n      activate Block Access Layer\n\t\t\tnote over Block Access Layer, Block Access Layer: fetch record from buffer<br/>and update search index\n\t\t\tBlock Access Layer--\x3e>Algebra Layer: a record\n\t\t\tdeactivate Block Access Layer\n\t\t\tnote right of Algebra Layer: create copy of record with only required attributes\n\t\t\tAlgebra Layer->>Block Access Layer: insert()\ud83d\udd35\n\t\t\tactivate Block Access Layer\n\t\t\tnote over Block Access Layer,Block Access Layer: insert records to buffer<br/>and update cache\n\t\t\tBlock Access Layer--\x3e>Algebra Layer:operation status\n\t\t\tdeactivate Block Access Layer\n    end\n    Algebra Layer--\x3e>User:operation status\n    deactivate Algebra Layer\n    deactivate Frontend Programming Interface\n    deactivate Frontend User Interface\n"}),(0,r.kt)("br",null),(0,r.kt)("p",null,"A class diagram highlighting the methods relevant to this stage is shown below."),(0,r.kt)("mermaid",{value:"classDiagram\n  class Algebra{\n    +insert(char relName[ATTR_SIZE], int nAttrs, char record[][ATTR_SIZE])$ int\ud83d\udd35\n    +select(char srcRel[ATTR_SIZE], char targetRel[ATTR_SIZE], char attr[ATTR_SIZE], int op, char strVal[ATTR_SIZE])$ int\ud83d\udfe0\n\t\t+project(char srcRel[ATTR_SIZE], char targetRel[ATTR_SIZE])$ int\ud83d\udfe2\n\t\t+project(char srcRel[ATTR_SIZE], char targetRel[ATTR_SIZE], int tar_nAttrs, char tar_Attrs[][ATTR_SIZE])$ int\ud83d\udfe2\n  }"}),(0,r.kt)("mermaid",{value:"classDiagram\n  class BlockAccess{\n    +linearSearch(int relId, char attrName[ATTR_SIZE], Attribute attrVal, int op)$ RecId\ud83d\udd35\n    +renameRelation(char oldName[ATTR_SIZE], char newName[ATTR_SIZE])$ int\ud83d\udd35\n    +renameAttribute(char relName[ATTR_SIZE], char oldName[ATTR_SIZE], char newName[ATTR_SIZE])$ int\ud83d\udd35\n    +insert(int relId, union Attribute* record)$ int\ud83d\udfe4\n    +search(int relId, Attribute *record, char attrName[ATTR_SIZE], Attribute attrVal, int op)$ int\ud83d\udfe4\n    +deleteRelation(char relName[ATTR_SIZE])$ int\ud83d\udfe4\n\t\t+project(int relId, Attribute *record)$ int\ud83d\udfe2\n  }"}),(0,r.kt)("br",null),(0,r.kt)("p",null,"In the ",(0,r.kt)("a",{parentName:"p",href:"/docs/Design/Block%20Access%20Layer"},"Block Access Layer"),", we implement the ",(0,r.kt)("inlineCode",{parentName:"p"},"project()")," function. This function is used to fetch ",(0,r.kt)("strong",{parentName:"p"},"one")," record of the relation. Each subsequent call would return the next record until there are no more records to be returned. Similar to the ",(0,r.kt)("inlineCode",{parentName:"p"},"linearSearch()")," function you implemented earlier, ",(0,r.kt)("inlineCode",{parentName:"p"},"project()")," makes use of the ",(0,r.kt)("inlineCode",{parentName:"p"},"searchIndex")," in the relation cache to keep track of the last"),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"NOTE: Even though this function is named ",(0,r.kt)("inlineCode",{parentName:"p"},"project()"),", it does not do a PROJECT operation. It effectively serves as a way to access the next record from a relation. The actual projection of the record to a subset of its columns is implemented in the ",(0,r.kt)("a",{parentName:"p",href:"/docs/Design/Algebra%20Layer"},"Algebra Layer"),". This function is named ",(0,r.kt)("inlineCode",{parentName:"p"},"project()")," only due to the fact that it serves as a helper function for the ",(0,r.kt)("inlineCode",{parentName:"p"},"Algebra::project()")," function.")),(0,r.kt)("details",null,(0,r.kt)("summary",null,"BlockAccess/BlockAccess.cpp"),(0,r.kt)("p",null,"Implement the ",(0,r.kt)("inlineCode",{parentName:"p"},"BlockAccess::project()")," function by looking at the algorithm given in the ",(0,r.kt)("a",{parentName:"p",href:"/docs/Design/Block%20Access%20Layer#blockaccess--project"},"design docs"),".")),(0,r.kt)("p",null,"In the ",(0,r.kt)("a",{parentName:"p",href:"/docs/Design/Algebra%20Layer"},"Algebra Layer"),", you had already implemented part of the ",(0,r.kt)("inlineCode",{parentName:"p"},"select()")," function in previous stages. In this stage, you will modify the function to create a new relation and insert the selected records into the new relation."),(0,r.kt)("p",null,"We also add two new overloaded functions ",(0,r.kt)("inlineCode",{parentName:"p"},"project(srcRel, targetRel)")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"project(srcRel, targetRel, numAttrs, attrs)")," which are responsible for the ",(0,r.kt)("a",{parentName:"p",href:"/docs/User%20Interface%20Commands/dml#select--from-table"},"SELECT ","*"," FROM TABLE")," and ",(0,r.kt)("a",{parentName:"p",href:"/docs/User%20Interface%20Commands/dml#select-attrlist-from-table"},"SELECT AttrList FROM TABLE")," commands respectively. The ",(0,r.kt)("a",{parentName:"p",href:"/docs/User%20Interface%20Commands/dml#select-attrlist-from-table-where"},"SELECT AttrList FROM TABLE WHERE")," also makes use of the ",(0,r.kt)("inlineCode",{parentName:"p"},"project(srcRel, targetRel, numAttrs, attrs)")," function. Note that the ",(0,r.kt)("inlineCode",{parentName:"p"},"project(srcRel, targetRel)")," function is used to create a copy of the source relation into the target relation."),(0,r.kt)("details",null,(0,r.kt)("summary",null,"Algebra/Algebra.cpp"),(0,r.kt)("p",null,"Implement the following functions looking at their respective design docs"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/docs/Design/Algebra%20Layer#select"},(0,r.kt)("inlineCode",{parentName:"a"},"Algebra::select()")),".",(0,r.kt)("br",null),(0,r.kt)("strong",{parentName:"li"},"NOTE"),": The definition of the above function involves a call to the ",(0,r.kt)("inlineCode",{parentName:"li"},"AttrCacheTable::resetSearchIndex()")," function before the call to the ",(0,r.kt)("inlineCode",{parentName:"li"},"BlockAccess::search()")," function. This call is only relevant when we are doing a B+ tree search. Since we have not yet implemented indexing, this call can be omitted. The rest of the design remains the same."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/docs/Design/Algebra%20Layer#project-all-attributes-copy-relation"},(0,r.kt)("inlineCode",{parentName:"a"},"Algebra::project(srcRel, targetRel)"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/docs/Design/Algebra%20Layer#project-specified-attributes"},(0,r.kt)("inlineCode",{parentName:"a"},"Algebra::project(srcRel, targetRel, numAttrs, attrs)"))))),(0,r.kt)("p",null,"Finally, in the ",(0,r.kt)("a",{parentName:"p",href:"/docs/Design/Frontend#frontend-programming-interface"},"Frontend Programming Interface"),", we update the handlers of the functions to call the respective ",(0,r.kt)("a",{parentName:"p",href:"/docs/Design/Algebra%20Layer"},"Algebra Layer")," methods."),(0,r.kt)("p",null,"Contrary to what we are used to, the implementation of the ",(0,r.kt)("inlineCode",{parentName:"p"},"Frontend::select_attrlist_from_table_where()")," function involves more than just a call to a lower layer method. Since this operation is a combination of both selection and projection, it requires calls to both the corresponding methods."),(0,r.kt)("p",null,"The function implementation involves creating an intermediate relation which holds the result of one of the operations. The second operation is done on this intermediate relation, following which the intermediate relation is deleted. NITCbase reserves the name of this intermediate relation as ",(0,r.kt)("inlineCode",{parentName:"p"},".temp")," (available to you as the constant ",(0,r.kt)("a",{parentName:"p",href:"/constants"},"TEMP"),")."),(0,r.kt)("details",null,(0,r.kt)("summary",null,"Frontend/Frontend.cpp"),(0,r.kt)("p",null,"Implement the following functions looking at their respective design docs"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/docs/Design/Frontend#frontend--select_from_table"},(0,r.kt)("inlineCode",{parentName:"a"},"Frontend::select_from_table()"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/docs/Design/Frontend#frontend--select_attrlist_from_table"},(0,r.kt)("inlineCode",{parentName:"a"},"Frontend::select_attrlist_from_table()"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/docs/Design/Frontend#frontend--select_from_table_where"},(0,r.kt)("inlineCode",{parentName:"a"},"Frontend::select_from_table_where()"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/docs/Design/Frontend#frontend--select_attrlist_from_table_where"},(0,r.kt)("inlineCode",{parentName:"a"},"Frontend::select_attrlist_from_table_where()"))))),(0,r.kt)("h2",{id:"exercises"},"Exercises"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Q1"),". Create a relation ",(0,r.kt)("inlineCode",{parentName:"p"},"Toys(id NUM, name STR, colour STR, stock NUM)")," and insert the values from ",(0,r.kt)("a",{target:"_blank",href:a(2027).Z},"this file")," into it. Then, run the following commands in your NITCbase."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT name,colour FROM Toys INTO ToyColours;\nSELECT * FROM Toys INTO ToysForSale WHERE stock>10;\nSELECT * FROM Toys INTO ToysCopy;\nSELECT id,name FROM Toys INTO BlueToys WHERE colour=blue;\n")),(0,r.kt)("p",null,"Verify the contents of the new relations in the XFS Interface using either the ",(0,r.kt)("a",{parentName:"p",href:"/docs/User%20Interface%20Commands/efs#print-relation"},"PRINT TABLE")," command or ",(0,r.kt)("a",{parentName:"p",href:"/docs/User%20Interface%20Commands/efs#export-relation"},"EXPORT")," command."))}d.isMDXComponent=!0},2027:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/files/s9toys-d2bd1f098f139a7b802a97abcb17cf30.txt"}}]);