"use strict";(self.webpackChunknitcbase=self.webpackChunknitcbase||[]).push([[7452],{3905:(e,t,a)=>{a.d(t,{Zo:()=>h,kt:()=>p});var n=a(7294);function o(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){o(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function l(e,t){if(null==e)return{};var a,n,o=function(e,t){if(null==e)return{};var a,n,o={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(o[a]=e[a]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(o[a]=e[a])}return o}var s=n.createContext({}),d=function(e){var t=n.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},h=function(e){var t=d(e.components);return n.createElement(s.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},u=n.forwardRef((function(e,t){var a=e.components,o=e.mdxType,r=e.originalType,s=e.parentName,h=l(e,["components","mdxType","originalType","parentName"]),u=d(a),p=o,k=u["".concat(s,".").concat(p)]||u[p]||c[p]||r;return a?n.createElement(k,i(i({ref:t},h),{},{components:a})):n.createElement(k,i({ref:t},h))}));function p(e,t){var a=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=a.length,i=new Array(r);i[0]=u;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:o,i[1]=l;for(var d=2;d<r;d++)i[d]=a[d];return n.createElement.apply(null,i)}return n.createElement.apply(null,a)}u.displayName="MDXCreateElement"},4968:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>c,frontMatter:()=>r,metadata:()=>l,toc:()=>d});var n=a(7462),o=(a(7294),a(3905));const r={title:"Stage 2: The Grand Picture"},i="Stage 2: The Grand Picture (1 week)",l={unversionedId:"Roadmap/Stage02",id:"Roadmap/Stage02",title:"Stage 2: The Grand Picture",description:"- Understand in detail about the different types of blocks on our XFS disk - record and index blocks",source:"@site/docs/Roadmap/Stage02.md",sourceDirName:"Roadmap",slug:"/Roadmap/Stage02",permalink:"/docs/Roadmap/Stage02",draft:!1,tags:[],version:"current",frontMatter:{title:"Stage 2: The Grand Picture"},sidebar:"Roadmap",previous:{title:"Stage 1 : Understanding NITCbase and its filesystem",permalink:"/docs/Roadmap/Stage01"}},s={},d=[{value:"What&#39;s on the disk?",id:"whats-on-the-disk",level:2},{value:"Records and Catalogs",id:"records-and-catalogs",level:3},{value:"Indexes",id:"indexes",level:3},{value:"What&#39;s in memory?",id:"whats-in-memory",level:2},{value:"Buffers",id:"buffers",level:3},{value:"Caches",id:"caches",level:3},{value:"What comes next?",id:"what-comes-next",level:2},{value:"Allocating New Blocks",id:"allocating-new-blocks",level:3},{value:"Search Operations",id:"search-operations",level:3},{value:"Update Operations",id:"update-operations",level:3},{value:"Freeing Blocks",id:"freeing-blocks",level:3},{value:"What&#39;s at the top?",id:"whats-at-the-top",level:2},{value:"Schema Operations",id:"schema-operations",level:3},{value:"Algebra Operations",id:"algebra-operations",level:3},{value:"Architecture",id:"architecture",level:2},{value:"Exercises",id:"exercises",level:2}],h={toc:d};function c(e){let{components:t,...a}=e;return(0,o.kt)("wrapper",(0,n.Z)({},h,a,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"stage-2-the-grand-picture-1-week"},"Stage 2: The Grand Picture (1 week)"),(0,o.kt)("admonition",{title:"Learning Objectives",type:"note"},(0,o.kt)("ul",{parentName:"admonition"},(0,o.kt)("li",{parentName:"ul"},"Understand in detail about the different types of blocks on our XFS disk - record and index blocks"),(0,o.kt)("li",{parentName:"ul"},"Learn in detail about the catalog data structures used in NITCbase - relation and attribute catalog"),(0,o.kt)("li",{parentName:"ul"},"Learn the fundamentals of indexing"),(0,o.kt)("li",{parentName:"ul"},"Learn about the runtime data structures used in NITCbase"),(0,o.kt)("li",{parentName:"ul"},"Learn about the operations on a relational DBMS"),(0,o.kt)("li",{parentName:"ul"},"Learn about the NITCbase architecture"))),(0,o.kt)("sub",null,(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"NOTE"),": ",(0,o.kt)("em",{parentName:"p"},"make sure that you don't get lost in the links as you follow along in this stage"),". You're not expected to read any links other than the ones mentioned specifically on this page. You'll be able to understand all the layers in more detail as we go further.")),(0,o.kt)("h2",{id:"whats-on-the-disk"},"What's on the disk?"),(0,o.kt)("p",null,"You must now be familiar with basic disk operations on the XFS disk. Here, we will discuss in detail about the classification of blocks and other data structures that are used in NITCbase."),(0,o.kt)("h3",{id:"records-and-catalogs"},"Records and Catalogs"),(0,o.kt)("p",null,"The main purpose of a relational database is to store and retrieve records. When we initially start adding entries to a database, we can obtain a random free disk block and start dumping the values into it one after another and we can traverse it just as easily. But, we're soon going to run out of space on the disk block. What will we do then? We'll get another random disk block and continue our process. But there's now a complication. How will we traverse between these two disk blocks while reading these entries. Clearly, we'll need to store the preceding and following disk block as some metadata in each block. You might've realized that this is in fact just a linked list and you're right. Records in NITCbase are stored in a linked list of disk blocks."),(0,o.kt)("p",null,"Now, what exactly is a ",(0,o.kt)("strong",{parentName:"p"},"record"),"? It is just an array of ",(0,o.kt)("strong",{parentName:"p"},"attribute values"),". Each relation can have a different number of attributes and the total number of records per disk block of a relation varies based on that. Each record block is divided into ",(0,o.kt)("strong",{parentName:"p"},"slots")," of variable record size and each slot stores a single record."),(0,o.kt)("p",null,"So, now we have a lot of relations each having their own records stored on the disk across multiple blocks. How do we identify and organise these blocks? The ",(0,o.kt)("strong",{parentName:"p"},"relation catalog")," solves this problem in NITCbase. It stores the relation name, the number of attributes and other information related to the record blocks for all the relations in the database."),(0,o.kt)("p",null,"We now have a provision to keep track of the list of relations that we have stored in the database. But we don't have any information regarding the attributes of each relation. In a production database, an attribute can be one of a myriad of possible types, but here in NITCbase, we'll restrict that to two possible types: ",(0,o.kt)("inlineCode",{parentName:"p"},"NUM")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"STR"),". Numbers and strings, as the name would suggest. Both of these types are fixed at a size 16 bytes for the sake of simplicity. The ",(0,o.kt)("strong",{parentName:"p"},"attribute catalog")," stores these details of all the attributes of every relation in the database. It also stores details about indices created on attributes. We'll get into the details of indexing later."),(0,o.kt)("p",null,"The relation catalog and attribute catalog together allows us to get all the relations and their respective schemas from our disk. If you didn't realise it yet, the relation and attribute catalog themselves are just relations on our disk! And as such, the blocks storing all the data we mentioned are just record blocks. The first entries in the relation catalog are for itself and the attribute catalog. And the first entries in the attribute catalog are the attributes of the relation catalog and the attributes of itself. You'll ",(0,o.kt)("a",{parentName:"p",href:"/docs/Design/Physical%20Layer#disk-model"},"remember")," that the first few blocks are reserved for these data structures."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Read the documentation for ",(0,o.kt)("a",{parentName:"strong",href:"/docs/Design/Physical%20Layer#record-block-structure"},"record blocks")," and ",(0,o.kt)("a",{parentName:"strong",href:"/docs/Design/Physical%20Layer#catalog-structures"},"catalog structures")," before proceeding further.")),(0,o.kt)("details",null,(0,o.kt)("summary",null,"Q. Consider the following catalog entries and record for a relation.",(0,o.kt)("table",null,(0,o.kt)("thead",null,(0,o.kt)("tr",null,(0,o.kt)("th",{colspan:"6"},"Relation Catalog Entry"))),(0,o.kt)("tbody",null,(0,o.kt)("tr",null,(0,o.kt)("th",null,"RelName")," ",(0,o.kt)("th",null,"#Attrs")," ",(0,o.kt)("th",null,"#Records")," ",(0,o.kt)("th",null,"FirstBlock")," ",(0,o.kt)("th",null,"LastBlock")," ",(0,o.kt)("th",null,"#Slots")),(0,o.kt)("tr",null,(0,o.kt)("td",null,"Students")," ",(0,o.kt)("td",null,"?")," ",(0,o.kt)("td",null,"?")," ",(0,o.kt)("td",null,"34")," ",(0,o.kt)("td",null,"35")," ",(0,o.kt)("td",null,"?")))),(0,o.kt)("table",null,(0,o.kt)("thead",null,(0,o.kt)("tr",null,(0,o.kt)("th",{colspan:"6"},"Attribute Catalog Entry"))),(0,o.kt)("tbody",null,(0,o.kt)("tr",null,(0,o.kt)("th",null,"RelName")," ",(0,o.kt)("th",null,"AttrName")," ",(0,o.kt)("th",null,"AttrType")," ",(0,o.kt)("th",null,"PrimaryFlag")," ",(0,o.kt)("th",null,"RootBlock")," ",(0,o.kt)("th",null,"Offset")),(0,o.kt)("tr",null,(0,o.kt)("td",null,"Students")," ",(0,o.kt)("td",null,"Name")," ",(0,o.kt)("td",null,"?")," ",(0,o.kt)("td",null,"-")," ",(0,o.kt)("td",null,"-1")," ",(0,o.kt)("td",null,"?")),(0,o.kt)("tr",null,(0,o.kt)("td",null,"Students")," ",(0,o.kt)("td",null,"RollNo")," ",(0,o.kt)("td",null,"?")," ",(0,o.kt)("td",null,"-")," ",(0,o.kt)("td",null,"-1")," ",(0,o.kt)("td",null,"?")),(0,o.kt)("tr",null,(0,o.kt)("td",null,"Students")," ",(0,o.kt)("td",null,"Marks")," ",(0,o.kt)("td",null,"?")," ",(0,o.kt)("td",null,"-")," ",(0,o.kt)("td",null,"-1")," ",(0,o.kt)("td",null,"?")))),(0,o.kt)("table",null,(0,o.kt)("thead",null,(0,o.kt)("tr",null,(0,o.kt)("th",{colspan:"6"},"section from the record block"))),(0,o.kt)("tbody",null,(0,o.kt)("tr",null,(0,o.kt)("td",null,"...")," ",(0,o.kt)("td",null,"B190539CS")," ",(0,o.kt)("td",null,"Jacques")," ",(0,o.kt)("td",null,"91.08")," ",(0,o.kt)("td",null,"...")))),(0,o.kt)("p",null,"Assume that the relation has only two record blocks and both are fully filled. Find all the missing values (marked with ",(0,o.kt)("inlineCode",{parentName:"p"},"?"),").",(0,o.kt)("br",null),"\n(click to view answer)",(0,o.kt)("br",null))),"pending answer. how to: 3 attrs -> 41 slots -> 82 records. attr type and offset from record."),(0,o.kt)("h3",{id:"indexes"},"Indexes"),(0,o.kt)("p",null,"We'd discussed the necessity of indexing in the earlier stage. NITCbase uses the B+ tree data structure for this purpose. ",(0,o.kt)("strong",{parentName:"p"},"Read the section about ",(0,o.kt)("a",{parentName:"strong",href:"/docs/Misc/B+%20Trees"},"B+ trees")," before proceeding further.")),(0,o.kt)("p",null,"We now know about B+ trees and operations on them. How exactly does NITCbase use them?",(0,o.kt)("br",null),"\nAs we mentioned earlier, a relation in a production database can contain millions or records and might span over a large number of disk blocks. This relation will be made up of some number of attributes. If we find ourselves frequently doing operations on the values of one specific attribute, then it would be wise to create an index on that attribute for that relation."),(0,o.kt)("p",null,"For example, consider the relation ",(0,o.kt)("inlineCode",{parentName:"p"},"Student")," having 5 attributes (",(0,o.kt)("inlineCode",{parentName:"p"},"Roll No"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"Name"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"Marks"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"Grade"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"Attendance"),"). As an administrator, we might have to frequently get the subset of students having ",(0,o.kt)("inlineCode",{parentName:"p"},"Marks")," greater than some amount ",(0,o.kt)("inlineCode",{parentName:"p"},"M"),". Instead of going through each and every record and checking if it satisfies our condition, the index allows us to easily reach the first record with ",(0,o.kt)("inlineCode",{parentName:"p"},"Marks")," > ",(0,o.kt)("inlineCode",{parentName:"p"},"M"),". We know that in a B+ tree, every subsequent leaf node will also satisfy this condition (Why?). You can see how this would save us a lot of time."),(0,o.kt)("p",null,"In NITCbase, indexes are B+ trees with ",(0,o.kt)("strong",{parentName:"p"},"internal nodes of size 100"),", and ",(0,o.kt)("strong",{parentName:"p"},"leaf nodes of size 63"),". Each of these nodes will be stored in a separate disk block. A fully filled internal node would consist of a 100 attribute values from various records and 101 pointers to their respective children. A pointer here refers to the block number of the corresponding internal or leaf index block. A fully filled leaf node would consist of 63 attribute values from various records along with the block number and slot number where the record containing this attribute can be found."),(0,o.kt)("p",null,"The ",(0,o.kt)("a",{parentName:"p",href:"/docs/Design/Physical%20Layer#attribute-catalog"},"attribute catalog")," stores whether a particular attribute of a relation has an index. If it does, the ",(0,o.kt)("inlineCode",{parentName:"p"},"RootBlock")," field of the attribute catalog will store the block number of the root block of the index."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Read the documentation for ",(0,o.kt)("a",{parentName:"strong",href:"/docs/Design/Physical%20Layer#internal-index-block-structure"},"internal index blocks")," and ",(0,o.kt)("a",{parentName:"strong",href:"/docs/Design/Physical%20Layer#leaf-index-block-structure"},"leaf index blocks")," before proceeding further.")),(0,o.kt)("h2",{id:"whats-in-memory"},"What's in memory?"),(0,o.kt)("p",null,"You now know all about the ",(0,o.kt)("a",{parentName:"p",href:"/docs/Design/Physical%20Layer"},"Physical Layer")," of NITCbase and how the data is represented on the disk. However, disk operations are quite slow and a bottleneck to the efficient functioning of our database. Memory operations are much more efficient, but are subject to space constraints. We should ensure that our system makes optimum use of memory wherever possible to build a fast and responsive database."),(0,o.kt)("h3",{id:"buffers"},"Buffers"),(0,o.kt)("p",null,"Following the ",(0,o.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Locality_of_reference"},"principle of locality"),", NITCbase buffers all the disk i/o operations. We will be pre-allocating memory for holding 32 disk blocks in memory at a given time. Whenever a disk block is accessed for the first time, it will be loaded into the buffer. All subsequent operations on that block will be done on that buffer until that disk block is swapped out by a more recently required disk block. All the changes done to the buffer will be commited back to the disk at that point."),(0,o.kt)("p",null,"We'll learn in detail about this as we implement the ",(0,o.kt)("a",{parentName:"p",href:"/docs/Design/Buffer%20Layer"},"Buffer Layer"),"."),(0,o.kt)("h3",{id:"caches"},"Caches"),(0,o.kt)("p",null,"Almost all operations on a relation require access to its corresponding Relation Catalog and Attribute Catalog entries. We will be pre-allocating memory to cache the catalogs of 12 relations at a given time. A relation is said to be ",(0,o.kt)("strong",{parentName:"p"},"open")," if it's catalog entries are loaded into memory. The ",(0,o.kt)("strong",{parentName:"p"},"relation catalog and attribute catalog are always open")," (recall that the relation and attribute catalog too are just relations in our database) since the values stored in these relations will be frequently used and it's beneficial to avoid the overhead of loading it to memory as required. Any other relation will have to be ",(0,o.kt)("em",{parentName:"p"},"opened")," before any operation can be done on it."),(0,o.kt)("p",null,"We have three data structures to store this information: ",(0,o.kt)("strong",{parentName:"p"},"the relation cache"),", the ",(0,o.kt)("strong",{parentName:"p"},"attribute cache")," and the ",(0,o.kt)("strong",{parentName:"p"},"open relation table"),". The open relation table stores details about the currently open relations. A relation needs to have an entry in the open relation table for it to be considered ",(0,o.kt)("em",{parentName:"p"},"open"),". The relation cache stores the relation catalog entry of an open relation. The attribute cache stores details about all the attributes of an open relation as a linked list of attribute catalog entries. These caches also store a ",(0,o.kt)("inlineCode",{parentName:"p"},"searchIndex")," field which saves the block and slot of the last search hit (we'll cover this field later)."),(0,o.kt)("p",null,"We'll learn in detail about this as we implement the ",(0,o.kt)("a",{parentName:"p",href:"/docs/Design/Cache%20Layer"},"Cache Layer"),"."),(0,o.kt)("h2",{id:"what-comes-next"},"What comes next?"),(0,o.kt)("p",null,"We now understand the low level representation of data in the disk blocks. How is this data saved as so? What do we do with this data? We'll find out."),(0,o.kt)("h3",{id:"allocating-new-blocks"},"Allocating New Blocks"),(0,o.kt)("p",null,"A new block can be obtained by looking at the ",(0,o.kt)("a",{parentName:"p",href:"/docs/Design/Physical%20Layer#disk-model"},"Block Allocation Map")," for a free entry. We can then load this new block into the buffer and initialise the header with the required header values. If it's a record block, we need to make sure that we add it to the linked list by setting ",(0,o.kt)("inlineCode",{parentName:"p"},"LBlock")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"RBlock"),". An index block will have to be added as the appropriate left or right child and ",(0,o.kt)("inlineCode",{parentName:"p"},"PBlock")," needs to be set."),(0,o.kt)("h3",{id:"search-operations"},"Search Operations"),(0,o.kt)("p",null,"A search operation involves fetching all records that satisfy some condition. In NITCbase, search can proceed in one of two ways. If an index is present on our search condition attribute, we can do a B+ search; else we'll have to do a linear search on all the records of the relation. We'll implement a function that will do the appropriate search and return to us a record that satisfies our condition each time it's called. Higher levels can call this function until a null condition to fetch all the records satisfying the condition. You will implement this while working on the ",(0,o.kt)("a",{parentName:"p",href:"/docs/Design/Block%20Access%20Layer"},"Block Access Layer"),"."),(0,o.kt)("p",null,"You might've realized that the above function would require some global state to work as intended. We'll need to keep track of the previously found record so that we can fetch the next record that satisfies the condition. And that is exactly what the ",(0,o.kt)("inlineCode",{parentName:"p"},"searchIndex")," field in the relation and attribute cache do. ",(0,o.kt)("inlineCode",{parentName:"p"},"searchIndex")," in the relation cache is used to store the last hit during linear search on that relation. ",(0,o.kt)("inlineCode",{parentName:"p"},"searchIndex")," in the attribute cache is used to store the last hit during a B+ search on the index of that attribute. A value of ",(0,o.kt)("inlineCode",{parentName:"p"},"{-1, -1}")," indicates that the search should start over from the beginning again."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Read through the documentation for ",(0,o.kt)("a",{parentName:"strong",href:"/docs/Misc/Indexing"},"indexing")," to learn about the insertion and search operations on indexes.")," You will be implementing this while working on the ",(0,o.kt)("a",{parentName:"p",href:"/docs/Design/B+%20Tree%20Layer"},"B+ Tree Layer"),"."),(0,o.kt)("h3",{id:"update-operations"},"Update Operations"),(0,o.kt)("p",null,"All updates to the data are done on the buffer and commited to the disk as required. For a record/index block, the changes in the buffer will be written to the disk when the block is swapped out of the buffer to free up the slot. For operations which require modifications to the relation or attribute catalog, the changes will be written to their respective caches and written back to the disk when an NITCbase session terminates."),(0,o.kt)("h3",{id:"freeing-blocks"},"Freeing Blocks"),(0,o.kt)("p",null,"To free a block, we update the block allocation map for that block index to be free and remove the reference to that block from any referencing blocks. Since NITCbase does not support a partial delete operation, we will not need to implement individual freeing of blocks and will only have to free all associated blocks at once."),(0,o.kt)("details",null,(0,o.kt)("summary",null,(0,o.kt)("p",null,"Q. Assume we have an empty database with no relations. We start it and create a table ",(0,o.kt)("inlineCode",{parentName:"p"},"LibraryBooks")," with attributes (",(0,o.kt)("inlineCode",{parentName:"p"},"name"),": STR, ",(0,o.kt)("inlineCode",{parentName:"p"},"id"),": NUM, ",(0,o.kt)("inlineCode",{parentName:"p"},"shelf"),": NUM, ",(0,o.kt)("inlineCode",{parentName:"p"},"borrower"),": STR).We then insert 1000 records into the relation ",(0,o.kt)("inlineCode",{parentName:"p"},"LibraryBooks")," in descending order of their ",(0,o.kt)("inlineCode",{parentName:"p"},"id")," (id from 1000 to 1)."),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"If we were to do a search for a book with ",(0,o.kt)("inlineCode",{parentName:"li"},"id")," < 500, which book would we get? What's the corresponding record-id?"),(0,o.kt)("li",{parentName:"ol"},"We then create an index on ",(0,o.kt)("inlineCode",{parentName:"li"},"id")," for ",(0,o.kt)("inlineCode",{parentName:"li"},"LibraryBooks"),". How many index blocks would be created?"),(0,o.kt)("li",{parentName:"ol"},"How many entries does the root block have? What is the rightmost value in the root block?"),(0,o.kt)("li",{parentName:"ol"},"If we were to again do a search for a book with ",(0,o.kt)("inlineCode",{parentName:"li"},"id")," > 500, which book would we get? What's the corresponding record-id?"),(0,o.kt)("li",{parentName:"ol"},"What are the contents of the relation cache and the attribute cache?"),(0,o.kt)("li",{parentName:"ol"},"What are the contents of the relation catalog and attribute catalog on the disk?")),(0,o.kt)("p",null,"(click to view answer)")),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Answer"),"(pending rewrite)"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"book with ",(0,o.kt)("inlineCode",{parentName:"li"},"id")," 1000 because that's the first record"),(0,o.kt)("li",{parentName:"ol"},"31 index blocks. 1 internal index."),(0,o.kt)("li",{parentName:"ol"},"30 entries. rightmost value is 969."),(0,o.kt)("li",{parentName:"ol"},"we would get the book with ",(0,o.kt)("inlineCode",{parentName:"li"},"id")," 501 because it's in ascending order"),(0,o.kt)("li",{parentName:"ol"},"it would contain entries for the relation with the appropriate search index filled in."),(0,o.kt)("li",{parentName:"ol"},"it would be as if the relation was not created because we have not written back to the disk."))),(0,o.kt)("h2",{id:"whats-at-the-top"},"What's at the top?"),(0,o.kt)("p",null,"We've now got a bottom-up view of how NITCbase stores and uses the data. Let's take a top-down look at all the operations our database will support and how we'll implement them."),(0,o.kt)("h3",{id:"schema-operations"},"Schema Operations"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"Table Creation and Deletion"),(0,o.kt)("br",null),"\nCreating a table is a fundamental operation in a database. In NITCbase, table creation entails the following steps;"),(0,o.kt)("ol",{parentName:"li"},(0,o.kt)("li",{parentName:"ol"},"Ensure that a relation with the same name does not already exist by iterating through the relation catalog"),(0,o.kt)("li",{parentName:"ol"},"Insert a new entry into the relation catalog. We will have to do this operation on the relation catalog disk block directly since we do not have a relation cache entry(Why?)"),(0,o.kt)("li",{parentName:"ol"},"Insert entries for all the new attributes into the appropriate attribute catalog disk block. This too will have to be done to the disk block directly.")),(0,o.kt)("p",{parentName:"li"},"Deleting a table involves removing all the entries created during the table creation and freeing all the record blocks used by the relation.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"Table Opening and Closing"),(0,o.kt)("br",null),"\nAs we mentioned earlier, a table needs to be open for any operation to be done on it. Opening a relation involves loading the relation and attribute catalog entries for the relation into the relation and attribute cache respectively. ",(0,o.kt)("br",null),"\nClosing a relation involves writing back any changes that occured to the cache to the disk block and freeing the memory allocated during opening. ",(0,o.kt)("br",null),"\nThe relation catalog and attribute catalog will always be open and cannot be closed.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"Index Creation and Deletion"),(0,o.kt)("br",null),"\nA high-end database might automatically create and dispose of indexes as required by the program without user intervention. In NITCbase, the user is expected to decide when the index is to be created and dropped. Creating an index on an attribute involves iterating through all the records of the relation and inserting the attribute value as well as a pointer to the record into a B+ tree.",(0,o.kt)("br",null),"\nIndex deletion involves recursively deleting all the nodes of the B+ tree.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"Table and Column Rename"),(0,o.kt)("br",null),"\nNITCbase allows us to rename existing relations and their attributes. This is done by updating the relation/attribute cache."))),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Read through the documentation for ",(0,o.kt)("a",{parentName:"strong",href:"/docs/User%20Interface%20Commands/ddl"},"DDL Commands")," before proceeding further.")," We'll look into detail about the implementation of these features as we develop the ",(0,o.kt)("a",{parentName:"p",href:"/docs/Design/Schema%20Layer"},"Schema Layer"),"."),(0,o.kt)("h3",{id:"algebra-operations"},"Algebra Operations"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"Insertion"),(0,o.kt)("br",null),"\nAny database will have to support the basic operation of inserting records. Inserting records into a relation in NITCbase involves the following steps."),(0,o.kt)("ol",{parentName:"li"},(0,o.kt)("li",{parentName:"ol"},"ensuring that the relation is open and not the relation/attribute catalog"),(0,o.kt)("li",{parentName:"ol"},"fetch the relation catalog entry from the relation cache"),(0,o.kt)("li",{parentName:"ol"},"get the first record block for the relation from the relation catalog entry"),(0,o.kt)("li",{parentName:"ol"},"iterate through all the slots of the block and every subsequent record block until a free slot is found (using the slot map)"),(0,o.kt)("li",{parentName:"ol"},"if a free slot is not found, allocate a new record block for the relation and update the relation cache and the block headers to add it to the linked list."),(0,o.kt)("li",{parentName:"ol"},"set the record values in the free slot found and update the ",(0,o.kt)("inlineCode",{parentName:"li"},"numEntries")," in the relation cache and other fields in the header of the block."),(0,o.kt)("li",{parentName:"ol"},"do a b+ tree insertion if any index exists for this relation"))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"Selection"),(0,o.kt)("br",null),"\nA selection operation on a relation is used to select a subset of the records satisfying a certain condition. NITCbase supports selection with the following operators: ",(0,o.kt)("inlineCode",{parentName:"p"},"="),", ",(0,o.kt)("inlineCode",{parentName:"p"},"!="),", ",(0,o.kt)("inlineCode",{parentName:"p"},">"),", ",(0,o.kt)("inlineCode",{parentName:"p"},">="),", ",(0,o.kt)("inlineCode",{parentName:"p"},"<")," ",(0,o.kt)("inlineCode",{parentName:"p"},">="),". We will be able to select the records that fit the condition into a new relation.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"Projection"),(0,o.kt)("br",null),"\nA projection operation is used to pick a subset of attributes from a relation. The specified attributes from all the records of the relation will be projected. NITCbase supports projection into a new relation.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"Joins"),(0,o.kt)("br",null),"\nThe join operation is used to combine two relations with respect to a condition on two columns from the respective relations. NITCbase allows us to combine two relations into a new relation with the ",(0,o.kt)("inlineCode",{parentName:"p"},"=")," condition. This is called an ",(0,o.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Relational_algebra#%CE%B8-join_and_equijoin"},"equijoin"),"."))),(0,o.kt)("p",null,"NITCbase also allows you to do any combination of selection, projection and join together in a single command to create a new target relation with the specified properties."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Read through the documentation for ",(0,o.kt)("a",{parentName:"strong",href:"/docs/User%20Interface%20Commands/dml"},"DML Commands")," before proceeding further.")," We'll look into detail about the implementation of these features as we develop the ",(0,o.kt)("a",{parentName:"p",href:"/docs/Design/Algebra%20Layer"},"Algebra Layer"),"."),(0,o.kt)("details",null,(0,o.kt)("summary",null,(0,o.kt)("p",null,"Q. Consider we have a relation ",(0,o.kt)("inlineCode",{parentName:"p"},"Events")," with the attributes (",(0,o.kt)("inlineCode",{parentName:"p"},"id"),": NUM, ",(0,o.kt)("inlineCode",{parentName:"p"},"title"),": STR, ",(0,o.kt)("inlineCode",{parentName:"p"},"location"),": STR) and a relation ",(0,o.kt)("inlineCode",{parentName:"p"},"Locations")," with the attributes name(",(0,o.kt)("inlineCode",{parentName:"p"},"name"),": STR, ",(0,o.kt)("inlineCode",{parentName:"p"},"capacity"),": NUM). There are no index blocks on the disk. We run the following commands on our frontend interface."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"OPEN TABLE Events;\nSELECT * FROM Events INTO Lectures WHERE location=ELHC;\nOPEN TABLE Locations;\nOPEN TABLE Lectures;\nSELECT title, location, capacity FROM Lectures JOIN INTO LectureCapacities Locations WHERE Lectures.location = Locations.name;\nDROP TABLE Lectures;\nALTER TABLE RENAME LectureCapacities TO Lectures;\n")),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"What are the entries in the relation cache and attribute cache for the new relation?"),(0,o.kt)("li",{parentName:"ol"},"What commands could we have run to speed up these operations?"),(0,o.kt)("li",{parentName:"ol"},"Suppose we add a relation ",(0,o.kt)("inlineCode",{parentName:"li"},"Participants")," with attributes (",(0,o.kt)("inlineCode",{parentName:"li"},"regNo"),": NUM, ",(0,o.kt)("inlineCode",{parentName:"li"},"event"),": STR). Write commands to filter only the students who are attending the event happening in the location ",(0,o.kt)("em",{parentName:"li"},"Auditorium"),"."))),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Answer"),"(Pending)"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"relation lectures with combined attrs"),(0,o.kt)("li",{parentName:"ol"},"create indexes on join attrs (mention that we'll auto create indexes)"),(0,o.kt)("li",{parentName:"ol"},"join + select + project operations"))),(0,o.kt)("h2",{id:"architecture"},"Architecture"),(0,o.kt)("p",null,"You must now have an understanding of the functionalities provided to you by NITCbase and how they are represented in a lower level. We can now get into the finer details of our architecture. NITCbase has a 7-layer object-oriented architecture with each layer specialising in some operation. ",(0,o.kt)("strong",{parentName:"p"},"Take a look at the ",(0,o.kt)("a",{parentName:"strong",href:"/docs/Design/Architecture"},"architecture")," page before proceeding further"),". You don't need to understand everything mentioned there at this point. You could also take a look at the ",(0,o.kt)("a",{parentName:"p",href:"/docs/Design/DesignDiagram"},"system design")," to get a detailed idea about the flow of information between layers."),(0,o.kt)("h2",{id:"exercises"},"Exercises"),(0,o.kt)("details",null,(0,o.kt)("summary",null,"Q1. Insert question here"),"only final answers."))}c.isMDXComponent=!0}}]);