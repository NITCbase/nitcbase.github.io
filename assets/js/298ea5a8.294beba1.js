"use strict";(self.webpackChunknitcbase=self.webpackChunknitcbase||[]).push([[6958],{3905:(e,t,r)=>{r.d(t,{Zo:()=>h,kt:()=>b});var n=r(7294);function a(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function l(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function i(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?l(Object(r),!0).forEach((function(t){a(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):l(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function o(e,t){if(null==e)return{};var r,n,a=function(e,t){if(null==e)return{};var r,n,a={},l=Object.keys(e);for(n=0;n<l.length;n++)r=l[n],t.indexOf(r)>=0||(a[r]=e[r]);return a}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(n=0;n<l.length;n++)r=l[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(a[r]=e[r])}return a}var c=n.createContext({}),s=function(e){var t=n.useContext(c),r=t;return e&&(r="function"==typeof e?e(t):i(i({},t),e)),r},h=function(e){var t=s(e.components);return n.createElement(c.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},g=n.forwardRef((function(e,t){var r=e.components,a=e.mdxType,l=e.originalType,c=e.parentName,h=o(e,["components","mdxType","originalType","parentName"]),g=s(r),b=a,d=g["".concat(c,".").concat(b)]||g[b]||u[b]||l;return r?n.createElement(d,i(i({ref:t},h),{},{components:r})):n.createElement(d,i({ref:t},h))}));function b(e,t){var r=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var l=r.length,i=new Array(l);i[0]=g;var o={};for(var c in t)hasOwnProperty.call(t,c)&&(o[c]=t[c]);o.originalType=e,o.mdxType="string"==typeof e?e:a,i[1]=o;for(var s=2;s<l;s++)i[s]=r[s];return n.createElement.apply(null,i)}return n.createElement.apply(null,r)}g.displayName="MDXCreateElement"},7959:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>u,frontMatter:()=>l,metadata:()=>o,toc:()=>s});var n=r(7462),a=(r(7294),r(3905));const l={sidebar_position:2,title:"Algebra Layer"},i="Algebra Layer Stub Code",o={unversionedId:"Misc/stub/algebra",id:"Misc/stub/algebra",title:"Algebra Layer",description:"Algebra.cpp",source:"@site/docs/Misc/stub/algebra.md",sourceDirName:"Misc/stub",slug:"/Misc/stub/algebra",permalink:"/docs/Misc/stub/algebra",draft:!1,tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2,title:"Algebra Layer"},sidebar:"stubSidebar",previous:{title:"Frontend Programming Interface",permalink:"/docs/Misc/stub/frontend"},next:{title:"Schema Layer",permalink:"/docs/Misc/stub/schema"}},c={},s=[{value:"Algebra.cpp",id:"algebracpp",level:2}],h={toc:s};function u(e){let{components:t,...r}=e;return(0,a.kt)("wrapper",(0,n.Z)({},h,r,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"algebra-layer-stub-code"},"Algebra Layer Stub Code"),(0,a.kt)("h2",{id:"algebracpp"},"Algebra.cpp"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"int Algebra::insert(char relName[ATTR_SIZE], int nAttrs, char record[][ATTR_SIZE]){\n    // if relName is equal to \"RELATIONCAT\" or \"ATTRIBUTECAT\"\n    // return E_NOTPERMITTED;\n\n    // get the relation's rel-id using OpenRelTable::getRelId() method\n    int relId = OpenRelTable::getRelId(relName);\n\n    // if relation is not open in open relation table, return E_RELNOTOPEN\n    // (check if the value returned from getRelId function call = E_RELNOTOPEN)\n    // get the relation catalog entry from relation cache\n    // (use RelCacheTable::getRelCatEntry() of Cache Layer)\n\n    /* if relCatEntry.numAttrs != numberOfAttributes in relation,\n       return E_NATTRMISMATCH */\n\n    // let recordValues[numberOfAttributes] be an array of type union Attribute\n\n    /*\n        Converting 2D char array of record values to Attribute array recordValues\n     */\n    // iterate through 0 to nAttrs-1: (let i be the iterator)\n    {\n        // get the attr-cat entry for the i'th attribute from the attr-cache\n        // (use AttrCacheTable::getAttrCatEntry())\n\n        // let type = attrCatEntry.attrType;\n\n        if (type == NUMBER)\n        {\n            // if the char array record[i] can be converted to a number\n            // (check this using isNumber() function)\n            {\n                /* convert the char array to numeral and store it\n                   at recordValues[i].nVal using atof() */\n            }\n            // else\n            {\n                return E_ATTRTYPEMISMATCH;\n            }\n        }\n        else if (type == STRING)\n        {\n            // copy record[i] to recordValues[i].sVal\n        }\n    }\n\n    // insert the record by calling BlockAccess::insert() function\n    // let retVal denote the return value of insert call\n\n    return retVal;\n}\n\n\nint Algebra::select(char srcRel[ATTR_SIZE], char targetRel[ATTR_SIZE], char attr[ATTR_SIZE], int op, char strVal[ATTR_SIZE]) {\n    // get the srcRel's rel-id (let it be srcRelid), using OpenRelTable::getRelId()\n    // if srcRel is not open in open relation table, return E_RELNOTOPEN\n\n    // get the attr-cat entry for attr, using AttrCacheTable::getAttrCatEntry()\n    // if getAttrcatEntry() call fails return E_ATTRNOTEXIST\n\n\n    /*** Convert strVal to an attribute of data type NUMBER or STRING ***/\n\n    Attribute attrVal;\n    int type = attrCatEntry.attrType;\n\n    if (type == NUMBER)\n    {\n        // if the input argument strVal can be converted to a number\n        // (check this using isNumber() function)\n        {\n            // convert strVal to double and store it at attrVal.nVal using atof()\n        }\n        // else\n        {\n            return E_ATTRTYPEMISMATCH;\n        }\n    }\n    else if (type == STRING)\n    {\n        // copy strVal to attrVal.sVal\n    }\n\n    /*** Creating and opening the target relation ***/\n    // Prepare arguments for createRel() in the following way:\n    // get RelcatEntry of srcRel using RelCacheTable::getRelCatEntry()\n    int src_nAttrs = /* the no. of attributes present in src relation */ ;\n\n\n    /* let attr_names[src_nAttrs][ATTR_SIZE] be a 2D array of type char\n        (will store the attribute names of rel). */\n    // let attr_types[src_nAttrs] be an array of type int\n\n    /*iterate through 0 to src_nAttrs-1 :\n        get the i'th attribute's AttrCatEntry using AttrCacheTable::getAttrCatEntry()\n        fill the attr_names, attr_types arrays that we declared with the entries\n        of corresponding attributes\n    */\n\n\n    /* Create the relation for target relation by calling Schema::createRel()\n       by providing appropriate arguments */\n    // if the createRel returns an error code, then return that value.\n\n    /* Open the newly created target relation by calling OpenRelTable::openRel()\n       method and store the target relid */\n    /* If opening fails, delete the target relation by calling Schema::deleteRel()\n       and return the error value returned from openRel() */\n\n    /*** Selecting and inserting records into the target relation ***/\n    /* Before calling the search function, reset the search to start from the\n       first using RelCacheTable::resetSearchIndex() */\n\n    Attribute record[src_nAttrs];\n\n    /*\n        The BlockAccess::search() function can either do a linearSearch or\n        a B+ tree search. Hence, reset the search index of the relation in the\n        relation cache using RelCacheTable::resetSearchIndex().\n        Also, reset the search index in the attribute cache for the select\n        condition attribute with name given by the argument `attr`. Use\n        AttrCacheTable::resetSearchIndex().\n        Both these calls are necessary to ensure that search begins from the\n        first record.\n    */\n    RelCacheTable::resetSearchIndex(/* fill arguments */);\n    AttrCacheTable::resetSearchIndex(/* fill arguments */);\n\n    // read every record that satisfies the condition by repeatedly calling\n    // BlockAccess::search() until there are no more records to be read\n\n    while (/* BlockAccess::search() returns success */) {\n\n        // ret = BlockAccess::insert(targetRelId, record);\n\n        // if (insert fails) {\n        //     close the targetrel(by calling Schema::closeRel(targetrel))\n        //     delete targetrel (by calling Schema::deleteRel(targetrel))\n        //     return ret;\n        // }\n    }\n\n    // Close the targetRel by calling closeRel() method of schema layer\n\n    // return SUCCESS.\n}\n\n\nint Algebra::project(char srcRel[ATTR_SIZE], char targetRel[ATTR_SIZE], int tar_nAttrs, char tar_Attrs[][ATTR_SIZE]) {\n\n    int srcRelId = /*srcRel's rel-id (use OpenRelTable::getRelId() function)*/\n\n    // if srcRel is not open in open relation table, return E_RELNOTOPEN\n\n    // get RelCatEntry of srcRel using RelCacheTable::getRelCatEntry()\n\n    // get the no. of attributes present in relation from the fetched RelCatEntry.\n\n    // declare attr_offset[tar_nAttrs] an array of type int.\n    // where i-th entry will store the offset in a record of srcRel for the\n    // i-th attribute in the target relation.\n\n    // let attr_types[tar_nAttrs] be an array of type int.\n    // where i-th entry will store the type of the i-th attribute in the\n    // target relation.\n\n\n    /*** Checking if attributes of target are present in the source relation\n         and storing its offsets and types ***/\n\n    /*iterate through 0 to tar_nAttrs-1 :\n        - get the attribute catalog entry of the attribute with name tar_attrs[i].\n        - if the attribute is not found return E_ATTRNOTEXIST\n        - fill the attr_offset, attr_types arrays of target relation from the\n          corresponding attribute catalog entries of source relation\n    */\n\n\n    /*** Creating and opening the target relation ***/\n\n    // Create a relation for target relation by calling Schema::createRel()\n\n    // if the createRel returns an error code, then return that value.\n\n    // Open the newly created target relation by calling OpenRelTable::openRel()\n    // and get the target relid\n\n    // If opening fails, delete the target relation by calling Schema::deleteRel()\n    // and return the error value from openRel()\n\n\n    /*** Inserting projected records into the target relation ***/\n\n    // Take care to reset the searchIndex before calling the project function\n    // using RelCacheTable::resetSearchIndex()\n\n    Attribute record[src_nAttrs];\n\n    while (/* BlockAccess::project(srcRelId, record) returns SUCCESS */) {\n        // the variable `record` will contain the next record\n\n        Attribute proj_record[tar_nAttrs];\n\n        //iterate through 0 to tar_attrs-1:\n        //    proj_record[attr_iter] = record[attr_offset[attr_iter]]\n\n        // ret = BlockAccess::insert(targetRelId, proj_record);\n\n        if (/* insert fails */) {\n            // close the targetrel by calling Schema::closeRel()\n            // delete targetrel by calling Schema::deleteRel()\n            // return ret;\n        }\n    }\n\n    // Close the targetRel by calling Schema::closeRel()\n\n    // return SUCCESS.\n}\n\n\nint Algebra::project(char srcRel[ATTR_SIZE], char targetRel[ATTR_SIZE]) {\n\n    int srcRelId = /*srcRel's rel-id (use OpenRelTable::getRelId() function)*/\n\n    // if srcRel is not open in open relation table, return E_RELNOTOPEN\n\n    // get RelCatEntry of srcRel using RelCacheTable::getRelCatEntry()\n\n    // get the no. of attributes present in relation from the fetched RelCatEntry.\n\n    // attrNames and attrTypes will be used to store the attribute names\n    // and types of the source relation respectively\n    char attrNames[numAttrs][ATTR_SIZE];\n    int attrTypes[numAttrs];\n\n    /*iterate through every attribute of the source relation :\n        - get the AttributeCat entry of the attribute with offset.\n          (using AttrCacheTable::getAttrCatEntry())\n        - fill the arrays `attrNames` and `attrTypes` that we declared earlier\n          with the data about each attribute\n    */\n\n\n    /*** Creating and opening the target relation ***/\n\n    // Create a relation for target relation by calling Schema::createRel()\n\n    // if the createRel returns an error code, then return that value.\n\n    // Open the newly created target relation by calling OpenRelTable::openRel()\n    // and get the target relid\n\n    // If opening fails, delete the target relation by calling Schema::deleteRel() of\n    // return the error value returned from openRel().\n\n\n    /*** Inserting projected records into the target relation ***/\n\n    // Take care to reset the searchIndex before calling the project function\n    // using RelCacheTable::resetSearchIndex()\n\n    Attribute record[numAttrs];\n\n\n    while (/* BlockAccess::project(srcRelId, record) returns SUCCESS */)\n    {\n        // record will contain the next record\n\n        // ret = BlockAccess::insert(targetRelId, proj_record);\n\n        if (/* insert fails */) {\n            // close the targetrel by calling Schema::closeRel()\n            // delete targetrel by calling Schema::deleteRel()\n            // return ret;\n        }\n    }\n\n    // Close the targetRel by calling Schema::closeRel()\n\n    // return SUCCESS.\n}\n\n\nint join(char srcRelation1[ATTR_SIZE], char srcRelation2[ATTR_SIZE], char targetRelation[ATTR_SIZE], char attribute1[ATTR_SIZE], char attribute2[ATTR_SIZE]) {\n\n    // get the srcRelation1's rel-id using OpenRelTable::getRelId() method\n\n    // get the srcRelation2's rel-id using OpenRelTable::getRelId() method\n\n    // if either of the two source relations is not open\n    //     return E_RELNOTOPEN\n\n    AttrCatEntry attrCatEntry1, attrCatEntry2;\n    // get the attribute catalog entries for the following from the attribute cache\n    // (using AttrCacheTable::getAttrCatEntry())\n    // - attrCatEntry1 = attribute1 of srcRelation1\n    // - attrCatEntry2 = attribute2 of srcRelation2\n\n    // if attribute1 is not present in srcRelation1 or attribute2 is not\n    // present in srcRelation2 (getAttrCatEntry() returned E_ATTRNOTEXIST)\n    //     return E_ATTRNOTEXIST.\n\n    // if attribute1 and attribute2 are of different types return E_ATTRTYPEMISMATCH\n\n    // iterate through all the attributes in both the source relations and check if\n    // there are any other pair of attributes other than join attributes\n    // (i.e. attribute1 and attribute2) with duplicate names in srcRelation1 and\n    // srcRelation2 (use AttrCacheTable::getAttrCatEntry())\n    // If yes, return E_DUPLICATEATTR\n\n    // get the relation catalog entries for the relations from the relation cache\n    // (use RelCacheTable::getRelCatEntry() function)\n\n    int numOfAttributes1 = /* number of attributes in srcRelation1 */;\n    int numOfAttributes2 = /* number of attributes in srcRelation2 */;\n\n    // if rel2 does not have an index on attr2\n    //     create it using BPlusTree:bPlusCreate()\n    //     if call fails, return the appropriate error code\n    //     (if your implementation is correct, the only error code that will\n    //      be returned here is E_DISKFULL)\n\n    int numOfAttributesInTarget = numOfAttributes1 + numOfAttributes2 - 1;\n    // Note: The target relation has number of attributes one less than\n    // nAttrs1+nAttrs2 (Why?)\n\n    // declare the following arrays to store the details of the target relation\n    char targetRelAttrNames[numOfAttributesInTarget][ATTR_SIZE];\n    int targetRelAttrTypes[numOfAttributesInTarget];\n\n    // iterate through all the attributes in both the source relations and\n    // update targetRelAttrNames[],targetRelAttrTypes[] arrays excluding attribute2\n    // in srcRelation2 (use AttrCacheTable::getAttrCatEntry())\n\n    // create the target relation using the Schema::createRel() function\n\n    // if createRel() returns an error, return that error\n\n    // Open the targetRelation using OpenRelTable::openRel()\n\n    // if openRel() fails (No free entries left in the Open Relation Table)\n    {\n        // delete target relation by calling Schema::deleteRel()\n        // return the error code\n    }\n\n    Attribute record1[numOfAttributes1];\n    Attribute record2[numOfAttributes2];\n    Attribute targetRecord[numOfAttributesInTarget];\n\n    // this loop is to get every record of the srcRelation1 one by one\n    while (BlockAccess::project(srcRelId1, record1) == SUCCESS) {\n\n        // reset the search index of `srcRelation2` in the relation cache\n        // using RelCacheTable::resetSearchIndex()\n\n        // reset the search index of `attribute2` in the attribute cache\n        // using AttrCacheTable::resetSearchIndex()\n\n        // this loop is to get every record of the srcRelation2 which satisfies\n        //the following condition:\n        // record1.attribute1 = record2.attribute2 (i.e. Equi-Join condition)\n        while (BlockAccess::search(\n            srcRelId2, record2, attribute2, record1[attrCatEntry1.offset], EQ\n        ) == SUCCESS ) {\n\n            // copy srcRelation1's and srcRelation2's attribute values(except\n            // for attribute2 in rel2) from record1 and record2 to targetRecord\n\n            // insert the current record into the target relation by calling\n            // BlockAccess::insert()\n\n            if(/* insert fails (insert should fail only due to DISK being FULL) */) {\n\n                // close the target relation by calling OpenRelTable::closeRel()\n                // delete targetRelation (by calling Schema::deleteRel())\n                return E_DISKFULL;\n            }\n        }\n    }\n\n    // close the target relation by calling OpenRelTable::closeRel()\n    return SUCCESS;\n}\n")))}u.isMDXComponent=!0}}]);