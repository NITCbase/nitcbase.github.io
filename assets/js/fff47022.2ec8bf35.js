"use strict";(self.webpackChunknitcbase=self.webpackChunknitcbase||[]).push([[7451],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>m});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},l=Object.keys(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var d=a.createContext({}),s=function(e){var t=a.useContext(d),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=s(e.components);return a.createElement(d.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,l=e.originalType,d=e.parentName,u=o(e,["components","mdxType","originalType","parentName"]),c=s(n),m=r,k=c["".concat(d,".").concat(m)]||c[m]||p[m]||l;return n?a.createElement(k,i(i({ref:t},u),{},{components:n})):a.createElement(k,i({ref:t},u))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var l=n.length,i=new Array(l);i[0]=c;var o={};for(var d in t)hasOwnProperty.call(t,d)&&(o[d]=t[d]);o.originalType=e,o.mdxType="string"==typeof e?e:r,i[1]=o;for(var s=2;s<l;s++)i[s]=n[s];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},8421:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>i,default:()=>p,frontMatter:()=>l,metadata:()=>o,toc:()=>s});var a=n(7462),r=(n(7294),n(3905));const l={title:"classes IndBuffer, IndInternal, IndLeaf",sidebar_position:4},i=void 0,o={unversionedId:"Design/Buffer Layer/IndBuffer",id:"Design/Buffer Layer/IndBuffer",title:"classes IndBuffer, IndInternal, IndLeaf",description:"class IndBuffer",source:"@site/docs/Design/Buffer Layer/IndBuffer.md",sourceDirName:"Design/Buffer Layer",slug:"/Design/Buffer Layer/IndBuffer",permalink:"/docs/Design/Buffer Layer/IndBuffer",draft:!1,tags:[],version:"current",sidebarPosition:4,frontMatter:{title:"classes IndBuffer, IndInternal, IndLeaf",sidebar_position:4},sidebar:"Design",previous:{title:"class RecBuffer",permalink:"/docs/Design/Buffer Layer/RecBuffer"},next:{title:"Physical Layer",permalink:"/docs/Design/Physical Layer"}},d={},s=[{value:"class IndBuffer",id:"class-indbuffer",level:2},{value:"IndBuffer :: IndBuffer() (Constructor 1)",id:"indbuffer--indbuffer-constructor-1",level:3},{value:"Description",id:"description",level:4},{value:"Arguments",id:"arguments",level:4},{value:"Return Values",id:"return-values",level:4},{value:"Algorithm",id:"algorithm",level:4},{value:"IndBuffer :: IndBuffer() (Constructor 2)",id:"indbuffer--indbuffer-constructor-2",level:3},{value:"Description",id:"description-1",level:4},{value:"Arguments",id:"arguments-1",level:4},{value:"Return Values",id:"return-values-1",level:4},{value:"Algorithm",id:"algorithm-1",level:4},{value:"class IndInternal",id:"class-indinternal",level:2},{value:"IndInternal :: IndInternal() (Constructor1)",id:"indinternal--indinternal-constructor1",level:3},{value:"Description",id:"description-2",level:4},{value:"Arguments",id:"arguments-2",level:4},{value:"Return Values",id:"return-values-2",level:4},{value:"IndInternal :: IndInternal() (Constructor2)",id:"indinternal--indinternal-constructor2",level:3},{value:"Description",id:"description-3",level:4},{value:"Arguments",id:"arguments-3",level:4},{value:"Return Values",id:"return-values-3",level:4},{value:"IndInternal :: getEntry()",id:"indinternal--getentry",level:3},{value:"Description",id:"description-4",level:4},{value:"Arguments",id:"arguments-4",level:4},{value:"Return Values",id:"return-values-4",level:4},{value:"Algorithm",id:"algorithm-2",level:4},{value:"IndInternal :: setEntry()",id:"indinternal--setentry",level:3},{value:"Description",id:"description-5",level:4},{value:"Arguments",id:"arguments-5",level:4},{value:"Return Values",id:"return-values-5",level:4},{value:"Algorithm",id:"algorithm-3",level:4},{value:"class IndLeaf",id:"class-indleaf",level:2},{value:"IndLeaf :: IndLeaf() (Constructor 1)",id:"indleaf--indleaf-constructor-1",level:3},{value:"Description",id:"description-6",level:4},{value:"Arguments",id:"arguments-6",level:4},{value:"Return Values",id:"return-values-6",level:4},{value:"Algorithm",id:"algorithm-4",level:4},{value:"IndLeaf :: IndLeaf() (Constructor 2)",id:"indleaf--indleaf-constructor-2",level:3},{value:"Description",id:"description-7",level:4},{value:"Arguments",id:"arguments-7",level:4},{value:"Return Values",id:"return-values-7",level:4},{value:"Algorithm",id:"algorithm-5",level:4},{value:"IndLeaf :: getEntry()",id:"indleaf--getentry",level:3},{value:"Description",id:"description-8",level:4},{value:"Arguments",id:"arguments-8",level:4},{value:"Return Values",id:"return-values-8",level:4},{value:"Algorithm",id:"algorithm-6",level:4},{value:"IndLeaf :: setEntry()",id:"indleaf--setentry",level:3},{value:"Description",id:"description-9",level:4},{value:"Arguments",id:"arguments-9",level:4},{value:"Return Values",id:"return-values-9",level:4},{value:"Algorithm",id:"algorithm-7",level:4}],u={toc:s};function p(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h2",{id:"class-indbuffer"},"class IndBuffer"),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"IndBuffer")," class is a generic class for representing an ",(0,r.kt)("em",{parentName:"p"},"Index")," block. ",(0,r.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/B%2B_tree"},"B+ Trees")," are constructed using ",(0,r.kt)("em",{parentName:"p"},"Index")," blocks which can be either ",(0,r.kt)("a",{parentName:"p",href:"../../Design/Physical%20Layer#internal-index-block-structure"},"Index Internal blocks")," or ",(0,r.kt)("a",{parentName:"p",href:"../../Design/Physical%20Layer#leaf-index-block-structure"},"Index Leaf blocks"),". B+ Tree helps in faster data access as compared to sequentially accessing the data through ",(0,r.kt)("a",{parentName:"p",href:"../../Design/Physical%20Layer#record-block-structure"},"Record")," blocks."),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"IndBuffer")," class extends the ",(0,r.kt)("a",{parentName:"p",href:"#class-blockbuffer"},"BlockBuffer")," class. Thus, all its protected fields and methods can be accessed by ",(0,r.kt)("em",{parentName:"p"},"IndBuffer")," class. In addition to these, ",(0,r.kt)("em",{parentName:"p"},"IndBuffer")," class has two ",(0,r.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Virtual_function#Abstract_classes_and_pure_virtual_functions"},"pure virtual methods"),"- ",(0,r.kt)("inlineCode",{parentName:"p"},"getEntry()")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"setEntry()"),". These methods take an argument of type ",(0,r.kt)("inlineCode",{parentName:"p"},"void *")," so that arguments of both ",(0,r.kt)("a",{parentName:"p",href:"#internalentry"},(0,r.kt)("inlineCode",{parentName:"a"},"struct InternalEntry"))," and ",(0,r.kt)("a",{parentName:"p",href:"#index"},(0,r.kt)("inlineCode",{parentName:"a"},"struct Index"))," type can be passed to it. This is based on the fact that a ",(0,r.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Void_type"},"void pointer")," can hold address of any type and can be typcasted to any type."),(0,r.kt)("p",null,"The children classes, ",(0,r.kt)("a",{parentName:"p",href:"#class-indinternal"},"IndInternal")," and ",(0,r.kt)("a",{parentName:"p",href:"#class-indleaf"},"IndLeaf"),", extend the class IndBuffer and override the virtual functions. The constructors of ",(0,r.kt)("em",{parentName:"p"},"IndBuffer")," class simply calls the constructor of the parent class with the received argument."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"class IndBuffer : public BlockBuffer {\n\npublic:\n    //methods\n    IndBuffer(char blockType);\n    IndBuffer(int blockNum);\n    virtual int getEntry(void *ptr, int indexNum) = 0;\n    virtual int setEntry(void *ptr, int indexNum) = 0;\n\n};\n")),(0,r.kt)("p",null,"The following are the specifications for the methods in class IndBuffer."),(0,r.kt)("h3",{id:"indbuffer--indbuffer-constructor-1"},"IndBuffer :: IndBuffer() (Constructor 1)"),(0,r.kt)("h4",{id:"description"},"Description"),(0,r.kt)("p",null,"Called if a new index block of the input type is to be allocated in the disk."),(0,r.kt)("h4",{id:"arguments"},"Arguments"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Name")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Type")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Description")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"I"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"char")),(0,r.kt)("td",{parentName:"tr",align:null},"New block of ",(0,r.kt)("a",{parentName:"td",href:"/constants"},(0,r.kt)("inlineCode",{parentName:"a"},"IND_INTERNAL"))," type to be alloted.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"L"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"char")),(0,r.kt)("td",{parentName:"tr",align:null},"New block of ",(0,r.kt)("a",{parentName:"td",href:"/constants"},(0,r.kt)("inlineCode",{parentName:"a"},"IND_LEAF "))," type to be alloted.")))),(0,r.kt)("h4",{id:"return-values"},"Return Values"),(0,r.kt)("p",null,"Nil"),(0,r.kt)("h4",{id:"algorithm"},"Algorithm"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"// this is the way to call parent non-default constructor.\nIndBuffer::IndBuffer(char blockType) : BlockBuffer(blockType){}\n\n")),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"If the block has already been initialised as an index block on the disk, use ",(0,r.kt)("a",{parentName:"p",href:"#indbuffer-constructor-2"},"constructor 2"),".")),(0,r.kt)("h3",{id:"indbuffer--indbuffer-constructor-2"},"IndBuffer :: IndBuffer() (Constructor 2)"),(0,r.kt)("h4",{id:"description-1"},"Description"),(0,r.kt)("p",null,"Called when the block has already been initialised as an index block on the disk."),(0,r.kt)("h4",{id:"arguments-1"},"Arguments"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Name")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Type")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Description")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"blockNum"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"int")),(0,r.kt)("td",{parentName:"tr",align:null},"Block number of the index block.")))),(0,r.kt)("h4",{id:"return-values-1"},"Return Values"),(0,r.kt)("p",null,"Nil"),(0,r.kt)("h4",{id:"algorithm-1"},"Algorithm"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"// this is a way to call parent non-default constructor.\nIndBuffer::IndBuffer(int blockNum) : BlockBuffer(blockNum){}\n")),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"If a new index block is to be allocated in the disk use ",(0,r.kt)("a",{parentName:"p",href:"#indbuffer-constructor-1"},"constructor 1"),".")),(0,r.kt)("h2",{id:"class-indinternal"},"class IndInternal"),(0,r.kt)("p",null,"An object of the ",(0,r.kt)("inlineCode",{parentName:"p"},"class IndInternal")," is associated with an ",(0,r.kt)("strong",{parentName:"p"},"Internal Index block"),". An Internal Index block stores entries of type ",(0,r.kt)("inlineCode",{parentName:"p"},"struct InternalEntry")," and is used as the ",(0,r.kt)("strong",{parentName:"p"},"internal nodes of a B+ Tree"),". Public methods of this class deal with the access/modification of the InternalEntry entries. ",(0,r.kt)("inlineCode",{parentName:"p"},"IndInternal class")," extends ",(0,r.kt)("inlineCode",{parentName:"p"},"IndBuffer class")," and overrides its virtual methods. The constructor of the IndInternal class calls the constructor of the parent class by passing suitable argument."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"class IndInternal : public IndBuffer {\n\npublic:\n    //methods\n    IndInternal();\n    IndInternal(int blockNum);\n    int getEntry(void *ptr, int indexNum);\n    int setEntry(void *ptr, int indexNum);\n\n};\n")),(0,r.kt)("p",null,"The following are the specifications for the methods in ",(0,r.kt)("inlineCode",{parentName:"p"},"class IndInternal"),"."),(0,r.kt)("h3",{id:"indinternal--indinternal-constructor1"},"IndInternal :: IndInternal() (Constructor1)"),(0,r.kt)("h4",{id:"description-2"},"Description"),(0,r.kt)("p",null,"Called if a new internal index block is to be allocated in the disk."),(0,r.kt)("h4",{id:"arguments-2"},"Arguments"),(0,r.kt)("p",null,"Nil"),(0,r.kt)("h4",{id:"return-values-2"},"Return Values"),(0,r.kt)("p",null,"Nil"),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"If the block has already been initialised as an internal index block on the disk, use ",(0,r.kt)("a",{parentName:"p",href:"#indinternal--indinternal-constructor2"},"constructor 2"),".")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"IndInternal::IndInternal() : IndBuffer('I'){}\n//this is the way to call parent non-default constructor.\n// 'I' used to denote IndInternal.\n")),(0,r.kt)("h3",{id:"indinternal--indinternal-constructor2"},"IndInternal :: IndInternal() (Constructor2)"),(0,r.kt)("h4",{id:"description-3"},"Description"),(0,r.kt)("p",null,"Called when the block has already been initialised as an internal index block on the disk."),(0,r.kt)("h4",{id:"arguments-3"},"Arguments"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Name")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Type")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Description")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"blockNum"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"int")),(0,r.kt)("td",{parentName:"tr",align:null},"Block number of the internal index block.")))),(0,r.kt)("h4",{id:"return-values-3"},"Return Values"),(0,r.kt)("p",null,"Nil"),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"If a new internal index block is to be allocated in the disk use ",(0,r.kt)("a",{parentName:"p",href:"#indinternal--indinternal-constructor1"},"constructor 1"),".")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"IndInternal::IndInternal(int blockNum) : IndBuffer(blockNum){}\n//this is the way to call parent non-default constructor.\n")),(0,r.kt)("h3",{id:"indinternal--getentry"},"IndInternal :: getEntry()"),(0,r.kt)("h4",{id:"description-4"},"Description"),(0,r.kt)("p",null,"Gives the indexNumth entry of the block."),(0,r.kt)("h4",{id:"arguments-4"},"Arguments"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Name")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Type")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Description")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"ptr"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"void *")),(0,r.kt)("td",{parentName:"tr",align:null},"Pointer to the struct InternalEntry to which the specified internal index entry of the block is copied.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"indexNum"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"int")),(0,r.kt)("td",{parentName:"tr",align:null},"Index number of the entry in the block.")))),(0,r.kt)("h4",{id:"return-values-4"},"Return Values"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Value")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Description")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/constants"},(0,r.kt)("inlineCode",{parentName:"a"},"SUCCESS"))),(0,r.kt)("td",{parentName:"tr",align:null},"Successful copy of the internal index entry.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/constants"},(0,r.kt)("inlineCode",{parentName:"a"},"E_OUTOFBOUND"))),(0,r.kt)("td",{parentName:"tr",align:null},"Input indexNum is outside the valid range of index numbers of the block.")))),(0,r.kt)("admonition",{title:"note",type:"caution"},(0,r.kt)("ul",{parentName:"admonition"},(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("inlineCode",{parentName:"li"},"void")," pointer is a generic pointer that can be pointed at objects of any data type. However, because the ",(0,r.kt)("inlineCode",{parentName:"li"},"void")," pointer does not know what type of object it is pointing to, it must first be explicitly cast to another pointer type before it is dereferenced."),(0,r.kt)("li",{parentName:"ul"},"The higher layers calling the ",(0,r.kt)("inlineCode",{parentName:"li"},"getEntry()")," function of the ",(0,r.kt)("inlineCode",{parentName:"li"},"IndInternal class")," must ensure that the argument of type ",(0,r.kt)("inlineCode",{parentName:"li"},"struct InternalEntry *")," is passed."),(0,r.kt)("li",{parentName:"ul"},"The higher layers must allocate memory for the ",(0,r.kt)("inlineCode",{parentName:"li"},"struct InternalEntry")," before calling this function."),(0,r.kt)("li",{parentName:"ul"},"The alignment of the ",(0,r.kt)("inlineCode",{parentName:"li"},"InternalEntry")," structure in memory ",(0,r.kt)("a",{parentName:"li",href:"https://en.wikipedia.org/wiki/Data_structure_alignment#Data_structure_padding"},"might be different")," from the way it is organized in our disk. Make sure to copy each element of the structure separately with appropriate offset. Using ",(0,r.kt)("inlineCode",{parentName:"li"},"memcpy")," on the whole object can lead to errors."))),(0,r.kt)("h4",{id:"algorithm-2"},"Algorithm"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"int IndInternal::getEntry(void *ptr, int indexNum) {\n    unsigned char *bufferPtr;\n    /* get the starting address of the buffer containing the block\n       using loadBlockAndGetBufferPtr(&bufferPtr). */\n\n    // if loadBlockAndGetBufferPtr(&bufferPtr) != SUCCESS\n        // return the value returned by the call.\n\n    // if the indexNum is not in the valid range of 0-(MAX_KEYS_INTERNAL-1)\n    //     return E_OUTOFBOUND.\n\n    // copy the indexNum'th Internalentry in block to memory ptr\n    // (ptr can be type casted appropriately if needed).\n\n    // return SUCCESS.\n}\n")),(0,r.kt)("h3",{id:"indinternal--setentry"},"IndInternal :: setEntry()"),(0,r.kt)("h4",{id:"description-5"},"Description"),(0,r.kt)("p",null,"Sets the indexNumth entry of the block with the input struct InternalEntry contents."),(0,r.kt)("h4",{id:"arguments-5"},"Arguments"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Name")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Type")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Description")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"ptr"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"void *")),(0,r.kt)("td",{parentName:"tr",align:null},"Pointer to the struct InternalEntry from which the specified internal index entry of the block is set.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"indexNum"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"int")),(0,r.kt)("td",{parentName:"tr",align:null},"Index number of the entry in the block.")))),(0,r.kt)("h4",{id:"return-values-5"},"Return Values"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Value")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Description")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/constants"},(0,r.kt)("inlineCode",{parentName:"a"},"SUCCESS"))),(0,r.kt)("td",{parentName:"tr",align:null},"Successful copy of the internal index entry.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/constants"},(0,r.kt)("inlineCode",{parentName:"a"},"E_OUTOFBOUND"))),(0,r.kt)("td",{parentName:"tr",align:null},"Input indexNum is outside the valid range of index numbers of the block.")))),(0,r.kt)("admonition",{title:"note",type:"caution"},(0,r.kt)("ul",{parentName:"admonition"},(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("inlineCode",{parentName:"li"},"void")," pointer is a generic pointer that can be pointed at objects of any data type. However, because the ",(0,r.kt)("inlineCode",{parentName:"li"},"void")," pointer does not know what type of object it is pointing to, it must first be explicitly cast to another pointer type before it is dereferenced."),(0,r.kt)("li",{parentName:"ul"},"The higher layers calling the ",(0,r.kt)("inlineCode",{parentName:"li"},"setEntry()")," method of the ",(0,r.kt)("inlineCode",{parentName:"li"},"IndInternal class")," must ensure that the argument of type ",(0,r.kt)("inlineCode",{parentName:"li"},"struct InternalEntry *")," is passed."),(0,r.kt)("li",{parentName:"ul"},"The higher layers must allocate memory for the ",(0,r.kt)("inlineCode",{parentName:"li"},"struct InternalEntry")," before calling this function."),(0,r.kt)("li",{parentName:"ul"},"The alignment of the ",(0,r.kt)("inlineCode",{parentName:"li"},"InternalEntry")," structure in memory might be different from the way it is organized in our disk. Make sure to copy each element of the structure separately with appropriate offset. Using ",(0,r.kt)("inlineCode",{parentName:"li"},"memcpy")," on the whole object can lead to errors."))),(0,r.kt)("h4",{id:"algorithm-3"},"Algorithm"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"int IndInternal::setEntry(void *ptr, int indexNum) {\n    unsigned char *bufferPtr;\n    // get the starting address of the buffer containing the block using loadBlockAndGetBufferPtr(&bufferPtr).\n\n    // if loadBlockAndGetBufferPtr(&bufferPtr) != SUCCESS\n        // return the value returned by the call.\n\n    // if the indexNum is not in the valid range of 0-(MAX_KEYS_INTERNAL-1), return E_OUTOFBOUND.\n\n    // copy the struct InternalEntry pointed by ptr to indexNum'th entry in block.\n\n    // update dirty bit.\n    // if setDirtyBit failed, return the value returned by the call\n\n    // return SUCCESS\n}\n")),(0,r.kt)("h2",{id:"class-indleaf"},"class IndLeaf"),(0,r.kt)("p",null,"An object of the ",(0,r.kt)("em",{parentName:"p"},"IndLeaf")," class will be associated with a ",(0,r.kt)("a",{parentName:"p",href:"../../Design/Physical%20Layer#leaf-index-block-structure"},"Index Leaf blocks"),". A Leaf Index block stores entries of type ",(0,r.kt)("inlineCode",{parentName:"p"},"struct Index")," and is used as the leaf nodes of a B+ Tree. Public methods of this class deal with the access/modification of the ",(0,r.kt)("em",{parentName:"p"},"Index")," entries. ","*",(0,r.kt)("em",{parentName:"p"},"IndLeaf")," class extends ",(0,r.kt)("a",{parentName:"p",href:"#class-indbuffer"},"IndBuffer class")," and overrides its virtual methods. The constructor of the IndLeaf class calls the constructor of the parent class by passing suitable argument."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"class IndLeaf : public IndBuffer{\n\npublic:\n    //methods\n    IndLeaf();\n    IndLeaf(int blockNum);\n    int getEntry(void *ptr, int indexNum) ;\n    int setEntry(void *ptr, int indexNum) ;\n\n};\n")),(0,r.kt)("p",null,"The following are the specifications for the methods in class IndLeaf."),(0,r.kt)("h3",{id:"indleaf--indleaf-constructor-1"},"IndLeaf :: IndLeaf() (Constructor 1)"),(0,r.kt)("h4",{id:"description-6"},"Description"),(0,r.kt)("p",null,"Called if a new leaf index block is to be allocated in the disk."),(0,r.kt)("h4",{id:"arguments-6"},"Arguments"),(0,r.kt)("p",null,"Nil"),(0,r.kt)("h4",{id:"return-values-6"},"Return Values"),(0,r.kt)("p",null,"Nil"),(0,r.kt)("h4",{id:"algorithm-4"},"Algorithm"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"IndLeaf::IndLeaf() : IndBuffer('L'){} // this is the way to call parent non-default constructor.\n                      // 'L' used to denote IndLeaf.\n\n")),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"If the block has already been initialised as a leaf index block on the disk, use ",(0,r.kt)("a",{parentName:"p",href:"#indleaf-constructor-2"},"constructor 2"),".")),(0,r.kt)("h3",{id:"indleaf--indleaf-constructor-2"},"IndLeaf :: IndLeaf() (Constructor 2)"),(0,r.kt)("h4",{id:"description-7"},"Description"),(0,r.kt)("p",null,"Called when the block has already been initialised as a leaf index block on the disk."),(0,r.kt)("h4",{id:"arguments-7"},"Arguments"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Name")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Type")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Description")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"blockNum"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"int")),(0,r.kt)("td",{parentName:"tr",align:null},"Block number of the leaf index block.")))),(0,r.kt)("h4",{id:"return-values-7"},"Return Values"),(0,r.kt)("p",null,"Nil"),(0,r.kt)("h4",{id:"algorithm-5"},"Algorithm"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"//this is the way to call parent non-default constructor.\nIndLeaf::IndLeaf(int blockNum) : IndBuffer(blockNum){}\n")),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"If a new leaf index block is to be allocated in the disk use ",(0,r.kt)("a",{parentName:"p",href:"#indleaf-constructor-1"},"constructor 1"),".")),(0,r.kt)("h3",{id:"indleaf--getentry"},"IndLeaf :: getEntry()"),(0,r.kt)("h4",{id:"description-8"},"Description"),(0,r.kt)("p",null,"Gives the indexNum",(0,r.kt)("sup",null,"th")," entry of the block."),(0,r.kt)("h4",{id:"arguments-8"},"Arguments"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Name")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Type")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Description")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"ptr"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"void *")),(0,r.kt)("td",{parentName:"tr",align:null},"Pointer to the ",(0,r.kt)("a",{parentName:"td",href:"#index"},"struct Index")," to which the specified leaf index entry of the block is copied.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"indexNum"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"int")),(0,r.kt)("td",{parentName:"tr",align:null},"Index number of the entry in the block.")))),(0,r.kt)("h4",{id:"return-values-8"},"Return Values"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Value")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Description")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/constants"},(0,r.kt)("inlineCode",{parentName:"a"},"SUCCESS"))),(0,r.kt)("td",{parentName:"tr",align:null},"Successful getting of the leaf index entry.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/constants"},(0,r.kt)("inlineCode",{parentName:"a"},"E_OUTOFBOUND"))),(0,r.kt)("td",{parentName:"tr",align:null},"Input ",(0,r.kt)("inlineCode",{parentName:"td"},"indexNum")," is outside the valid range of index numbers of the block.")))),(0,r.kt)("admonition",{title:"note",type:"caution"},(0,r.kt)("ul",{parentName:"admonition"},(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("a",{parentName:"li",href:"https://en.wikipedia.org/wiki/Void_type"},"void pointer")," is a generic pointer that can be pointed at objects of any data type. However, because the void pointer does not know what type of object it is pointing to, the void pointer must first be explicitly cast to another pointer type before it is dereferenced."),(0,r.kt)("li",{parentName:"ul"},"The higher layers calling the ",(0,r.kt)("inlineCode",{parentName:"li"},"getEntry()")," function of the ",(0,r.kt)("em",{parentName:"li"},"IndLeaf")," class must ensure that the argument of type ",(0,r.kt)("inlineCode",{parentName:"li"},"struct Index *")," is passed."),(0,r.kt)("li",{parentName:"ul"},"The higher layers must allocate memory for the ",(0,r.kt)("inlineCode",{parentName:"li"},"struct Index")," before calling this function."),(0,r.kt)("li",{parentName:"ul"},"The alignment of the ",(0,r.kt)("inlineCode",{parentName:"li"},"Index")," structure in memory might be different from the way it is organized in our disk. Make sure to copy each element of the structure separately with appropriate offset. Using ",(0,r.kt)("inlineCode",{parentName:"li"},"memcpy")," on the whole object can lead to errors."))),(0,r.kt)("h4",{id:"algorithm-6"},"Algorithm"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"int IndLeaf::getEntry(void *ptr, int indexNum) {\n    unsigned char *bufferPtr;\n    // get the starting address of the buffer containing the block using loadBlockAndGetBufferPtr(&bufferPtr).\n\n    // if loadBlockAndGetBufferPtr(&bufferPtr) != SUCCESS\n        // return the value returned by the call.\n\n    // if the indexNum is not in the valid range of 0-(MAX_KEYS_LEAF-1), return E_OUTOFBOUND.\n\n    // copy the indexNum'th Index entry in block to memory ptr(ptr can be type casted appropriately if needed).\n\n    // return SUCCESS.\n}\n")),(0,r.kt)("h3",{id:"indleaf--setentry"},"IndLeaf :: setEntry()"),(0,r.kt)("h4",{id:"description-9"},"Description"),(0,r.kt)("p",null,"Sets the indexNum",(0,r.kt)("sup",null,"th")," entry of the block with the input struct Index contents."),(0,r.kt)("h4",{id:"arguments-9"},"Arguments"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Name")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Type")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Description")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"ptr"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"void *")),(0,r.kt)("td",{parentName:"tr",align:null},"Pointer to the ",(0,r.kt)("a",{parentName:"td",href:"#index"},"struct Index")," to which the specified leaf index entry of the block is copied.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"indexNum"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"int")),(0,r.kt)("td",{parentName:"tr",align:null},"Index number of the entry in the block.")))),(0,r.kt)("h4",{id:"return-values-9"},"Return Values"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Value")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Description")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/constants"},(0,r.kt)("inlineCode",{parentName:"a"},"SUCCESS"))),(0,r.kt)("td",{parentName:"tr",align:null},"Successful setting of the leaf index entry.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/constants"},(0,r.kt)("inlineCode",{parentName:"a"},"E_OUTOFBOUND"))),(0,r.kt)("td",{parentName:"tr",align:null},"Input ",(0,r.kt)("inlineCode",{parentName:"td"},"indexNum")," is outside the valid range of index numbers of the block.")))),(0,r.kt)("admonition",{title:"note",type:"caution"},(0,r.kt)("ul",{parentName:"admonition"},(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("a",{parentName:"li",href:"https://en.wikipedia.org/wiki/Void_type"},"void pointer")," is a generic pointer that can be pointed at objects of any data type. However, because the void pointer does not know what type of object it is pointing to, the void pointer must first be explicitly cast to another pointer type before it is dereferenced."),(0,r.kt)("li",{parentName:"ul"},"The higher layers calling the ",(0,r.kt)("inlineCode",{parentName:"li"},"setEntry()")," function of the IndLeaf class must ensure that the argument of type ",(0,r.kt)("inlineCode",{parentName:"li"},"struct Index *")," is passed."),(0,r.kt)("li",{parentName:"ul"},"The higher layers must allocate memory for the struct Index before calling this function."),(0,r.kt)("li",{parentName:"ul"},"The alignment of the ",(0,r.kt)("inlineCode",{parentName:"li"},"Index")," structure in memory might be different from the way it is organized in our disk. Make sure to copy each element of the structure separately with appropriate offset. Using ",(0,r.kt)("inlineCode",{parentName:"li"},"memcpy")," on the whole object can lead to errors."))),(0,r.kt)("h4",{id:"algorithm-7"},"Algorithm"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"int IndLeaf::setEntry(void *ptr, int indexNum) {\n    unsigned char *bufferPtr;\n    // get the starting address of the buffer containing the block using loadBlockAndGetBufferPtr(&bufferPtr).\n\n    // if loadBlockAndGetBufferPtr(&bufferPtr) != SUCCESS\n            // return the value returned by the call.\n\n    // if the indexNum is not in the valid range of 0-(MAX_KEYS_LEAF-1), return E_OUTOFBOUND.\n\n    // copy the struct Index pointed by ptr to indexNum'th entry in block.\n\n    // update dirty bit.\n    // if setDirtyBit failed, return the value returned by the call\n\n    //return SUCCESS\n}\n")))}p.isMDXComponent=!0}}]);