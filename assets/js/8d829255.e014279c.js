"use strict";(self.webpackChunknitcbase=self.webpackChunknitcbase||[]).push([[7091],{3905:(t,e,n)=>{n.d(e,{Zo:()=>u,kt:()=>p});var a=n(7294);function r(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}function l(t,e){var n=Object.keys(t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(t);e&&(a=a.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),n.push.apply(n,a)}return n}function i(t){for(var e=1;e<arguments.length;e++){var n=null!=arguments[e]?arguments[e]:{};e%2?l(Object(n),!0).forEach((function(e){r(t,e,n[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(n,e))}))}return t}function o(t,e){if(null==t)return{};var n,a,r=function(t,e){if(null==t)return{};var n,a,r={},l=Object.keys(t);for(a=0;a<l.length;a++)n=l[a],e.indexOf(n)>=0||(r[n]=t[n]);return r}(t,e);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(t);for(a=0;a<l.length;a++)n=l[a],e.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(t,n)&&(r[n]=t[n])}return r}var s=a.createContext({}),d=function(t){var e=a.useContext(s),n=e;return t&&(n="function"==typeof t?t(e):i(i({},e),t)),n},u=function(t){var e=d(t.components);return a.createElement(s.Provider,{value:e},t.children)},h={inlineCode:"code",wrapper:function(t){var e=t.children;return a.createElement(a.Fragment,{},e)}},c=a.forwardRef((function(t,e){var n=t.components,r=t.mdxType,l=t.originalType,s=t.parentName,u=o(t,["components","mdxType","originalType","parentName"]),c=d(n),p=r,k=c["".concat(s,".").concat(p)]||c[p]||h[p]||l;return n?a.createElement(k,i(i({ref:e},u),{},{components:n})):a.createElement(k,i({ref:e},u))}));function p(t,e){var n=arguments,r=e&&e.mdxType;if("string"==typeof t||r){var l=n.length,i=new Array(l);i[0]=c;var o={};for(var s in e)hasOwnProperty.call(e,s)&&(o[s]=e[s]);o.originalType=t,o.mdxType="string"==typeof t?t:r,i[1]=o;for(var d=2;d<l;d++)i[d]=n[d];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},5832:(t,e,n)=>{n.r(e),n.d(e,{assets:()=>s,contentTitle:()=>i,default:()=>h,frontMatter:()=>l,metadata:()=>o,toc:()=>d});var a=n(7462),r=(n(7294),n(3905));const l={sidebar_position:6,title:"B+ Tree Layer"},i=void 0,o={unversionedId:"Design/B+ Tree Layer",id:"Design/B+ Tree Layer",title:"B+ Tree Layer",description:"- B+ Trees",source:"@site/docs/Design/B+ Tree Layer.md",sourceDirName:"Design",slug:"/Design/B+ Tree Layer",permalink:"/docs/Design/B+ Tree Layer",draft:!1,tags:[],version:"current",sidebarPosition:6,frontMatter:{sidebar_position:6,title:"B+ Tree Layer"},sidebar:"Design",previous:{title:"Block Access Layer",permalink:"/docs/Design/Block Access Layer"},next:{title:"Introduction",permalink:"/docs/Design/Cache Layer/intro"}},s={},d=[{value:"Layout",id:"layout",level:2},{value:"class BPlusTree",id:"class-bplustree",level:2},{value:"BPlusTree::bPlusCreate",id:"bplustreebpluscreate",level:3},{value:"Description",id:"description",level:4},{value:"Arguments",id:"arguments",level:4},{value:"Return values",id:"return-values",level:4},{value:"Algorithm",id:"algorithm",level:4},{value:"BPlusTree::bPlusSearch",id:"bplustreebplussearch",level:3},{value:"Description",id:"description-1",level:4},{value:"Arguments",id:"arguments-1",level:4},{value:"Return values",id:"return-values-1",level:4},{value:"Algorithm",id:"algorithm-1",level:4},{value:"BPlusTree::bPlusDestroy",id:"bplustreebplusdestroy",level:3},{value:"Description",id:"description-2",level:4},{value:"Arguments",id:"arguments-2",level:4},{value:"Return values",id:"return-values-2",level:4},{value:"Algorithm",id:"algorithm-2",level:4},{value:"BPlusTree::bPlusInsert",id:"bplustreebplusinsert",level:3},{value:"Description",id:"description-3",level:4},{value:"Arguments",id:"arguments-3",level:4},{value:"Return values",id:"return-values-3",level:4},{value:"Algorithm",id:"algorithm-3",level:4},{value:"BPlusTree::findLeafToInsert",id:"bplustreefindleaftoinsert",level:3},{value:"Description",id:"description-4",level:4},{value:"Arguments",id:"arguments-4",level:4},{value:"Return values",id:"return-values-4",level:4},{value:"Algorithm",id:"algorithm-4",level:4},{value:"BPlusTree::insertIntoLeaf",id:"bplustreeinsertintoleaf",level:3},{value:"Description",id:"description-5",level:4},{value:"Arguments",id:"arguments-5",level:4},{value:"Return values",id:"return-values-5",level:4},{value:"Algorithm",id:"algorithm-5",level:4},{value:"BPlusTree::splitLeaf",id:"bplustreesplitleaf",level:3},{value:"Description",id:"description-6",level:4},{value:"Arguments",id:"arguments-6",level:4},{value:"Return values",id:"return-values-6",level:4},{value:"Algorithm",id:"algorithm-6",level:4},{value:"BPlusTree::insertIntoInternal",id:"bplustreeinsertintointernal",level:3},{value:"Description",id:"description-7",level:4},{value:"Arguments",id:"arguments-7",level:4},{value:"Return values",id:"return-values-7",level:4},{value:"Algorithm",id:"algorithm-7",level:4},{value:"BPlusTree::splitInternal",id:"bplustreesplitinternal",level:3},{value:"Description",id:"description-8",level:4},{value:"Arguments",id:"arguments-8",level:4},{value:"Return values",id:"return-values-8",level:4},{value:"Algorithm",id:"algorithm-8",level:4},{value:"BPlusTree::createNewRoot",id:"bplustreecreatenewroot",level:3},{value:"Description",id:"description-9",level:4},{value:"Arguments",id:"arguments-9",level:4},{value:"Return values",id:"return-values-9",level:4},{value:"Algorithm",id:"algorithm-9",level:4}],u={toc:d};function h(t){let{components:e,...n}=t;return(0,r.kt)("wrapper",(0,a.Z)({},u,n,{components:e,mdxType:"MDXLayout"}),(0,r.kt)("admonition",{title:"PREREQUISITE READING",type:"caution"},(0,r.kt)("ul",{parentName:"admonition"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/docs/Misc/B+%20Trees"},"B+ Trees")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/docs/Misc/Indexing"},"Indexing in NITCbase")))),(0,r.kt)("admonition",{title:"note",type:"info"},(0,r.kt)("p",{parentName:"admonition"},"The files corresponding to this layer can be found in the ",(0,r.kt)("inlineCode",{parentName:"p"},"BPlusTree")," directory. The code is to be written in the file ",(0,r.kt)("inlineCode",{parentName:"p"},"BPlusTree.cpp"),". The declaration for the functions can be found in the header file ",(0,r.kt)("inlineCode",{parentName:"p"},"BPlusTree.h"),"."),(0,r.kt)("p",{parentName:"admonition"},(0,r.kt)("a",{parentName:"p",href:"/docs/Misc/stub/bplus"},(0,r.kt)("strong",{parentName:"a"},"The stub code for this layer can be found here.")))),(0,r.kt)("h2",{id:"layout"},"Layout"),(0,r.kt)("p",null,"Indexing is used to quickly locate and access the data in a database. It reduces the number of disk accesses needed when a search query is processed. NITCbase uses B+ Trees for the purpose of indexing an attribute in a relation. The B+ Tree Layer provides specifications for the creation/ usage of B+ Trees."),(0,r.kt)("p",null,"For each internal entry in the B+ tree, the attribute values in the left child are smaller or equal to, and the attribute values in the right child are larger than the attribute value of its parent. This property allows systematic traversal of the B+ Tree. ",(0,r.kt)("br",null),"\nThe leaf entries are ordered in ascending order of attribute values. The Leaf Index blocks are also connected as a linked list. This allows easy access to an entry in the next Leaf Index block rather than traversing the entire B+ Tree from the root to reach that entry."),(0,r.kt)("p",null,"NITCbase follows Object Oriented design for implementing B+ Tree. The class diagram is as shown below."),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"class-bplustree"},"class BPlusTree"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"class BPlusTree {\n private:\n  static int findLeafToInsert(int rootBlock, Attribute attrVal, int attrType);\n  static int insertIntoLeaf(int relId, char attrName[ATTR_SIZE], int blockNum, Index entry);\n  static int splitLeaf(int leafBlockNum, Index indices[]);\n  static int insertIntoInternal(int relId, char attrName[ATTR_SIZE], int intBlockNum, InternalEntry entry);\n  static int splitInternal(int intBlockNum, InternalEntry internalEntries[]);\n  static int createNewRoot(int relId, char attrName[ATTR_SIZE], Attribute attrVal, int lChild, int rChild);\n\n public:\n  static int bPlusCreate(int relId, char attrName[ATTR_SIZE]);\n  static int bPlusInsert(int relId, char attrName[ATTR_SIZE], union Attribute attrVal, RecId recordId);\n  static RecId bPlusSearch(int relId, char attrName[ATTR_SIZE], union Attribute attrVal, int op);\n  static int bPlusDestroy(int rootBlockNum);\n};\n\n")),(0,r.kt)("h3",{id:"bplustreebpluscreate"},"BPlusTree::bPlusCreate"),(0,r.kt)("h4",{id:"description"},"Description"),(0,r.kt)("p",null,"This method creates a B+ Tree (Indexing) for the input attribute of the specified relation. It inserts the attribute value corresponding to attrName of all entries in the relation into the B+Tree using ",(0,r.kt)("a",{parentName:"p",href:"#bplusinsert"},"bPlusInsert()"),".",(0,r.kt)("br",null),"\nIf in between the insertion, the disk runs out of space, then the B+ Tree will not be created."),(0,r.kt)("h4",{id:"arguments"},"Arguments"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Name")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Type")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Description")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"relId"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"int")),(0,r.kt)("td",{parentName:"tr",align:null},"Relation Id of the relation whose attribute a B+ tree is to be created for.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"attrName"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"char[ATTR_SIZE]")),(0,r.kt)("td",{parentName:"tr",align:null},"Attribute/column name for which B+ tree (index) is to be created.")))),(0,r.kt)("h4",{id:"return-values"},"Return values"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Value")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Description")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/docs/constants"},(0,r.kt)("inlineCode",{parentName:"a"},"SUCCESS"))),(0,r.kt)("td",{parentName:"tr",align:null},"On successful creation of a B+ tree for the attribute")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/docs/constants"},(0,r.kt)("inlineCode",{parentName:"a"},"E_OUTOFBOUND"))),(0,r.kt)("td",{parentName:"tr",align:null},"Input relId is outside the valid set of possible relation ids")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/docs/constants"},(0,r.kt)("inlineCode",{parentName:"a"},"E_RELNOTOPEN"))),(0,r.kt)("td",{parentName:"tr",align:null},"If the relation is not open")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/docs/constants"},(0,r.kt)("inlineCode",{parentName:"a"},"E_ATTRNOTEXIST"))),(0,r.kt)("td",{parentName:"tr",align:null},"If attribute with name attrName does not exist")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/docs/constants"},(0,r.kt)("inlineCode",{parentName:"a"},"E_DISKFULL"))),(0,r.kt)("td",{parentName:"tr",align:null},"If disk space is not sufficient for creating the index")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/docs/constants"},(0,r.kt)("inlineCode",{parentName:"a"},"E_NOTPERMITTED"))),(0,r.kt)("td",{parentName:"tr",align:null},"If an index is being created for the catalog relations. The catalog relations are only linear searched and hence should not be indexed")))),(0,r.kt)("h4",{id:"algorithm"},"Algorithm"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"int BPlusTree::bPlusCreate(int relId, char attrName[ATTR_SIZE]) {\n\n    // if relId is either RELCAT_RELID or ATTRCAT_RELID:\n    //     return E_NOTPERMITTED;\n\n\n    // get the attribute catalog entry of attribute `attrName`\n    // using AttrCacheTable::getAttrCatEntry()\n\n    // if getAttrCatEntry fails\n    //     return the error code from getAttrCatEntry\n\n    if (/* an index already exists for the attribute (check rootBlock field) */) {\n        return SUCCESS;\n    }\n\n    /******Creating a new B+ Tree ******/\n\n    // get a free leaf block using constructor 1 to allocate a new block\n    IndLeaf rootBlockBuf;\n\n    // (if the block could not be allocated, the appropriate error code\n    //  will be stored in the blockNum member field of the object)\n\n    // declare rootBlock to store the blockNumber of the new leaf block\n    int rootBlock = rootBlockBuf.getBlockNum();\n\n    // if there is no more disk space for creating an index\n    if (rootBlock == E_DISKFULL) {\n        return E_DISKFULL;\n    }\n\n    RelCatEntry relCatEntry;\n\n    // load the relation catalog entry into relCatEntry\n    // using RelCacheTable::getRelCatEntry().\n\n    int block = /* first record block of the relation */;\n\n    /***** Traverse all the blocks in the relation and insert them one\n           by one into the B+ Tree *****/\n    while (block != -1) {\n\n        // declare a RecBuffer object for `block` (using appropriate constructor)\n\n        unsigned char slotMap[relCatEntry.numSlotsPerBlk];\n\n        // load the slot map into slotMap using RecBuffer::getSlotMap().\n\n        // for every occupied slot of the block\n        {\n            Attribute record[relCatEntry.numAttrs];\n            // load the record corresponding to the slot into `record`\n            // using RecBuffer::getRecord().\n\n            // declare recId and store the rec-id of this record in it\n            // RecId recId{block, slot};\n\n            // insert the attribute value corresponding to attrName from the record\n            // into the B+ tree using bPlusInsert.\n            // (note that bPlusInsert will destroy any existing bplus tree if\n            // insert fails i.e when disk is full)\n            // retVal = bPlusInsert(relId, attrName, attribute value, recId);\n\n            // if (retVal == E_DISKFULL) {\n            //     // (unable to get enough blocks to build the B+ Tree.)\n            //     return E_DISKFULL;\n            // }\n        }\n\n        // get the header of the block using BlockBuffer::getHeader()\n\n        // set block = rblock of current block (from the header)\n    }\n\n    return SUCCESS;\n}\n")),(0,r.kt)("hr",null),(0,r.kt)("h3",{id:"bplustreebplussearch"},"BPlusTree::bPlusSearch"),(0,r.kt)("h4",{id:"description-1"},"Description"),(0,r.kt)("p",null,"This method searches the relation specified using a B+ tree to find the next record that satisfies the specified condition. The condition value is given by the argument ",(0,r.kt)("inlineCode",{parentName:"p"},"attrVal"),". This function returns the recId of the next record satisfying the condition. The condition that is checked for is the following."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"value-in-record `op` attrVal\n")),(0,r.kt)("admonition",{title:"note",type:"info"},(0,r.kt)("ul",{parentName:"admonition"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},'This function reads the "next" record from the given relation that satisfies a given condition. The search index of the attribute (stored in the ',(0,r.kt)("a",{parentName:"p",href:"/docs/Design/Cache%20Layer/AttrCacheTable"},"AttrCacheTable")," entry of the relation) is used to identify the location of the previous record that was returned. This function reads the next record and updates the value of the search index to the position of the newly read record, before passing the record to the caller.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"If ",(0,r.kt)("inlineCode",{parentName:"p"},"searchIndex")," was reset to ",(0,r.kt)("inlineCode",{parentName:"p"},"{-1,-1}")," before the call, this function starts reading from the beginning and returns the first record of the relation that satisfies the condition. The ",(0,r.kt)("inlineCode",{parentName:"p"},"AttrCacheTable::resetSearchIndex()")," function may be used to reset the value of the search index.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"If the ",(0,r.kt)("inlineCode",{parentName:"p"},"searchIndex")," value of a relation corresponds to the last record of the relation that satisfies the condition, this function will return ",(0,r.kt)("inlineCode",{parentName:"p"},"{-1, -1}"),', as there is no "next" record to be read.')),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"If ",(0,r.kt)("inlineCode",{parentName:"p"},"searchIndex")," has reached the last record of the relation, it is the responsibility of the caller to reset the search index if it is required that the function starts reading from the beginning of the relation again. If not done, every subsequent call to this function will return ",(0,r.kt)("inlineCode",{parentName:"p"},"{-1, -1}"),".")))),(0,r.kt)("h4",{id:"arguments-1"},"Arguments"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Name")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Type")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Description")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"relId"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"int")),(0,r.kt)("td",{parentName:"tr",align:null},"Relation Id of the relation containing the attribute with index.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"attrName"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"char[ATTR_SIZE]")),(0,r.kt)("td",{parentName:"tr",align:null},"Attribute/column name (which has an index) to which condition need to be checked with.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"attrVal"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"union Attribute")),(0,r.kt)("td",{parentName:"tr",align:null},"value of attribute that has to be checked against the operater.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"op"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"int")),(0,r.kt)("td",{parentName:"tr",align:null},"Conditional Operator (can be one among ",(0,r.kt)("inlineCode",{parentName:"td"},"EQ")," , ",(0,r.kt)("inlineCode",{parentName:"td"},"LE")," , ",(0,r.kt)("inlineCode",{parentName:"td"},"LT")," , ",(0,r.kt)("inlineCode",{parentName:"td"},"GE")," , ",(0,r.kt)("inlineCode",{parentName:"td"},"GT")," , ",(0,r.kt)("inlineCode",{parentName:"td"},"NE")," corresponding to equal, less or than equal, less than ,greater than or equal, greater than, not equal operators respectively).")))),(0,r.kt)("h4",{id:"return-values-1"},"Return values"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Value")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Description")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"{block#, index#}")),(0,r.kt)("td",{parentName:"tr",align:null},"returns the ",(0,r.kt)("em",{parentName:"td"},"block number and slot number")," of the record corresponding to the next hit. This corresponds to type ",(0,r.kt)("inlineCode",{parentName:"td"},"RecId"),".")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"{-1, -1}")),(0,r.kt)("td",{parentName:"tr",align:null},"If no valid next hit is found or if a B+ tree does not exist for the attribute. This corresponds to type ",(0,r.kt)("inlineCode",{parentName:"td"},"RecId"),".")))),(0,r.kt)("h4",{id:"algorithm-1"},"Algorithm"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"RecId BPlusTree::bPlusSearch(int relId, char attrName[ATTR_SIZE], Attribute attrVal, int op) {\n    // declare searchIndex which will be used to store search index for attrName.\n    IndexId searchIndex;\n\n    /* get the search index corresponding to attribute with name attrName\n       using AttrCacheTable::getSearchIndex(). */\n\n    AttrCatEntry attrCatEntry;\n    /* load the attribute cache entry into attrCatEntry using\n     AttrCacheTable::getAttrCatEntry(). */\n\n    // declare variables block and index which will be used during search\n    int block, index;\n\n    if (/* searchIndex == {-1, -1}*/) {\n        // (search is done for the first time)\n\n        // start the search from the first entry of root.\n        block = attrCatEntry.rootBlock;\n        index = 0;\n\n        if (/* attrName doesn't have a B+ tree (block == -1)*/) {\n            return RecId{-1, -1};\n        }\n\n    } else {\n        /*a valid searchIndex points to an entry in the leaf index of the attribute's\n        B+ Tree which had previously satisfied the op for the given attrVal.*/\n\n        block = searchIndex.block;\n        index = searchIndex.index + 1;  // search is resumed from the next index.\n\n        // load block into leaf using IndLeaf::IndLeaf().\n        IndLeaf leaf(block);\n\n        // declare leafHead which will be used to hold the header of leaf.\n        HeadInfo leafHead;\n\n        // load header into leafHead using BlockBuffer::getHeader().\n\n        if (index >= leafHead.numEntries) {\n            /* (all the entries in the block has been searched; search from the\n            beginning of the next leaf index block. */\n\n            // update block to rblock of current block and index to 0.\n\n            if (block == -1) {\n                // (end of linked list reached - the search is done.)\n                return RecId{-1, -1};\n            }\n        }\n    }\n\n    /******  Traverse through all the internal nodes according to value\n             of attrVal and the operator op                             ******/\n\n    /* (This section is only needed when\n        - search restarts from the root block (when searchIndex is reset by caller)\n        - root is not a leaf\n        If there was a valid search index, then we are already at a leaf block\n        and the test condition in the following loop will fail)\n    */\n\n    while(/* block is of type IND_INTERNAL */) {  //use StaticBuffer::getStaticBlockType()\n\n        // load the block into internalBlk using IndInternal::IndInternal().\n        IndInternal internalBlk(block);\n\n        HeadInfo intHead;\n\n        // load the header of internalBlk into intHead using BlockBuffer::getHeader()\n\n        // declare intEntry which will be used to store an entry of internalBlk.\n        InternalEntry intEntry;\n\n        if (/* op is one of NE, LT, LE */) {\n            /*\n            - NE: need to search the entire linked list of leaf indices of the B+ Tree,\n            starting from the leftmost leaf index. Thus, always move to the left.\n\n            - LT and LE: the attribute values are arranged in ascending order in the\n            leaf indices of the B+ Tree. Values that satisfy these conditions, if\n            any exist, will always be found in the left-most leaf index. Thus,\n            always move to the left.\n            */\n\n            // load entry in the first slot of the block into intEntry\n            // using IndInternal::getEntry().\n\n            block = intEntry.lChild;\n\n        } else {\n            /*\n            - EQ, GT and GE: move to the left child of the first entry that is\n            greater than (or equal to) attrVal\n            (we are trying to find the first entry that satisfies the condition.\n            since the values are in ascending order we move to the left child which\n            might contain more entries that satisfy the condition)\n            */\n\n            /*\n             traverse through all entries of internalBlk and find an entry that\n             satisfies the condition.\n             if op == EQ or GE, then intEntry.attrVal >= attrVal\n             if op == GT, then intEntry.attrVal > attrVal\n             Hint: the helper function compareAttrs() can be used for comparing\n            */\n\n            if (/* such an entry is found*/) {\n                // move to the left child of that entry\n                block =  // left child of the entry\n\n            } else {\n                // move to the right child of the last entry of the block\n                // i.e numEntries - 1 th entry of the block\n\n                block =  // right child of last entry\n            }\n        }\n    }\n\n    // NOTE: `block` now has the block number of a leaf index block.\n\n    /******  Identify the first leaf index entry from the current position\n                that satisfies our condition (moving right)             ******/\n\n    while (block != -1) {\n        // load the block into leafBlk using IndLeaf::IndLeaf().\n        IndLeaf leafBlk(block);\n        HeadInfo leafHead;\n\n        // load the header to leafHead using BlockBuffer::getHeader().\n\n        // declare leafEntry which will be used to store an entry from leafBlk\n        Index leafEntry;\n\n        //highlight-start\n        while (/*index < numEntries in leafBlk*/) {\n\n            // load entry corresponding to block and index into leafEntry\n            // using IndLeaf::getEntry().\n\n            int cmpVal = /* comparison between leafEntry's attribute value\n                            and input attrVal using compareAttrs()*/\n\n            if (\n                (op == EQ && cmpVal == 0) ||\n                (op == LE && cmpVal <= 0) ||\n                (op == LT && cmpVal < 0) ||\n                (op == GT && cmpVal > 0) ||\n                (op == GE && cmpVal >= 0) ||\n                (op == NE && cmpVal != 0)\n            ) {\n                // (entry satisfying the condition found)\n\n                // set search index to {block, index}\n\n                // return the recId {leafEntry.block, leafEntry.slot}.\n\n            } else if ((op == EQ || op == LE || op == LT) && cmpVal > 0) {\n                /*future entries will not satisfy EQ, LE, LT since the values\n                    are arranged in ascending order in the leaves */\n\n                // return RecId {-1, -1};\n            }\n\n            // search next index.\n            ++index;\n        }\n        //highlight-end\n\n        /*only for NE operation do we have to check the entire linked list;\n        for all the other op it is guaranteed that the block being searched\n        will have an entry, if it exists, satisying that op. */\n        if (op != NE) {\n            break;\n        }\n\n        // block = next block in the linked list, i.e., the rblock in leafHead.\n        // update index to 0.\n    }\n\n    // no entry satisying the op was found; return the recId {-1,-1}\n}\n")),(0,r.kt)("hr",null),(0,r.kt)("h3",{id:"bplustreebplusdestroy"},"BPlusTree::bPlusDestroy"),(0,r.kt)("h4",{id:"description-2"},"Description"),(0,r.kt)("p",null,"Used to delete a B+ Tree rooted at a particular block passed as input to the method. The method recursively deletes the constituent index blocks, both internal and leaf index blocks, until the full B+ Tree is deleted."),(0,r.kt)("p",null,"This function is called when"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"the user issues the ",(0,r.kt)("inlineCode",{parentName:"li"},"DROP INDEX")," command"),(0,r.kt)("li",{parentName:"ul"},"in a situation where no further disk blocks can be allotted during the creation of/insertion to a B+ Tree"),(0,r.kt)("li",{parentName:"ul"},"while deleting an entire relation in NITCbase.")),(0,r.kt)("admonition",{title:"NOTE",type:"info"},(0,r.kt)("p",{parentName:"admonition"},"The caller is responsible for updating the rootBlock field in the corresponding attribute catalog after deletion.")),(0,r.kt)("h4",{id:"arguments-2"},"Arguments"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Name")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Type")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Description")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"rootBlockNum"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"int")),(0,r.kt)("td",{parentName:"tr",align:null},"block number of the root of the B+ tree to be destroyed")))),(0,r.kt)("h4",{id:"return-values-2"},"Return values"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Value")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Description")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/docs/constants"},(0,r.kt)("inlineCode",{parentName:"a"},"SUCCESS"))),(0,r.kt)("td",{parentName:"tr",align:null},"On successful deletion of the B+ tree rooted at rootBlockNum")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/docs/constants"},(0,r.kt)("inlineCode",{parentName:"a"},"E_OUTOFBOUND"))),(0,r.kt)("td",{parentName:"tr",align:null},"if ",(0,r.kt)("inlineCode",{parentName:"td"},"rootBlockNum")," is outside the valid range of block numbers")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/docs/constants"},(0,r.kt)("inlineCode",{parentName:"a"},"E_INVALIDBLOCK"))),(0,r.kt)("td",{parentName:"tr",align:null},"if ",(0,r.kt)("inlineCode",{parentName:"td"},"rootBlockNum")," does not correspond to an index block")))),(0,r.kt)("h4",{id:"algorithm-2"},"Algorithm"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"int BPlusTree::bPlusDestroy(int rootBlockNum) {\n    if (/*rootBlockNum lies outside the valid range [0,DISK_BLOCKS-1]*/) {\n        return E_OUTOFBOUND;\n    }\n\n    int type = /* type of block (using StaticBuffer::getStaticBlockType())*/;\n\n    if (type == IND_LEAF) {\n        // declare an instance of IndLeaf for rootBlockNum using appropriate\n        // constructor\n\n        // release the block using BlockBuffer::releaseBlock().\n\n        return SUCCESS;\n\n    } else if (type == IND_INTERNAL) {\n        // declare an instance of IndInternal for rootBlockNum using appropriate\n        // constructor\n\n        // load the header of the block using BlockBuffer::getHeader().\n\n        /*iterate through all the entries of the internalBlk and destroy the lChild\n        of the first entry and rChild of all entries using BPlusTree::bPlusDestroy().\n        (the rchild of an entry is the same as the lchild of the next entry.\n         take care not to delete overlapping children more than once ) */\n\n        // release the block using BlockBuffer::releaseBlock().\n\n        return SUCCESS;\n\n    } else {\n        // (block is not an index block.)\n        return E_INVALIDBLOCK;\n    }\n}\n")),(0,r.kt)("hr",null),(0,r.kt)("h3",{id:"bplustreebplusinsert"},"BPlusTree::bPlusInsert"),(0,r.kt)("h4",{id:"description-3"},"Description"),(0,r.kt)("p",null,"Inserts an attribute value and the rec-id of the corresponding record into a B+ tree index on the disk"),(0,r.kt)("admonition",{title:"NOTE",type:"info"},(0,r.kt)("p",{parentName:"admonition"},"During insertion of an entry to a valid B+ Tree, the disk may run out of memory. In such a case, the existing B+ Tree will be destroyed and the attribute catalog entry for the attribute will have rootBlock set to -1. Any operation on the B+ Tree must ensure that the object instance has a valid rootBlock.")),(0,r.kt)("h4",{id:"arguments-3"},"Arguments"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Name")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Type")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Description")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"relId"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"int")),(0,r.kt)("td",{parentName:"tr",align:null},"Relation Id of the relation containing the attribute.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"attrName"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"char[ATTR_SIZE]")),(0,r.kt)("td",{parentName:"tr",align:null},"Attribute/column name to whose B+ tree (index) an entry is to be added")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"attrVal"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"union Attribute")),(0,r.kt)("td",{parentName:"tr",align:null},"Attribute value corresponding to attrName in the target record.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"recId"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"struct RecId")),(0,r.kt)("td",{parentName:"tr",align:null},"The record id of record to which attrVal belongs.")))),(0,r.kt)("h4",{id:"return-values-3"},"Return values"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Value")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Description")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/docs/constants"},(0,r.kt)("inlineCode",{parentName:"a"},"SUCCESS"))),(0,r.kt)("td",{parentName:"tr",align:null},"On successful insertion into the B+ tree of the attribute")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/docs/constants"},(0,r.kt)("inlineCode",{parentName:"a"},"E_RELNOTOPEN"))),(0,r.kt)("td",{parentName:"tr",align:null},"If the relation is not open")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/docs/constants"},(0,r.kt)("inlineCode",{parentName:"a"},"E_OUTOFBOUND"))),(0,r.kt)("td",{parentName:"tr",align:null},"Input relId is outside the valid set of possible relation ids")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/docs/constants"},(0,r.kt)("inlineCode",{parentName:"a"},"E_ATTRNOTEXIST"))),(0,r.kt)("td",{parentName:"tr",align:null},"If attribute with name attrName does not exist")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/docs/constants"},(0,r.kt)("inlineCode",{parentName:"a"},"E_NOINDEX"))),(0,r.kt)("td",{parentName:"tr",align:null},"Attribute ",(0,r.kt)("inlineCode",{parentName:"td"},"attrName")," does not have an index")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/docs/constants"},(0,r.kt)("inlineCode",{parentName:"a"},"E_DISKFULL"))),(0,r.kt)("td",{parentName:"tr",align:null},"If disk space is not sufficient for insertion into the B+ tree")))),(0,r.kt)("admonition",{type:"caution"},(0,r.kt)("p",{parentName:"admonition"},"The caller is expected to ensure that"),(0,r.kt)("ul",{parentName:"admonition"},(0,r.kt)("li",{parentName:"ul"},"the ",(0,r.kt)("inlineCode",{parentName:"li"},"RecId")," passed belongs to a valid record in the same relation"),(0,r.kt)("li",{parentName:"ul"},"a duplicate index entry for this record does not already exist in the B+ tree."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"recId")," actually points to the specific record that the argument attribute value belongs to")),(0,r.kt)("p",{parentName:"admonition"},"This function will add the pair ",(0,r.kt)("inlineCode",{parentName:"p"},"(attrVal, recId)")," to the B+ tree ",(0,r.kt)("strong",{parentName:"p"},"without any validation")," on these arguments.")),(0,r.kt)("h4",{id:"algorithm-3"},"Algorithm"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"int BPlusTree::bPlusInsert(int relId, char attrName[ATTR_SIZE], Attribute attrVal, RecId recId) {\n    // get the attribute cache entry corresponding to attrName\n    // using AttrCacheTable::getAttrCatEntry().\n\n    // if getAttrCatEntry() failed\n    //     return the error code\n\n    int blockNum = /* rootBlock of B+ Tree (from attrCatEntry) */;\n\n    if (/* there is no index on attribute (rootBlock is -1) */) {\n        return E_NOINDEX;\n    }\n\n    // find the leaf block to which insertion is to be done using the\n    // findLeafToInsert() function\n\n    int leafBlkNum = /* findLeafToInsert(root block num, attrVal, attribute type) */;\n\n    // insert the attrVal and recId to the leaf block at blockNum using the\n    // insertIntoLeaf() function.\n    // declare a struct Index with attrVal = attrVal, block = recId.block and\n    // slot = recId.slot to pass as argument to the function.\n    // insertIntoLeaf(relId, attrName, leafBlkNum, Index entry)\n    // NOTE: the insertIntoLeaf() function will propagate the insertion to the\n    //       required internal nodes by calling the required helper functions\n    //       like insertIntoInternal() or createNewRoot()\n\n    if (/*insertIntoLeaf() returns E_DISKFULL */) {\n        // destroy the existing B+ tree by passing the rootBlock to bPlusDestroy().\n\n        // update the rootBlock of attribute catalog cache entry to -1 using\n        // AttrCacheTable::setAttrCatEntry().\n\n        return E_DISKFULL;\n    }\n\n    return SUCCESS;\n}\n")),(0,r.kt)("h3",{id:"bplustreefindleaftoinsert"},"BPlusTree::findLeafToInsert"),(0,r.kt)("h4",{id:"description-4"},"Description"),(0,r.kt)("p",null,"Used to find the leaf index block to which an attribute would be inserted to in the B+ insertion process. If this leaf turns out to be full, the caller will need to handle the splitting of this block to insert the entry."),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"According to the NITCbase specification, this function will only be called from ",(0,r.kt)("a",{parentName:"p",href:"#bplustreebplusinsert"},"bPlusInsert()"),".")),(0,r.kt)("admonition",{type:"caution"},(0,r.kt)("p",{parentName:"admonition"},"This function does not do any validation. It is the responsibility of the the caller to verify that"),(0,r.kt)("ul",{parentName:"admonition"},(0,r.kt)("li",{parentName:"ul"},"the argument passed is the block number of root block of a B+ tree on the disk"),(0,r.kt)("li",{parentName:"ul"},"the attribute type that is present in the index matches the attribute type that is passed"))),(0,r.kt)("h4",{id:"arguments-4"},"Arguments"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Name")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Type")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Description")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"rootBlock"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"int")),(0,r.kt)("td",{parentName:"tr",align:null},"The root block of a B+ tree on the disk")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"attrVal"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"struct Attribute")),(0,r.kt)("td",{parentName:"tr",align:null},"The attrVal for which the appropriate leaf node is to be found")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"attrType"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"int")),(0,r.kt)("td",{parentName:"tr",align:null},"The type of the attribute ",(0,r.kt)("inlineCode",{parentName:"td"},"attrVal"),", that is, ",(0,r.kt)("a",{parentName:"td",href:"/docs/constants"},(0,r.kt)("inlineCode",{parentName:"a"},"NUMBER"),"/",(0,r.kt)("inlineCode",{parentName:"a"},"STRING")))))),(0,r.kt)("h4",{id:"return-values-4"},"Return values"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Value")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Description")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"leafBlkNum"),(0,r.kt)("td",{parentName:"tr",align:null},"The block number of the leaf block to which insertion can be done")))),(0,r.kt)("h4",{id:"algorithm-4"},"Algorithm"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"int BPlusTree::findLeafToInsert(int rootBlock, Attribute attrVal, int attrType) {\n    int blockNum = rootBlock;\n\n    while (/*block is not of type IND_LEAF */) {  // use StaticBuffer::getStaticBlockType()\n\n        // declare an IndInternal object for block using appropriate constructor\n\n        // get header of the block using BlockBuffer::getHeader()\n\n        /* iterate through all the entries, to find the first entry whose\n             attribute value >= value to be inserted.\n             NOTE: the helper function compareAttrs() declared in BlockBuffer.h\n                   can be used to compare two Attribute values. */\n\n        if (/*no such entry is found*/) {\n            // set blockNum = rChild of (nEntries-1)'th entry of the block\n            // (i.e. rightmost child of the block)\n\n        } else {\n            // set blockNum = lChild of the entry that was found\n        }\n    }\n\n    return blockNum;\n}\n")),(0,r.kt)("h3",{id:"bplustreeinsertintoleaf"},"BPlusTree::insertIntoLeaf"),(0,r.kt)("h4",{id:"description-5"},"Description"),(0,r.kt)("p",null,"Used to insert an index entry into a leaf index block of an existing B+ tree. If the leaf is full and requires splitting, this function will call other B+ Tree Layer functions to handle any updation required to the parent internal index blocks of the B+ tree."),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"According to the NITCbase specification, this function will only be called from ",(0,r.kt)("a",{parentName:"p",href:"#bplustreebplusinsert"},"bPlusInsert()"),".")),(0,r.kt)("h4",{id:"arguments-5"},"Arguments"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Name")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Type")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Description")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"relId"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"int")),(0,r.kt)("td",{parentName:"tr",align:null},"Relation Id of the relation containing the attribute.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"attrName"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"char[ATTR_SIZE]")),(0,r.kt)("td",{parentName:"tr",align:null},"Attribute/column name of the relation with given rel-id to whose B+ tree (index) an entry is to be added")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"blockNum"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"int")),(0,r.kt)("td",{parentName:"tr",align:null},"The block number of the leaf index block to which an entry is to be inserted")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"indexEntry"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"struct Index")),(0,r.kt)("td",{parentName:"tr",align:null},"The entry that is to be inserted into the leaf index block")))),(0,r.kt)("h4",{id:"return-values-5"},"Return values"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Value")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Description")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/docs/constants"},(0,r.kt)("inlineCode",{parentName:"a"},"SUCCESS"))),(0,r.kt)("td",{parentName:"tr",align:null},"On successful insertion into the B+ tree of the attribute")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/docs/constants"},(0,r.kt)("inlineCode",{parentName:"a"},"E_DISKFULL"))),(0,r.kt)("td",{parentName:"tr",align:null},"If disk space is not sufficient for insertion into the B+ tree")))),(0,r.kt)("admonition",{type:"caution"},(0,r.kt)("p",{parentName:"admonition"},"The caller is expected to ensure that"),(0,r.kt)("ul",{parentName:"admonition"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"blockNum")," corresponds to a valid leaf index block in the B+ tree corresponding to ",(0,r.kt)("inlineCode",{parentName:"li"},"attrName")," of the relation with specified rel-id."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"indexEntry")," contains the correct ",(0,r.kt)("inlineCode",{parentName:"li"},"recId")," and ",(0,r.kt)("inlineCode",{parentName:"li"},"attrVal")," corresponding to the record that is to be inserted")),(0,r.kt)("p",{parentName:"admonition"},"This function will insert ",(0,r.kt)("inlineCode",{parentName:"p"},"indexEntry")," to the B+ tree ",(0,r.kt)("strong",{parentName:"p"},"without any validation")," on the arguments.")),(0,r.kt)("h4",{id:"algorithm-5"},"Algorithm"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"int BPlusTree::insertIntoLeaf(int relId, char attrName[ATTR_SIZE], int blockNum, Index indexEntry) {\n    // get the attribute cache entry corresponding to attrName\n    // using AttrCacheTable::getAttrCatEntry().\n\n    // declare an IndLeaf instance for the block using appropriate constructor\n\n    HeadInfo blockHeader;\n    // store the header of the leaf index block into blockHeader\n    // using BlockBuffer::getHeader()\n\n    // the following variable will be used to store a list of index entries with\n    // existing indices + the new index to insert\n    Index indices[blockHeader.numEntries + 1];\n\n    /*\n    Iterate through all the entries in the block and copy them to the array indices.\n    Also insert `indexEntry` at appropriate position in the indices array maintaining\n    the ascending order.\n    - use IndLeaf::getEntry() to get the entry\n    - use compareAttrs() declared in BlockBuffer.h to compare two Attribute structs\n    */\n\n    if (blockHeader.numEntries != MAX_KEYS_LEAF) {\n        // (leaf block has not reached max limit)\n\n        // increment blockHeader.numEntries and update the header of block\n        // using BlockBuffer::setHeader().\n\n        // iterate through all the entries of the array `indices` and populate the\n        // entries of block with them using IndLeaf::setEntry().\n\n        return SUCCESS;\n    }\n\n    // If we reached here, the `indices` array has more than entries than can fit\n    // in a single leaf index block. Therefore, we will need to split the entries\n    // in `indices` between two leaf blocks. We do this using the splitLeaf() function.\n    // This function will return the blockNum of the newly allocated block or\n    // E_DISKFULL if there are no more blocks to be allocated.\n\n    int newRightBlk = splitLeaf(blockNum, indices);\n\n    // if splitLeaf() returned E_DISKFULL\n    //     return E_DISKFULL\n\n    if (/* the current leaf block was not the root */) {  // check pblock in header\n        // insert the middle value from `indices` into the parent block using the\n        // insertIntoInternal() function. (i.e the last value of the left block)\n\n        // the middle value will be at index 31 (given by constant MIDDLE_INDEX_LEAF)\n\n        // create a struct InternalEntry with attrVal = indices[MIDDLE_INDEX_LEAF].attrVal,\n        // lChild = currentBlock, rChild = newRightBlk and pass it as argument to\n        // the insertIntoInternalFunction as follows\n\n\n        // insertIntoInternal(relId, attrName, parent of current block, new internal entry)\n\n    } else {\n        // the current block was the root block and is now split. a new internal index\n        // block needs to be allocated and made the root of the tree.\n        // To do this, call the createNewRoot() function with the following arguments\n\n        // createNewRoot(relId, attrName, indices[MIDDLE_INDEX_LEAF].attrVal,\n        //               current block, new right block)\n    }\n\n    // if either of the above calls returned an error (E_DISKFULL), then return that\n    // else return SUCCESS\n}\n")),(0,r.kt)("h3",{id:"bplustreesplitleaf"},"BPlusTree::splitLeaf"),(0,r.kt)("h4",{id:"description-6"},"Description"),(0,r.kt)("p",null,"Distributes an array of index entries between an existing leaf index block and a newly allocated leaf index block."),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"According to the NITCbase specification, this function will only be called from ",(0,r.kt)("a",{parentName:"p",href:"#bplustreeinsertintoleaf"},"insertIntoLeaf()"),".")),(0,r.kt)("h4",{id:"arguments-6"},"Arguments"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Name")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Type")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Description")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"leafBlockNum"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"int")),(0,r.kt)("td",{parentName:"tr",align:null},"The block number of the existing leaf index block that needs to be split")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"indices"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"struct Index[]")),(0,r.kt)("td",{parentName:"tr",align:null},"Array of index entries that needs to be split among two leaf index blocks")))),(0,r.kt)("h4",{id:"return-values-6"},"Return values"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Value")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Description")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"rightBlkNum")),(0,r.kt)("td",{parentName:"tr",align:null},"The block number of the right block in the splitting, that is, the newly allocated block.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/docs/constants"},(0,r.kt)("inlineCode",{parentName:"a"},"E_DISKFULL"))),(0,r.kt)("td",{parentName:"tr",align:null},"If disk space is not sufficient for splitting the leaf index block")))),(0,r.kt)("admonition",{type:"caution"},(0,r.kt)("p",{parentName:"admonition"},"The caller is expected to ensure that"),(0,r.kt)("ul",{parentName:"admonition"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"leafBlockNum")," corresponds to a fully filled leaf index block in a B+ tree"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"indices")," is an array of size ",(0,r.kt)("a",{parentName:"li",href:"/docs/constants"},"MAX_KEYS_LEAF"),"+1 with valid index entries that is to be split among the leaves")),(0,r.kt)("p",{parentName:"admonition"},"This function will distribute ",(0,r.kt)("inlineCode",{parentName:"p"},"indices")," between the two blocks ",(0,r.kt)("strong",{parentName:"p"},"without any validation")," on the argument.")),(0,r.kt)("h4",{id:"algorithm-6"},"Algorithm"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"int BPlusTree::splitLeaf(int leafBlockNum, Index indices[]) {\n    // declare rightBlk, an instance of IndLeaf using constructor 1 to obtain new\n    // leaf index block that will be used as the right block in the splitting\n\n    // declare leftBlk, an instance of IndLeaf using constructor 2 to read from\n    // the existing leaf block\n\n    int rightBlkNum = /* block num of right blk */;\n    int leftBlkNum = /* block num of left blk */;\n\n    if (/* newly allocated block has blockNum E_DISKFULL */) {\n        //(failed to obtain a new leaf index block because the disk is full)\n        return E_DISKFULL;\n    }\n\n    HeadInfo leftBlkHeader, rightBlkHeader;\n    // get the headers of left block and right block using BlockBuffer::getHeader()\n\n    // set rightBlkHeader with the following values\n    // - number of entries = (MAX_KEYS_LEAF+1)/2 = 32,\n    // - pblock = pblock of leftBlk\n    // - lblock = leftBlkNum\n    // - rblock = rblock of leftBlk\n    // and update the header of rightBlk using BlockBuffer::setHeader()\n\n    // set leftBlkHeader with the following values\n    // - number of entries = (MAX_KEYS_LEAF+1)/2 = 32\n    // - rblock = rightBlkNum\n    // and update the header of leftBlk using BlockBuffer::setHeader() */\n\n    // set the first 32 entries of leftBlk = the first 32 entries of indices array\n    // and set the first 32 entries of newRightBlk = the next 32 entries of\n    // indices array using IndLeaf::setEntry().\n\n    return rightBlkNum;\n}\n")),(0,r.kt)("h3",{id:"bplustreeinsertintointernal"},"BPlusTree::insertIntoInternal"),(0,r.kt)("h4",{id:"description-7"},"Description"),(0,r.kt)("p",null,"Used to insert an index entry into an internal index block of an existing B+ tree. This function will call itself to handle any updation required to it's parent internal index blocks."),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"According to the NITCbase specification, this function can only be called from either the ",(0,r.kt)("a",{parentName:"p",href:"#bplustreeinsertintoleaf"},"insertIntoLeaf()")," function or from itself (recursively).")),(0,r.kt)("h4",{id:"arguments-7"},"Arguments"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Name")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Type")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Description")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"relId"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"int")),(0,r.kt)("td",{parentName:"tr",align:null},"Relation Id of the relation containing the attribute")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"attrName"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"char[ATTR_SIZE]")),(0,r.kt)("td",{parentName:"tr",align:null},"Attribute/column name of the relation with given rel-id to whose B+ tree (index) an entry is to be added")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"intBlockNum"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"int")),(0,r.kt)("td",{parentName:"tr",align:null},"The block number of the internal index block to which insertion is to be done")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"intEntry"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"struct InternalEntry")),(0,r.kt)("td",{parentName:"tr",align:null},"The index entry that is to be inserted into the internal index block")))),(0,r.kt)("h4",{id:"return-values-7"},"Return values"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Value")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Description")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/docs/constants"},(0,r.kt)("inlineCode",{parentName:"a"},"SUCCESS"))),(0,r.kt)("td",{parentName:"tr",align:null},"On successful insertion into the internal index block")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/docs/constants"},(0,r.kt)("inlineCode",{parentName:"a"},"E_DISKFULL"))),(0,r.kt)("td",{parentName:"tr",align:null},"If disk space is not sufficient for insertion into the B+ tree")))),(0,r.kt)("admonition",{type:"caution"},(0,r.kt)("p",{parentName:"admonition"},"The caller is expected to ensure that"),(0,r.kt)("ul",{parentName:"admonition"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"intBlockNum")," corresponds to a valid internal index block in the B+ tree corresponding to ",(0,r.kt)("inlineCode",{parentName:"li"},"attrName")," of the relation with specified rel-id."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"intEntry")," contains the correct ",(0,r.kt)("inlineCode",{parentName:"li"},"attrVal"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"lChild")," and ",(0,r.kt)("inlineCode",{parentName:"li"},"rChild")," corresponding to the child that it was called from.")),(0,r.kt)("p",{parentName:"admonition"},"This function will insert ",(0,r.kt)("inlineCode",{parentName:"p"},"intEntry")," to the B+ tree ",(0,r.kt)("strong",{parentName:"p"},"without any validation")," on the arguments.")),(0,r.kt)("h4",{id:"algorithm-7"},"Algorithm"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"int BPlusTree::insertIntoInternal(int relId, char attrName[ATTR_SIZE], int intBlockNum, InternalEntry intEntry) {\n    // get the attribute cache entry corresponding to attrName\n    // using AttrCacheTable::getAttrCatEntry().\n\n    // declare intBlk, an instance of IndInternal using constructor 2 for the block\n    // corresponding to intBlockNum\n\n    HeadInfo blockHeader;\n    // load blockHeader with header of intBlk using BlockBuffer::getHeader().\n\n    // declare internalEntries to store all existing entries + the new entry\n    InternalEntry internalEntries[blockHeader.numEntries + 1];\n\n    /*\n    Iterate through all the entries in the block and copy them to the array\n    `internalEntries`. Insert `indexEntry` at appropriate position in the\n    array maintaining the ascending order.\n        - use IndInternal::getEntry() to get the entry\n        - use compareAttrs() to compare two structs of type Attribute\n\n    Update the lChild of the internalEntry immediately following the newly added\n    entry to the rChild of the newly added entry.\n    */\n\n    if (blockHeader.numEntries != MAX_KEYS_INTERNAL) {\n        // (internal index block has not reached max limit)\n\n        // increment blockheader.numEntries and update the header of intBlk\n        // using BlockBuffer::setHeader().\n\n        // iterate through all entries in internalEntries array and populate the\n        // entries of intBlk with them using IndInternal::setEntry().\n\n        return SUCCESS;\n    }\n\n    // If we reached here, the `internalEntries` array has more than entries than\n    // can fit in a single internal index block. Therefore, we will need to split\n    // the entries in `internalEntries` between two internal index blocks. We do\n    // this using the splitInternal() function.\n    // This function will return the blockNum of the newly allocated block or\n    // E_DISKFULL if there are no more blocks to be allocated.\n\n    int newRightBlk = splitInternal(intBlockNum, internalEntries);\n\n    if (/* splitInternal() returned E_DISKFULL */) {\n\n        // Using bPlusDestroy(), destroy the right subtree, rooted at intEntry.rChild.\n        // This corresponds to the tree built up till now that has not yet been\n        // connected to the existing B+ Tree\n\n        return E_DISKFULL;\n    }\n\n    if (/* the current block was not the root */) {  // (check pblock in header)\n        // insert the middle value from `internalEntries` into the parent block\n        // using the insertIntoInternal() function (recursively).\n\n        // the middle value will be at index 50 (given by constant MIDDLE_INDEX_INTERNAL)\n\n        // create a struct InternalEntry with lChild = current block, rChild = newRightBlk\n        // and attrVal = internalEntries[MIDDLE_INDEX_INTERNAL].attrVal\n        // and pass it as argument to the insertIntoInternalFunction as follows\n\n        // insertIntoInternal(relId, attrName, parent of current block, new internal entry)\n\n    } else {\n        // the current block was the root block and is now split. a new internal index\n        // block needs to be allocated and made the root of the tree.\n        // To do this, call the createNewRoot() function with the following arguments\n\n        // createNewRoot(relId, attrName,\n        //               internalEntries[MIDDLE_INDEX_INTERNAL].attrVal,\n        //               current block, new right block)\n    }\n\n    // if either of the above calls returned an error (E_DISKFULL), then return that\n    // else return SUCCESS\n}\n")),(0,r.kt)("h3",{id:"bplustreesplitinternal"},"BPlusTree::splitInternal"),(0,r.kt)("h4",{id:"description-8"},"Description"),(0,r.kt)("p",null,"Distributes an array of index entries between an existing internal index block and a newly allocated internal index block."),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"According to the NITCbase specification, this function can only be called from ",(0,r.kt)("a",{parentName:"p",href:"#bplustreeinsertintointernal"},"insertIntoInternal()"),".")),(0,r.kt)("h4",{id:"arguments-8"},"Arguments"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Name")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Type")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Description")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"intBlockNum"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"int")),(0,r.kt)("td",{parentName:"tr",align:null},"The block number of the existing internal index block that needs to be split")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"internalEntries"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"struct InternalEntry[]")),(0,r.kt)("td",{parentName:"tr",align:null},"Array of index entries that needs to be split among two internal index blocks")))),(0,r.kt)("h4",{id:"return-values-8"},"Return values"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Value")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Description")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"rightBlkNum")),(0,r.kt)("td",{parentName:"tr",align:null},"The block number of the right block in the splitting, that is, the newly allocated block.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/docs/constants"},(0,r.kt)("inlineCode",{parentName:"a"},"E_DISKFULL"))),(0,r.kt)("td",{parentName:"tr",align:null},"If disk space is not sufficient for splitting the internal index block")))),(0,r.kt)("admonition",{type:"caution"},(0,r.kt)("p",{parentName:"admonition"},"The caller is expected to ensure that"),(0,r.kt)("ul",{parentName:"admonition"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"intBlockNum")," corresponds to a fully filled internal index block in a B+ tree"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"internalEntries")," is an array of size ",(0,r.kt)("a",{parentName:"li",href:"/docs/constants"},"MAX_KEYS_INTERNAL"),"+1 with valid internal index entries that is to be split among two blocks.")),(0,r.kt)("p",{parentName:"admonition"},"This function will distribute ",(0,r.kt)("inlineCode",{parentName:"p"},"internalEntries")," between the two blocks ",(0,r.kt)("strong",{parentName:"p"},"without any validation")," on the argument.")),(0,r.kt)("h4",{id:"algorithm-8"},"Algorithm"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"int BPlusTree::splitInternal(int intBlockNum, InternalEntry internalEntries[]) {\n    // declare rightBlk, an instance of IndInternal using constructor 1 to obtain new\n    // internal index block that will be used as the right block in the splitting\n\n    // declare leftBlk, an instance of IndInternal using constructor 2 to read from\n    // the existing internal index block\n\n    int rightBlkNum = /* block num of right blk */;\n    int leftBlkNum = /* block num of left blk */;\n\n    if (/* newly allocated block has blockNum E_DISKFULL */) {\n        //(failed to obtain a new internal index block because the disk is full)\n        return E_DISKFULL;\n    }\n\n    HeadInfo leftBlkHeader, rightBlkHeader;\n    // get the headers of left block and right block using BlockBuffer::getHeader()\n\n    // set rightBlkHeader with the following values\n    // - number of entries = (MAX_KEYS_INTERNAL)/2 = 50\n    // - pblock = pblock of leftBlk\n    // and update the header of rightBlk using BlockBuffer::setHeader()\n\n    // set leftBlkHeader with the following values\n    // - number of entries = (MAX_KEYS_INTERNAL)/2 = 50\n    // and update the header using BlockBuffer::setHeader()\n\n    /*\n    - set the first 50 entries of leftBlk = index 0 to 49 of internalEntries\n      array\n    - set the first 50 entries of newRightBlk = entries from index 51 to 100\n      of internalEntries array using IndInternal::setEntry().\n      (index 50 will be moving to the parent internal index block)\n    */\n\n    int type = /* block type of a child of any entry of the internalEntries array */;\n    //            (use StaticBuffer::getStaticBlockType())\n\n    for (/* each child block of the new right block */) {\n        // declare an instance of BlockBuffer to access the child block using\n        // constructor 2\n\n        // update pblock of the block to rightBlkNum using BlockBuffer::getHeader()\n        // and BlockBuffer::setHeader().\n    }\n\n    return rightBlkNum;\n}\n")),(0,r.kt)("h3",{id:"bplustreecreatenewroot"},"BPlusTree::createNewRoot"),(0,r.kt)("h4",{id:"description-9"},"Description"),(0,r.kt)("p",null,"Used to update the root of an existing B+ tree when the previous root block was split. This function will allocate a new root block and update the attribute cache entry of the attribute in the specified relation to point to the new root block."),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"According to the NITCbase specification, this function can only be called from either the ",(0,r.kt)("a",{parentName:"p",href:"#bplustreeinsertintoleaf"},"insertIntoLeaf()")," function or from the ",(0,r.kt)("a",{parentName:"p",href:"#bplustreeinsertintointernal"},"insertIntoInternal()")," function.")),(0,r.kt)("h4",{id:"arguments-9"},"Arguments"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Name")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Type")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Description")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"relId"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"int")),(0,r.kt)("td",{parentName:"tr",align:null},"Relation Id of the relation containing the attribute.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"attrName"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"char[ATTR_SIZE]")),(0,r.kt)("td",{parentName:"tr",align:null},"Attribute/column name of the relation with given rel-id to whose B+ tree (index) an entry is to be added")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"attrVal"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"union Attribute")),(0,r.kt)("td",{parentName:"tr",align:null},"Attribute value that needs to be inserted into the root block")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"lChild"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"int")),(0,r.kt)("td",{parentName:"tr",align:null},"The block number of the left child of the new entry in the root block")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"rChild"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"int")),(0,r.kt)("td",{parentName:"tr",align:null},"The block number of the right child of the new entry in the root block")))),(0,r.kt)("h4",{id:"return-values-9"},"Return values"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Value")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Description")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/docs/constants"},(0,r.kt)("inlineCode",{parentName:"a"},"SUCCESS"))),(0,r.kt)("td",{parentName:"tr",align:null},"On successful insertion into the B+ tree of the attribute")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/docs/constants"},(0,r.kt)("inlineCode",{parentName:"a"},"E_DISKFULL"))),(0,r.kt)("td",{parentName:"tr",align:null},"If disk space is not sufficient for insertion into the B+ tree")))),(0,r.kt)("admonition",{type:"caution"},(0,r.kt)("p",{parentName:"admonition"},"The caller is expected to ensure that"),(0,r.kt)("ul",{parentName:"admonition"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"relId")," corresponds to an open relation"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"attrName")," corresponds to the attribute of the specified relation whose index needs to be re-rooted."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"attrVal")," is of the same type as the attribute of the relation"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"lChild")," and ",(0,r.kt)("inlineCode",{parentName:"li"},"rChild")," correspond to the blocks that resulted from the split of the previous root block.")),(0,r.kt)("p",{parentName:"admonition"},"This function will update the root of the B+ tree ",(0,r.kt)("strong",{parentName:"p"},"without any validation")," on the arguments.")),(0,r.kt)("h4",{id:"algorithm-9"},"Algorithm"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"int BPlusTree::createNewRoot(int relId, char attrName[ATTR_SIZE], Attribute attrVal, int lChild, int rChild) {\n    // get the attribute cache entry corresponding to attrName\n    // using AttrCacheTable::getAttrCatEntry().\n\n    // declare newRootBlk, an instance of IndInternal using appropriate constructor\n    // to allocate a new internal index block on the disk\n\n    int newRootBlkNum = /* block number of newRootBlk */;\n\n    if (newRootBlkNum == E_DISKFULL) {\n        // (failed to obtain an empty internal index block because the disk is full)\n\n        // Using bPlusDestroy(), destroy the right subtree, rooted at rChild.\n        // This corresponds to the tree built up till now that has not yet been\n        // connected to the existing B+ Tree\n\n        return E_DISKFULL;\n    }\n\n    // update the header of the new block with numEntries = 1 using\n    // BlockBuffer::getHeader() and BlockBuffer::setHeader()\n\n    // create a struct InternalEntry with lChild, attrVal and rChild from the\n    // arguments and set it as the first entry in newRootBlk using IndInternal::setEntry()\n\n    // declare BlockBuffer instances for the `lChild` and `rChild` blocks using\n    // appropriate constructor and update the pblock of those blocks to `newRootBlkNum`\n    // using BlockBuffer::getHeader() and BlockBuffer::setHeader()\n\n    // update rootBlock = newRootBlkNum for the entry corresponding to `attrName`\n    // in the attribute cache using AttrCacheTable::setAttrCatEntry().\n\n    return SUCCESS;\n}\n")))}h.isMDXComponent=!0}}]);