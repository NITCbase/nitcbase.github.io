"use strict";(self.webpackChunknitcbase=self.webpackChunknitcbase||[]).push([[7451],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>m});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var d=a.createContext({}),s=function(e){var t=a.useContext(d),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},u=function(e){var t=s(e.components);return a.createElement(d.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,d=e.parentName,u=o(e,["components","mdxType","originalType","parentName"]),c=s(n),m=r,h=c["".concat(d,".").concat(m)]||c[m]||p[m]||i;return n?a.createElement(h,l(l({ref:t},u),{},{components:n})):a.createElement(h,l({ref:t},u))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,l=new Array(i);l[0]=c;var o={};for(var d in t)hasOwnProperty.call(t,d)&&(o[d]=t[d]);o.originalType=e,o.mdxType="string"==typeof e?e:r,l[1]=o;for(var s=2;s<i;s++)l[s]=n[s];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},8421:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>l,default:()=>p,frontMatter:()=>i,metadata:()=>o,toc:()=>s});var a=n(7462),r=(n(7294),n(3905));const i={title:"classes IndBuffer, IndInternal, IndLeaf",sidebar_position:4},l=void 0,o={unversionedId:"Design/Buffer Layer/IndBuffer",id:"Design/Buffer Layer/IndBuffer",title:"classes IndBuffer, IndInternal, IndLeaf",description:"class IndBuffer",source:"@site/docs/Design/Buffer Layer/IndBuffer.md",sourceDirName:"Design/Buffer Layer",slug:"/Design/Buffer Layer/IndBuffer",permalink:"/docs/Design/Buffer Layer/IndBuffer",draft:!1,tags:[],version:"current",sidebarPosition:4,frontMatter:{title:"classes IndBuffer, IndInternal, IndLeaf",sidebar_position:4},sidebar:"Design",previous:{title:"class RecBuffer",permalink:"/docs/Design/Buffer Layer/RecBuffer"},next:{title:"Physical Layer",permalink:"/docs/Design/Physical Layer"}},d={},s=[{value:"class IndBuffer",id:"class-indbuffer",level:2},{value:"IndBuffer :: IndBuffer() (Constructor 1)",id:"indbuffer--indbuffer-constructor-1",level:3},{value:"Description",id:"description",level:4},{value:"Arguments",id:"arguments",level:4},{value:"Return Values",id:"return-values",level:4},{value:"Algorithm",id:"algorithm",level:4},{value:"IndBuffer :: IndBuffer() (Constructor 2)",id:"indbuffer--indbuffer-constructor-2",level:3},{value:"Description",id:"description-1",level:4},{value:"Arguments",id:"arguments-1",level:4},{value:"Return Values",id:"return-values-1",level:4},{value:"Algorithm",id:"algorithm-1",level:4},{value:"class IndInternal",id:"class-indinternal",level:2},{value:"IndInternal :: IndInternal() (Constructor1)",id:"indinternal--indinternal-constructor1",level:3},{value:"Description",id:"description-2",level:4},{value:"Arguments",id:"arguments-2",level:4},{value:"Return Values",id:"return-values-2",level:4},{value:"IndInternal :: IndInternal() (Constructor2)",id:"indinternal--indinternal-constructor2",level:3},{value:"Description",id:"description-3",level:4},{value:"Arguments",id:"arguments-3",level:4},{value:"Return Values",id:"return-values-3",level:4},{value:"IndInternal :: getEntry()",id:"indinternal--getentry",level:3},{value:"Description",id:"description-4",level:4},{value:"Arguments",id:"arguments-4",level:4},{value:"Return Values",id:"return-values-4",level:4},{value:"Algorithm",id:"algorithm-2",level:4},{value:"IndInternal :: setEntry()",id:"indinternal--setentry",level:3},{value:"Description",id:"description-5",level:4},{value:"Arguments",id:"arguments-5",level:4},{value:"Return Values",id:"return-values-5",level:4},{value:"Algorithm",id:"algorithm-3",level:4},{value:"class IndLeaf",id:"class-indleaf",level:2},{value:"IndLeaf :: IndLeaf() (Constructor 1)",id:"indleaf--indleaf-constructor-1",level:3},{value:"Description",id:"description-6",level:4},{value:"Arguments",id:"arguments-6",level:4},{value:"Return Values",id:"return-values-6",level:4},{value:"Algorithm",id:"algorithm-4",level:4},{value:"IndLeaf :: IndLeaf() (Constructor 2)",id:"indleaf--indleaf-constructor-2",level:3},{value:"Description",id:"description-7",level:4},{value:"Arguments",id:"arguments-7",level:4},{value:"Return Values",id:"return-values-7",level:4},{value:"Algorithm",id:"algorithm-5",level:4},{value:"IndLeaf :: getEntry()",id:"indleaf--getentry",level:3},{value:"Description",id:"description-8",level:4},{value:"Arguments",id:"arguments-8",level:4},{value:"Return Values",id:"return-values-8",level:4},{value:"Algorithm",id:"algorithm-6",level:4},{value:"IndLeaf :: setEntry()",id:"indleaf--setentry",level:3},{value:"Description",id:"description-9",level:4},{value:"Arguments",id:"arguments-9",level:4},{value:"Return Values",id:"return-values-9",level:4},{value:"Algorithm",id:"algorithm-7",level:4}],u={toc:s};function p(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h2",{id:"class-indbuffer"},"class IndBuffer"),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"IndBuffer")," class is a generic class for representing an ",(0,r.kt)("em",{parentName:"p"},"Index")," block. ",(0,r.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/B%2B_tree"},"B+ Trees")," are constructed using ",(0,r.kt)("em",{parentName:"p"},"Index")," blocks which can be either ",(0,r.kt)("a",{parentName:"p",href:"../../Design/Physical%20Layer#internal-index-block-structure"},"Index Internal blocks")," or ",(0,r.kt)("a",{parentName:"p",href:"../../Design/Physical%20Layer#leaf-index-block-structure"},"Index Leaf blocks"),". B+ Tree helps in faster data access as compared to sequentially accessing the data through ",(0,r.kt)("a",{parentName:"p",href:"../../Design/Physical%20Layer#record-block-structure"},"Record")," blocks."),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"IndBuffer")," class extends the ",(0,r.kt)("a",{parentName:"p",href:"#class-blockbuffer"},"BlockBuffer")," class. Thus, all its protected fields and methods can be accessed by ",(0,r.kt)("em",{parentName:"p"},"IndBuffer")," class. In addition to these, ",(0,r.kt)("em",{parentName:"p"},"IndBuffer")," class has two ",(0,r.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Virtual_function#Abstract_classes_and_pure_virtual_functions"},"pure virtual methods"),"- ",(0,r.kt)("inlineCode",{parentName:"p"},"getEntry()")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"setEntry()"),". These methods take an argument of type ",(0,r.kt)("inlineCode",{parentName:"p"},"void *")," so that arguments of both ",(0,r.kt)("a",{parentName:"p",href:"#internalentry"},(0,r.kt)("inlineCode",{parentName:"a"},"struct InternalEntry"))," and ",(0,r.kt)("a",{parentName:"p",href:"#index"},(0,r.kt)("inlineCode",{parentName:"a"},"struct Index"))," type can be passed to it. This is based on the fact that a ",(0,r.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Void_type"},"void pointer")," can hold address of any type and can be typcasted to any type."),(0,r.kt)("p",null,"The children classes, ",(0,r.kt)("a",{parentName:"p",href:"#class-indinternal"},"IndInternal")," and ",(0,r.kt)("a",{parentName:"p",href:"#class-indleaf"},"IndLeaf"),", extend the class IndBuffer and override the virtual functions. The constructors of ",(0,r.kt)("em",{parentName:"p"},"IndBuffer")," class simply calls the constructor of the parent class with the received argument."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"class IndBuffer : public BlockBuffer {\n\npublic:\n    //methods\n    IndBuffer(char blockType);\n    IndBuffer(int blockNum);\n    virtual int getEntry(void *ptr, int indexNum) = 0;\n    virtual int setEntry(void *ptr, int indexNum) = 0;\n\n};\n")),(0,r.kt)("p",null,"The following are the specifications for the methods in class IndBuffer."),(0,r.kt)("h3",{id:"indbuffer--indbuffer-constructor-1"},"IndBuffer :: IndBuffer() (Constructor 1)"),(0,r.kt)("h4",{id:"description"},"Description"),(0,r.kt)("p",null,"Called if a new index block of the input type is to be allocated in the disk."),(0,r.kt)("h4",{id:"arguments"},"Arguments"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Name")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Type")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Description")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"blockType"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"char")),(0,r.kt)("td",{parentName:"tr",align:null},"The block type indicating whether it is an internal index block (",(0,r.kt)("a",{parentName:"td",href:"/constants"},(0,r.kt)("inlineCode",{parentName:"a"},"IND_INTERNAL")),") or a leaf index block (",(0,r.kt)("a",{parentName:"td",href:"/constants"},(0,r.kt)("inlineCode",{parentName:"a"},"IND_LEAF")),").")))),(0,r.kt)("h4",{id:"return-values"},"Return Values"),(0,r.kt)("p",null,"Nil"),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"If the block already has already been initialised as an index block on the disk, use ",(0,r.kt)("a",{parentName:"p",href:"#indbuffer--indbuffer-constructor-2"},"constructor 2"),".")),(0,r.kt)("h4",{id:"algorithm"},"Algorithm"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"// call the corresponding parent constructor\nIndBuffer::IndBuffer(char blockType) : BlockBuffer(blockType){}\n\n")),(0,r.kt)("h3",{id:"indbuffer--indbuffer-constructor-2"},"IndBuffer :: IndBuffer() (Constructor 2)"),(0,r.kt)("h4",{id:"description-1"},"Description"),(0,r.kt)("p",null,"Called when the block has already been initialised as an index block on the disk."),(0,r.kt)("h4",{id:"arguments-1"},"Arguments"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Name")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Type")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Description")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"blockNum"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"int")),(0,r.kt)("td",{parentName:"tr",align:null},"Block number of the index block.")))),(0,r.kt)("h4",{id:"return-values-1"},"Return Values"),(0,r.kt)("p",null,"Nil"),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"If a new index block is to be allocated in the disk use ",(0,r.kt)("a",{parentName:"p",href:"#indbuffer--indbuffer-constructor-1"},"constructor 1"),".")),(0,r.kt)("h4",{id:"algorithm-1"},"Algorithm"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"// call the corresponding parent constructor\nIndBuffer::IndBuffer(int blockNum) : BlockBuffer(blockNum){}\n")),(0,r.kt)("h2",{id:"class-indinternal"},"class IndInternal"),(0,r.kt)("p",null,"An object of the ",(0,r.kt)("inlineCode",{parentName:"p"},"class IndInternal")," is associated with an ",(0,r.kt)("strong",{parentName:"p"},"Internal Index block"),". An Internal Index block stores entries of type ",(0,r.kt)("inlineCode",{parentName:"p"},"struct InternalEntry")," and is used as the ",(0,r.kt)("strong",{parentName:"p"},"internal nodes of a B+ Tree"),". Public methods of this class deal with the access/modification of the InternalEntry entries. ",(0,r.kt)("inlineCode",{parentName:"p"},"IndInternal class")," extends ",(0,r.kt)("inlineCode",{parentName:"p"},"IndBuffer class")," and overrides its virtual methods. The constructor of the IndInternal class calls the constructor of the parent class by passing suitable argument."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"class IndInternal : public IndBuffer {\n\npublic:\n    //methods\n    IndInternal();\n    IndInternal(int blockNum);\n    int getEntry(void *ptr, int indexNum);\n    int setEntry(void *ptr, int indexNum);\n\n};\n")),(0,r.kt)("p",null,"The following are the specifications for the methods in ",(0,r.kt)("inlineCode",{parentName:"p"},"class IndInternal"),"."),(0,r.kt)("h3",{id:"indinternal--indinternal-constructor1"},"IndInternal :: IndInternal() (Constructor1)"),(0,r.kt)("h4",{id:"description-2"},"Description"),(0,r.kt)("p",null,"Called if a new internal index block is to be allocated in the disk."),(0,r.kt)("h4",{id:"arguments-2"},"Arguments"),(0,r.kt)("p",null,"Nil"),(0,r.kt)("h4",{id:"return-values-2"},"Return Values"),(0,r.kt)("p",null,"Nil"),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"If the block has already been initialised as an internal index block on the disk, use ",(0,r.kt)("a",{parentName:"p",href:"#indinternal--indinternal-constructor2"},"constructor 2"),".")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"IndInternal::IndInternal() : IndBuffer('I'){}\n// call the corresponding parent constructor\n// 'I' used to denote IndInternal.\n")),(0,r.kt)("h3",{id:"indinternal--indinternal-constructor2"},"IndInternal :: IndInternal() (Constructor2)"),(0,r.kt)("h4",{id:"description-3"},"Description"),(0,r.kt)("p",null,"Called when the block has already been initialised as an internal index block on the disk."),(0,r.kt)("h4",{id:"arguments-3"},"Arguments"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Name")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Type")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Description")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"blockNum"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"int")),(0,r.kt)("td",{parentName:"tr",align:null},"Block number of the internal index block.")))),(0,r.kt)("h4",{id:"return-values-3"},"Return Values"),(0,r.kt)("p",null,"Nil"),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"If a new internal index block is to be allocated in the disk use ",(0,r.kt)("a",{parentName:"p",href:"#indinternal--indinternal-constructor1"},"constructor 1"),".")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"IndInternal::IndInternal(int blockNum) : IndBuffer(blockNum){}\n// call the corresponding parent constructor\n")),(0,r.kt)("h3",{id:"indinternal--getentry"},"IndInternal :: getEntry()"),(0,r.kt)("h4",{id:"description-4"},"Description"),(0,r.kt)("p",null,"Gives the indexNum",(0,r.kt)("sup",null,"th")," entry of the block."),(0,r.kt)("h4",{id:"arguments-4"},"Arguments"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Name")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Type")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Description")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"ptr"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"void *")),(0,r.kt)("td",{parentName:"tr",align:null},"Pointer to the struct InternalEntry to which the specified internal index entry of the block is copied.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"indexNum"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"int")),(0,r.kt)("td",{parentName:"tr",align:null},"Index number of the entry in the block.")))),(0,r.kt)("h4",{id:"return-values-4"},"Return Values"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Value")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Description")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/constants"},(0,r.kt)("inlineCode",{parentName:"a"},"SUCCESS"))),(0,r.kt)("td",{parentName:"tr",align:null},"Successful copy of the internal index entry.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/constants"},(0,r.kt)("inlineCode",{parentName:"a"},"E_OUTOFBOUND"))),(0,r.kt)("td",{parentName:"tr",align:null},"Input indexNum is outside the valid range of index numbers of the block.")))),(0,r.kt)("admonition",{title:"note",type:"caution"},(0,r.kt)("ul",{parentName:"admonition"},(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("inlineCode",{parentName:"li"},"void")," pointer is a generic pointer that can be pointed at objects of any data type. However, because the ",(0,r.kt)("inlineCode",{parentName:"li"},"void")," pointer does not know what type of object it is pointing to, it must first be explicitly cast to another pointer type before it is dereferenced."),(0,r.kt)("li",{parentName:"ul"},"The higher layers calling the ",(0,r.kt)("inlineCode",{parentName:"li"},"getEntry()")," function of the ",(0,r.kt)("inlineCode",{parentName:"li"},"IndInternal class")," must ensure that the argument of type ",(0,r.kt)("inlineCode",{parentName:"li"},"struct InternalEntry *")," is passed."),(0,r.kt)("li",{parentName:"ul"},"The higher layers must allocate memory for the ",(0,r.kt)("inlineCode",{parentName:"li"},"struct InternalEntry")," before calling this function."),(0,r.kt)("li",{parentName:"ul"},"The alignment of the ",(0,r.kt)("inlineCode",{parentName:"li"},"InternalEntry")," structure in memory ",(0,r.kt)("a",{parentName:"li",href:"https://en.wikipedia.org/wiki/Data_structure_alignment#Data_structure_padding"},"might be different")," from the way it is organized in our disk. Make sure to copy each element of the structure separately with appropriate offset. Using ",(0,r.kt)("inlineCode",{parentName:"li"},"memcpy")," on the whole object can lead to errors."))),(0,r.kt)("h4",{id:"algorithm-2"},"Algorithm"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"int IndInternal::getEntry(void *ptr, int indexNum) {\n    // if the indexNum is not in the valid range of [0, MAX_KEYS_INTERNAL-1]\n    //     return E_OUTOFBOUND.\n\n    unsigned char *bufferPtr;\n    /* get the starting address of the buffer containing the block\n       using loadBlockAndGetBufferPtr(&bufferPtr). */\n\n    // if loadBlockAndGetBufferPtr(&bufferPtr) != SUCCESS\n    //     return the value returned by the call.\n\n    // typecast the void pointer to an internal entry pointer\n    struct InternalEntry *internalEntry = (struct InternalEntry *)ptr;\n\n    /*\n    - copy the entries from the indexNum`th entry to *internalEntry\n    - make sure that each field is copied individually as in the following code\n    - the lChild and rChild fields of InternalEntry are of type int32_t\n    - int32_t is a type of int that is guaranteed to be 4 bytes across every\n      C++ implementation. sizeof(int32_t) = 4\n    */\n\n    /* the indexNum'th entry will begin at an offset of\n       HEADER_SIZE + (indexNum * (sizeof(int) + ATTR_SIZE) )         [why?]\n       from bufferPtr */\n    unsigned char *entryPtr = bufferPtr + HEADER_SIZE + (indexNum * 20);\n\n    memcpy(&(internalEntry->lChild), entryPtr, sizeof(int32_t));\n    memcpy(&(internalEntry->attrVal), entryPtr + 4, sizeof(Attribute));\n    memcpy(&(internalEntry->rChild), entryPtr + 20, 4);\n\n    // return SUCCESS.\n}\n")),(0,r.kt)("h3",{id:"indinternal--setentry"},"IndInternal :: setEntry()"),(0,r.kt)("h4",{id:"description-5"},"Description"),(0,r.kt)("p",null,"Sets the indexNum",(0,r.kt)("sup",null,"th")," entry of the block with the input struct InternalEntry contents."),(0,r.kt)("h4",{id:"arguments-5"},"Arguments"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Name")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Type")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Description")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"ptr"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"void *")),(0,r.kt)("td",{parentName:"tr",align:null},"Pointer to the struct InternalEntry from which the specified internal index entry of the block is set.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"indexNum"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"int")),(0,r.kt)("td",{parentName:"tr",align:null},"Index number of the entry in the block.")))),(0,r.kt)("h4",{id:"return-values-5"},"Return Values"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Value")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Description")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/constants"},(0,r.kt)("inlineCode",{parentName:"a"},"SUCCESS"))),(0,r.kt)("td",{parentName:"tr",align:null},"Successful copy of the internal index entry.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/constants"},(0,r.kt)("inlineCode",{parentName:"a"},"E_OUTOFBOUND"))),(0,r.kt)("td",{parentName:"tr",align:null},"Input indexNum is outside the valid range of index numbers of the block.")))),(0,r.kt)("admonition",{title:"note",type:"caution"},(0,r.kt)("ul",{parentName:"admonition"},(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("inlineCode",{parentName:"li"},"void")," pointer is a generic pointer that can be pointed at objects of any data type. However, because the ",(0,r.kt)("inlineCode",{parentName:"li"},"void")," pointer does not know what type of object it is pointing to, it must first be explicitly cast to another pointer type before it is dereferenced."),(0,r.kt)("li",{parentName:"ul"},"The higher layers calling the ",(0,r.kt)("inlineCode",{parentName:"li"},"setEntry()")," method of the ",(0,r.kt)("inlineCode",{parentName:"li"},"IndInternal class")," must ensure that the argument of type ",(0,r.kt)("inlineCode",{parentName:"li"},"struct InternalEntry *")," is passed."),(0,r.kt)("li",{parentName:"ul"},"The higher layers must allocate memory for the ",(0,r.kt)("inlineCode",{parentName:"li"},"struct InternalEntry")," before calling this function."),(0,r.kt)("li",{parentName:"ul"},"The alignment of the ",(0,r.kt)("inlineCode",{parentName:"li"},"InternalEntry")," structure in memory might be different from the way it is organized in our disk. Make sure to copy each element of the structure separately with appropriate offset. Using ",(0,r.kt)("inlineCode",{parentName:"li"},"memcpy")," on the whole object can lead to errors."))),(0,r.kt)("h4",{id:"algorithm-3"},"Algorithm"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"int IndInternal::setEntry(void *ptr, int indexNum) {\n    // if the indexNum is not in the valid range of [0, MAX_KEYS_INTERNAL-1]\n    //     return E_OUTOFBOUND.\n\n    unsigned char *bufferPtr;\n    /* get the starting address of the buffer containing the block\n       using loadBlockAndGetBufferPtr(&bufferPtr). */\n\n    // if loadBlockAndGetBufferPtr(&bufferPtr) != SUCCESS\n    //     return the value returned by the call.\n\n    // typecast the void pointer to an internal entry pointer\n    struct InternalEntry *internalEntry = (struct InternalEntry *)ptr;\n\n    /*\n    - copy the entries from *internalEntry to the indexNum`th entry\n    - make sure that each field is copied individually as in the following code\n    - the lChild and rChild fields of InternalEntry are of type int32_t\n    - int32_t is a type of int that is guaranteed to be 4 bytes across every\n      C++ implementation. sizeof(int32_t) = 4\n    */\n\n    /* the indexNum'th entry will begin at an offset of\n       HEADER_SIZE + (indexNum * (sizeof(int) + ATTR_SIZE) )         [why?]\n       from bufferPtr */\n\n    unsigned char *entryPtr = bufferPtr + HEADER_SIZE + (indexNum * 20);\n\n    memcpy(entryPtr, &(internalEntry->lChild), 4);\n    memcpy(entryPtr + 4, &(internalEntry->attrVal), ATTR_SIZE);\n    memcpy(entryPtr + 20, &(internalEntry->rChild), 4);\n\n\n    // update dirty bit using setDirtyBit()\n    // if setDirtyBit failed, return the value returned by the call\n\n    // return SUCCESS\n}\n")),(0,r.kt)("h2",{id:"class-indleaf"},"class IndLeaf"),(0,r.kt)("p",null,"An object of the ",(0,r.kt)("em",{parentName:"p"},"IndLeaf")," class will be associated with a ",(0,r.kt)("a",{parentName:"p",href:"../../Design/Physical%20Layer#leaf-index-block-structure"},"Index Leaf blocks"),". A Leaf Index block stores entries of type ",(0,r.kt)("inlineCode",{parentName:"p"},"struct Index")," and is used as the leaf nodes of a B+ Tree. Public methods of this class deal with the access/modification of the ",(0,r.kt)("em",{parentName:"p"},"Index")," entries. ","*",(0,r.kt)("em",{parentName:"p"},"IndLeaf")," class extends ",(0,r.kt)("a",{parentName:"p",href:"#class-indbuffer"},"IndBuffer class")," and overrides its virtual methods. The constructor of the IndLeaf class calls the constructor of the parent class by passing suitable argument."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"class IndLeaf : public IndBuffer{\n\npublic:\n    //methods\n    IndLeaf();\n    IndLeaf(int blockNum);\n    int getEntry(void *ptr, int indexNum) ;\n    int setEntry(void *ptr, int indexNum) ;\n\n};\n")),(0,r.kt)("p",null,"The following are the specifications for the methods in class IndLeaf."),(0,r.kt)("h3",{id:"indleaf--indleaf-constructor-1"},"IndLeaf :: IndLeaf() (Constructor 1)"),(0,r.kt)("h4",{id:"description-6"},"Description"),(0,r.kt)("p",null,"Called if a new leaf index block is to be allocated in the disk."),(0,r.kt)("h4",{id:"arguments-6"},"Arguments"),(0,r.kt)("p",null,"Nil"),(0,r.kt)("h4",{id:"return-values-6"},"Return Values"),(0,r.kt)("p",null,"Nil"),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"If the block has already been initialised as a leaf index block on the disk, use ",(0,r.kt)("a",{parentName:"p",href:"#indleaf-constructor-2"},"constructor 2"),".")),(0,r.kt)("h4",{id:"algorithm-4"},"Algorithm"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"IndLeaf::IndLeaf() : IndBuffer('L'){} // this is the way to call parent non-default constructor.\n                      // 'L' used to denote IndLeaf.\n\n")),(0,r.kt)("h3",{id:"indleaf--indleaf-constructor-2"},"IndLeaf :: IndLeaf() (Constructor 2)"),(0,r.kt)("h4",{id:"description-7"},"Description"),(0,r.kt)("p",null,"Called when the block has already been initialised as a leaf index block on the disk."),(0,r.kt)("h4",{id:"arguments-7"},"Arguments"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Name")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Type")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Description")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"blockNum"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"int")),(0,r.kt)("td",{parentName:"tr",align:null},"Block number of the leaf index block.")))),(0,r.kt)("h4",{id:"return-values-7"},"Return Values"),(0,r.kt)("p",null,"Nil"),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"If a new leaf index block is to be allocated in the disk use ",(0,r.kt)("a",{parentName:"p",href:"#indleaf-constructor-1"},"constructor 1"),".")),(0,r.kt)("h4",{id:"algorithm-5"},"Algorithm"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"//this is the way to call parent non-default constructor.\nIndLeaf::IndLeaf(int blockNum) : IndBuffer(blockNum){}\n")),(0,r.kt)("h3",{id:"indleaf--getentry"},"IndLeaf :: getEntry()"),(0,r.kt)("h4",{id:"description-8"},"Description"),(0,r.kt)("p",null,"Gives the indexNum",(0,r.kt)("sup",null,"th")," entry of the block."),(0,r.kt)("h4",{id:"arguments-8"},"Arguments"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Name")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Type")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Description")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"ptr"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"void *")),(0,r.kt)("td",{parentName:"tr",align:null},"Pointer to the ",(0,r.kt)("a",{parentName:"td",href:"#index"},"struct Index")," to which the specified leaf index entry of the block is copied.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"indexNum"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"int")),(0,r.kt)("td",{parentName:"tr",align:null},"Index number of the entry in the block.")))),(0,r.kt)("h4",{id:"return-values-8"},"Return Values"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Value")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Description")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/constants"},(0,r.kt)("inlineCode",{parentName:"a"},"SUCCESS"))),(0,r.kt)("td",{parentName:"tr",align:null},"Successful getting of the leaf index entry.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/constants"},(0,r.kt)("inlineCode",{parentName:"a"},"E_OUTOFBOUND"))),(0,r.kt)("td",{parentName:"tr",align:null},"Input ",(0,r.kt)("inlineCode",{parentName:"td"},"indexNum")," is outside the valid range of index numbers of the block.")))),(0,r.kt)("admonition",{title:"note",type:"caution"},(0,r.kt)("ul",{parentName:"admonition"},(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("a",{parentName:"li",href:"https://en.wikipedia.org/wiki/Void_type"},"void pointer")," is a generic pointer that can be pointed at objects of any data type. However, because the void pointer does not know what type of object it is pointing to, the void pointer must first be explicitly cast to another pointer type before it is dereferenced."),(0,r.kt)("li",{parentName:"ul"},"The higher layers calling the ",(0,r.kt)("inlineCode",{parentName:"li"},"getEntry()")," function of the ",(0,r.kt)("em",{parentName:"li"},"IndLeaf")," class must ensure that the argument of type ",(0,r.kt)("inlineCode",{parentName:"li"},"struct Index *")," is passed."),(0,r.kt)("li",{parentName:"ul"},"The higher layers must allocate memory for the ",(0,r.kt)("inlineCode",{parentName:"li"},"struct Index")," before calling this function."),(0,r.kt)("li",{parentName:"ul"},"The alignment of the ",(0,r.kt)("inlineCode",{parentName:"li"},"Index")," structure in memory might be different from the way it is organized in our disk. Make sure to copy each element of the structure separately with appropriate offset. Using ",(0,r.kt)("inlineCode",{parentName:"li"},"memcpy")," on the whole object can lead to errors."))),(0,r.kt)("h4",{id:"algorithm-6"},"Algorithm"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"int IndLeaf::getEntry(void *ptr, int indexNum) {\n\n    // if the indexNum is not in the valid range of [0, MAX_KEYS_LEAF-1]\n    //     return E_OUTOFBOUND.\n\n    unsigned char *bufferPtr;\n    /* get the starting address of the buffer containing the block\n       using loadBlockAndGetBufferPtr(&bufferPtr). */\n\n    // if loadBlockAndGetBufferPtr(&bufferPtr) != SUCCESS\n    //     return the value returned by the call.\n\n    // copy the indexNum'th Index entry in buffer to memory ptr using memcpy\n\n    /* the indexNum'th entry will begin at an offset of\n       HEADER_SIZE + (indexNum * LEAF_ENTRY_SIZE)  from bufferPtr */\n    unsigned char *entryPtr = bufferPtr + HEADER_SIZE + (indexNum * LEAF_ENTRY_SIZE);\n    memcpy((struct Index *)ptr, entryPtr, LEAF_ENTRY_SIZE);\n\n    // return SUCCESS\n}\n")),(0,r.kt)("h3",{id:"indleaf--setentry"},"IndLeaf :: setEntry()"),(0,r.kt)("h4",{id:"description-9"},"Description"),(0,r.kt)("p",null,"Sets the indexNum",(0,r.kt)("sup",null,"th")," entry of the block with the input struct Index contents."),(0,r.kt)("h4",{id:"arguments-9"},"Arguments"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Name")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Type")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Description")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"ptr"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"void *")),(0,r.kt)("td",{parentName:"tr",align:null},"Pointer to the ",(0,r.kt)("a",{parentName:"td",href:"#index"},"struct Index")," to which the specified leaf index entry of the block is copied.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"indexNum"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"int")),(0,r.kt)("td",{parentName:"tr",align:null},"Index number of the entry in the block.")))),(0,r.kt)("h4",{id:"return-values-9"},"Return Values"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Value")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Description")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/constants"},(0,r.kt)("inlineCode",{parentName:"a"},"SUCCESS"))),(0,r.kt)("td",{parentName:"tr",align:null},"Successful setting of the leaf index entry.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/constants"},(0,r.kt)("inlineCode",{parentName:"a"},"E_OUTOFBOUND"))),(0,r.kt)("td",{parentName:"tr",align:null},"Input ",(0,r.kt)("inlineCode",{parentName:"td"},"indexNum")," is outside the valid range of index numbers of the block.")))),(0,r.kt)("admonition",{title:"note",type:"caution"},(0,r.kt)("ul",{parentName:"admonition"},(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("a",{parentName:"li",href:"https://en.wikipedia.org/wiki/Void_type"},"void pointer")," is a generic pointer that can be pointed at objects of any data type. However, because the void pointer does not know what type of object it is pointing to, the void pointer must first be explicitly cast to another pointer type before it is dereferenced."),(0,r.kt)("li",{parentName:"ul"},"The higher layers calling the ",(0,r.kt)("inlineCode",{parentName:"li"},"setEntry()")," function of the IndLeaf class must ensure that the argument of type ",(0,r.kt)("inlineCode",{parentName:"li"},"struct Index *")," is passed."),(0,r.kt)("li",{parentName:"ul"},"The higher layers must allocate memory for the struct Index before calling this function."),(0,r.kt)("li",{parentName:"ul"},"The alignment of the ",(0,r.kt)("inlineCode",{parentName:"li"},"Index")," structure in memory might be different from the way it is organized in our disk. Make sure to copy each element of the structure separately with appropriate offset. Using ",(0,r.kt)("inlineCode",{parentName:"li"},"memcpy")," on the whole object can lead to errors."))),(0,r.kt)("h4",{id:"algorithm-7"},"Algorithm"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"int IndLeaf::setEntry(void *ptr, int indexNum) {\n\n    // if the indexNum is not in the valid range of [0, MAX_KEYS_LEAF-1]\n    //     return E_OUTOFBOUND.\n\n    unsigned char *bufferPtr;\n    /* get the starting address of the buffer containing the block\n       using loadBlockAndGetBufferPtr(&bufferPtr). */\n\n    // if loadBlockAndGetBufferPtr(&bufferPtr) != SUCCESS\n    //     return the value returned by the call.\n\n    // copy the Index at ptr to indexNum'th entry in the buffer using memcpy\n\n    /* the indexNum'th entry will begin at an offset of\n       HEADER_SIZE + (indexNum * LEAF_ENTRY_SIZE)  from bufferPtr */\n    unsigned char *entryPtr = bufferPtr + HEADER_SIZE + (indexNum * LEAF_ENTRY_SIZE);\n    memcpy(entryPtr, (struct Index *)ptr, LEAF_ENTRY_SIZE);\n\n    // update dirty bit using setDirtyBit()\n    // if setDirtyBit failed, return the value returned by the call\n\n    //return SUCCESS\n}\n")))}p.isMDXComponent=!0}}]);